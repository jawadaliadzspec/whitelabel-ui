
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model failed_jobs
 * 
 */
export type failed_jobs = $Result.DefaultSelection<Prisma.$failed_jobsPayload>
/**
 * Model jobs
 * 
 */
export type jobs = $Result.DefaultSelection<Prisma.$jobsPayload>
/**
 * Model migrations
 * 
 */
export type migrations = $Result.DefaultSelection<Prisma.$migrationsPayload>
/**
 * Model model_has_permissions
 * 
 */
export type model_has_permissions = $Result.DefaultSelection<Prisma.$model_has_permissionsPayload>
/**
 * Model model_has_roles
 * 
 */
export type model_has_roles = $Result.DefaultSelection<Prisma.$model_has_rolesPayload>
/**
 * Model password_reset_tokens
 * 
 */
export type password_reset_tokens = $Result.DefaultSelection<Prisma.$password_reset_tokensPayload>
/**
 * Model permissions
 * 
 */
export type permissions = $Result.DefaultSelection<Prisma.$permissionsPayload>
/**
 * Model role_has_permissions
 * 
 */
export type role_has_permissions = $Result.DefaultSelection<Prisma.$role_has_permissionsPayload>
/**
 * Model roles
 * 
 */
export type roles = $Result.DefaultSelection<Prisma.$rolesPayload>
/**
 * Model users
 * 
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model cache
 * 
 */
export type cache = $Result.DefaultSelection<Prisma.$cachePayload>
/**
 * Model cache_locks
 * 
 */
export type cache_locks = $Result.DefaultSelection<Prisma.$cache_locksPayload>
/**
 * Model job_batches
 * 
 */
export type job_batches = $Result.DefaultSelection<Prisma.$job_batchesPayload>
/**
 * Model sessions
 * 
 */
export type sessions = $Result.DefaultSelection<Prisma.$sessionsPayload>
/**
 * Model categories
 * 
 */
export type categories = $Result.DefaultSelection<Prisma.$categoriesPayload>
/**
 * Model companies
 * 
 */
export type companies = $Result.DefaultSelection<Prisma.$companiesPayload>
/**
 * Model company_frontend_settings
 * 
 */
export type company_frontend_settings = $Result.DefaultSelection<Prisma.$company_frontend_settingsPayload>
/**
 * Model company_integrations
 * 
 */
export type company_integrations = $Result.DefaultSelection<Prisma.$company_integrationsPayload>
/**
 * Model company_profiles
 * 
 */
export type company_profiles = $Result.DefaultSelection<Prisma.$company_profilesPayload>
/**
 * Model company_subscriptions
 * 
 */
export type company_subscriptions = $Result.DefaultSelection<Prisma.$company_subscriptionsPayload>
/**
 * Model integration_category_mappings
 * 
 */
export type integration_category_mappings = $Result.DefaultSelection<Prisma.$integration_category_mappingsPayload>
/**
 * Model menus
 * 
 */
export type menus = $Result.DefaultSelection<Prisma.$menusPayload>
/**
 * Model offer_category
 * 
 */
export type offer_category = $Result.DefaultSelection<Prisma.$offer_categoryPayload>
/**
 * Model offers
 * 
 */
export type offers = $Result.DefaultSelection<Prisma.$offersPayload>
/**
 * Model payments
 * 
 */
export type payments = $Result.DefaultSelection<Prisma.$paymentsPayload>
/**
 * Model stores
 * This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
 */
export type stores = $Result.DefaultSelection<Prisma.$storesPayload>
/**
 * Model subscriptions
 * 
 */
export type subscriptions = $Result.DefaultSelection<Prisma.$subscriptionsPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const offers_type: {
  deal: 'deal',
  coupon: 'coupon',
  campaign: 'campaign'
};

export type offers_type = (typeof offers_type)[keyof typeof offers_type]

}

export type offers_type = $Enums.offers_type

export const offers_type: typeof $Enums.offers_type

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Failed_jobs
 * const failed_jobs = await prisma.failed_jobs.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Failed_jobs
   * const failed_jobs = await prisma.failed_jobs.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.failed_jobs`: Exposes CRUD operations for the **failed_jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Failed_jobs
    * const failed_jobs = await prisma.failed_jobs.findMany()
    * ```
    */
  get failed_jobs(): Prisma.failed_jobsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jobs`: Exposes CRUD operations for the **jobs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Jobs
    * const jobs = await prisma.jobs.findMany()
    * ```
    */
  get jobs(): Prisma.jobsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.migrations`: Exposes CRUD operations for the **migrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Migrations
    * const migrations = await prisma.migrations.findMany()
    * ```
    */
  get migrations(): Prisma.migrationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.model_has_permissions`: Exposes CRUD operations for the **model_has_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Model_has_permissions
    * const model_has_permissions = await prisma.model_has_permissions.findMany()
    * ```
    */
  get model_has_permissions(): Prisma.model_has_permissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.model_has_roles`: Exposes CRUD operations for the **model_has_roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Model_has_roles
    * const model_has_roles = await prisma.model_has_roles.findMany()
    * ```
    */
  get model_has_roles(): Prisma.model_has_rolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.password_reset_tokens`: Exposes CRUD operations for the **password_reset_tokens** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Password_reset_tokens
    * const password_reset_tokens = await prisma.password_reset_tokens.findMany()
    * ```
    */
  get password_reset_tokens(): Prisma.password_reset_tokensDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.permissions`: Exposes CRUD operations for the **permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permissions.findMany()
    * ```
    */
  get permissions(): Prisma.permissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.role_has_permissions`: Exposes CRUD operations for the **role_has_permissions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Role_has_permissions
    * const role_has_permissions = await prisma.role_has_permissions.findMany()
    * ```
    */
  get role_has_permissions(): Prisma.role_has_permissionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.roles`: Exposes CRUD operations for the **roles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roles
    * const roles = await prisma.roles.findMany()
    * ```
    */
  get roles(): Prisma.rolesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cache`: Exposes CRUD operations for the **cache** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Caches
    * const caches = await prisma.cache.findMany()
    * ```
    */
  get cache(): Prisma.cacheDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cache_locks`: Exposes CRUD operations for the **cache_locks** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cache_locks
    * const cache_locks = await prisma.cache_locks.findMany()
    * ```
    */
  get cache_locks(): Prisma.cache_locksDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.job_batches`: Exposes CRUD operations for the **job_batches** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Job_batches
    * const job_batches = await prisma.job_batches.findMany()
    * ```
    */
  get job_batches(): Prisma.job_batchesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.sessions`: Exposes CRUD operations for the **sessions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.sessions.findMany()
    * ```
    */
  get sessions(): Prisma.sessionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.categories`: Exposes CRUD operations for the **categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Categories
    * const categories = await prisma.categories.findMany()
    * ```
    */
  get categories(): Prisma.categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.companies`: Exposes CRUD operations for the **companies** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Companies
    * const companies = await prisma.companies.findMany()
    * ```
    */
  get companies(): Prisma.companiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company_frontend_settings`: Exposes CRUD operations for the **company_frontend_settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_frontend_settings
    * const company_frontend_settings = await prisma.company_frontend_settings.findMany()
    * ```
    */
  get company_frontend_settings(): Prisma.company_frontend_settingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company_integrations`: Exposes CRUD operations for the **company_integrations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_integrations
    * const company_integrations = await prisma.company_integrations.findMany()
    * ```
    */
  get company_integrations(): Prisma.company_integrationsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company_profiles`: Exposes CRUD operations for the **company_profiles** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_profiles
    * const company_profiles = await prisma.company_profiles.findMany()
    * ```
    */
  get company_profiles(): Prisma.company_profilesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.company_subscriptions`: Exposes CRUD operations for the **company_subscriptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Company_subscriptions
    * const company_subscriptions = await prisma.company_subscriptions.findMany()
    * ```
    */
  get company_subscriptions(): Prisma.company_subscriptionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.integration_category_mappings`: Exposes CRUD operations for the **integration_category_mappings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Integration_category_mappings
    * const integration_category_mappings = await prisma.integration_category_mappings.findMany()
    * ```
    */
  get integration_category_mappings(): Prisma.integration_category_mappingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.menus`: Exposes CRUD operations for the **menus** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Menus
    * const menus = await prisma.menus.findMany()
    * ```
    */
  get menus(): Prisma.menusDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offer_category`: Exposes CRUD operations for the **offer_category** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offer_categories
    * const offer_categories = await prisma.offer_category.findMany()
    * ```
    */
  get offer_category(): Prisma.offer_categoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.offers`: Exposes CRUD operations for the **offers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Offers
    * const offers = await prisma.offers.findMany()
    * ```
    */
  get offers(): Prisma.offersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payments`: Exposes CRUD operations for the **payments** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payments.findMany()
    * ```
    */
  get payments(): Prisma.paymentsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.stores`: Exposes CRUD operations for the **stores** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Stores
    * const stores = await prisma.stores.findMany()
    * ```
    */
  get stores(): Prisma.storesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.subscriptions`: Exposes CRUD operations for the **subscriptions** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subscriptions
    * const subscriptions = await prisma.subscriptions.findMany()
    * ```
    */
  get subscriptions(): Prisma.subscriptionsDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    failed_jobs: 'failed_jobs',
    jobs: 'jobs',
    migrations: 'migrations',
    model_has_permissions: 'model_has_permissions',
    model_has_roles: 'model_has_roles',
    password_reset_tokens: 'password_reset_tokens',
    permissions: 'permissions',
    role_has_permissions: 'role_has_permissions',
    roles: 'roles',
    users: 'users',
    cache: 'cache',
    cache_locks: 'cache_locks',
    job_batches: 'job_batches',
    sessions: 'sessions',
    categories: 'categories',
    companies: 'companies',
    company_frontend_settings: 'company_frontend_settings',
    company_integrations: 'company_integrations',
    company_profiles: 'company_profiles',
    company_subscriptions: 'company_subscriptions',
    integration_category_mappings: 'integration_category_mappings',
    menus: 'menus',
    offer_category: 'offer_category',
    offers: 'offers',
    payments: 'payments',
    stores: 'stores',
    subscriptions: 'subscriptions'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "failed_jobs" | "jobs" | "migrations" | "model_has_permissions" | "model_has_roles" | "password_reset_tokens" | "permissions" | "role_has_permissions" | "roles" | "users" | "cache" | "cache_locks" | "job_batches" | "sessions" | "categories" | "companies" | "company_frontend_settings" | "company_integrations" | "company_profiles" | "company_subscriptions" | "integration_category_mappings" | "menus" | "offer_category" | "offers" | "payments" | "stores" | "subscriptions"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      failed_jobs: {
        payload: Prisma.$failed_jobsPayload<ExtArgs>
        fields: Prisma.failed_jobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.failed_jobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$failed_jobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.failed_jobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$failed_jobsPayload>
          }
          findFirst: {
            args: Prisma.failed_jobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$failed_jobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.failed_jobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$failed_jobsPayload>
          }
          findMany: {
            args: Prisma.failed_jobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$failed_jobsPayload>[]
          }
          create: {
            args: Prisma.failed_jobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$failed_jobsPayload>
          }
          createMany: {
            args: Prisma.failed_jobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.failed_jobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$failed_jobsPayload>
          }
          update: {
            args: Prisma.failed_jobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$failed_jobsPayload>
          }
          deleteMany: {
            args: Prisma.failed_jobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.failed_jobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.failed_jobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$failed_jobsPayload>
          }
          aggregate: {
            args: Prisma.Failed_jobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFailed_jobs>
          }
          groupBy: {
            args: Prisma.failed_jobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Failed_jobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.failed_jobsCountArgs<ExtArgs>
            result: $Utils.Optional<Failed_jobsCountAggregateOutputType> | number
          }
        }
      }
      jobs: {
        payload: Prisma.$jobsPayload<ExtArgs>
        fields: Prisma.jobsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.jobsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.jobsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          findFirst: {
            args: Prisma.jobsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.jobsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          findMany: {
            args: Prisma.jobsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>[]
          }
          create: {
            args: Prisma.jobsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          createMany: {
            args: Prisma.jobsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.jobsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          update: {
            args: Prisma.jobsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          deleteMany: {
            args: Prisma.jobsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.jobsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.jobsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$jobsPayload>
          }
          aggregate: {
            args: Prisma.JobsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJobs>
          }
          groupBy: {
            args: Prisma.jobsGroupByArgs<ExtArgs>
            result: $Utils.Optional<JobsGroupByOutputType>[]
          }
          count: {
            args: Prisma.jobsCountArgs<ExtArgs>
            result: $Utils.Optional<JobsCountAggregateOutputType> | number
          }
        }
      }
      migrations: {
        payload: Prisma.$migrationsPayload<ExtArgs>
        fields: Prisma.migrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.migrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.migrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          findFirst: {
            args: Prisma.migrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.migrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          findMany: {
            args: Prisma.migrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>[]
          }
          create: {
            args: Prisma.migrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          createMany: {
            args: Prisma.migrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.migrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          update: {
            args: Prisma.migrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          deleteMany: {
            args: Prisma.migrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.migrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.migrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$migrationsPayload>
          }
          aggregate: {
            args: Prisma.MigrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMigrations>
          }
          groupBy: {
            args: Prisma.migrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<MigrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.migrationsCountArgs<ExtArgs>
            result: $Utils.Optional<MigrationsCountAggregateOutputType> | number
          }
        }
      }
      model_has_permissions: {
        payload: Prisma.$model_has_permissionsPayload<ExtArgs>
        fields: Prisma.model_has_permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.model_has_permissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.model_has_permissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload>
          }
          findFirst: {
            args: Prisma.model_has_permissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.model_has_permissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload>
          }
          findMany: {
            args: Prisma.model_has_permissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload>[]
          }
          create: {
            args: Prisma.model_has_permissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload>
          }
          createMany: {
            args: Prisma.model_has_permissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.model_has_permissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload>
          }
          update: {
            args: Prisma.model_has_permissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload>
          }
          deleteMany: {
            args: Prisma.model_has_permissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.model_has_permissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.model_has_permissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_permissionsPayload>
          }
          aggregate: {
            args: Prisma.Model_has_permissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModel_has_permissions>
          }
          groupBy: {
            args: Prisma.model_has_permissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Model_has_permissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.model_has_permissionsCountArgs<ExtArgs>
            result: $Utils.Optional<Model_has_permissionsCountAggregateOutputType> | number
          }
        }
      }
      model_has_roles: {
        payload: Prisma.$model_has_rolesPayload<ExtArgs>
        fields: Prisma.model_has_rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.model_has_rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.model_has_rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload>
          }
          findFirst: {
            args: Prisma.model_has_rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.model_has_rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload>
          }
          findMany: {
            args: Prisma.model_has_rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload>[]
          }
          create: {
            args: Prisma.model_has_rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload>
          }
          createMany: {
            args: Prisma.model_has_rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.model_has_rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload>
          }
          update: {
            args: Prisma.model_has_rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload>
          }
          deleteMany: {
            args: Prisma.model_has_rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.model_has_rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.model_has_rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$model_has_rolesPayload>
          }
          aggregate: {
            args: Prisma.Model_has_rolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModel_has_roles>
          }
          groupBy: {
            args: Prisma.model_has_rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Model_has_rolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.model_has_rolesCountArgs<ExtArgs>
            result: $Utils.Optional<Model_has_rolesCountAggregateOutputType> | number
          }
        }
      }
      password_reset_tokens: {
        payload: Prisma.$password_reset_tokensPayload<ExtArgs>
        fields: Prisma.password_reset_tokensFieldRefs
        operations: {
          findUnique: {
            args: Prisma.password_reset_tokensFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.password_reset_tokensFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          findFirst: {
            args: Prisma.password_reset_tokensFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.password_reset_tokensFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          findMany: {
            args: Prisma.password_reset_tokensFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>[]
          }
          create: {
            args: Prisma.password_reset_tokensCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          createMany: {
            args: Prisma.password_reset_tokensCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.password_reset_tokensDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          update: {
            args: Prisma.password_reset_tokensUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          deleteMany: {
            args: Prisma.password_reset_tokensDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.password_reset_tokensUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.password_reset_tokensUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$password_reset_tokensPayload>
          }
          aggregate: {
            args: Prisma.Password_reset_tokensAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePassword_reset_tokens>
          }
          groupBy: {
            args: Prisma.password_reset_tokensGroupByArgs<ExtArgs>
            result: $Utils.Optional<Password_reset_tokensGroupByOutputType>[]
          }
          count: {
            args: Prisma.password_reset_tokensCountArgs<ExtArgs>
            result: $Utils.Optional<Password_reset_tokensCountAggregateOutputType> | number
          }
        }
      }
      permissions: {
        payload: Prisma.$permissionsPayload<ExtArgs>
        fields: Prisma.permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.permissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.permissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          findFirst: {
            args: Prisma.permissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.permissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          findMany: {
            args: Prisma.permissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>[]
          }
          create: {
            args: Prisma.permissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          createMany: {
            args: Prisma.permissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.permissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          update: {
            args: Prisma.permissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          deleteMany: {
            args: Prisma.permissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.permissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.permissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$permissionsPayload>
          }
          aggregate: {
            args: Prisma.PermissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePermissions>
          }
          groupBy: {
            args: Prisma.permissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PermissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.permissionsCountArgs<ExtArgs>
            result: $Utils.Optional<PermissionsCountAggregateOutputType> | number
          }
        }
      }
      role_has_permissions: {
        payload: Prisma.$role_has_permissionsPayload<ExtArgs>
        fields: Prisma.role_has_permissionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.role_has_permissionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.role_has_permissionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload>
          }
          findFirst: {
            args: Prisma.role_has_permissionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.role_has_permissionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload>
          }
          findMany: {
            args: Prisma.role_has_permissionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload>[]
          }
          create: {
            args: Prisma.role_has_permissionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload>
          }
          createMany: {
            args: Prisma.role_has_permissionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.role_has_permissionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload>
          }
          update: {
            args: Prisma.role_has_permissionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload>
          }
          deleteMany: {
            args: Prisma.role_has_permissionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.role_has_permissionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.role_has_permissionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$role_has_permissionsPayload>
          }
          aggregate: {
            args: Prisma.Role_has_permissionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRole_has_permissions>
          }
          groupBy: {
            args: Prisma.role_has_permissionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Role_has_permissionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.role_has_permissionsCountArgs<ExtArgs>
            result: $Utils.Optional<Role_has_permissionsCountAggregateOutputType> | number
          }
        }
      }
      roles: {
        payload: Prisma.$rolesPayload<ExtArgs>
        fields: Prisma.rolesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.rolesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.rolesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findFirst: {
            args: Prisma.rolesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.rolesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          findMany: {
            args: Prisma.rolesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>[]
          }
          create: {
            args: Prisma.rolesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          createMany: {
            args: Prisma.rolesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.rolesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          update: {
            args: Prisma.rolesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          deleteMany: {
            args: Prisma.rolesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.rolesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.rolesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$rolesPayload>
          }
          aggregate: {
            args: Prisma.RolesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoles>
          }
          groupBy: {
            args: Prisma.rolesGroupByArgs<ExtArgs>
            result: $Utils.Optional<RolesGroupByOutputType>[]
          }
          count: {
            args: Prisma.rolesCountArgs<ExtArgs>
            result: $Utils.Optional<RolesCountAggregateOutputType> | number
          }
        }
      }
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      cache: {
        payload: Prisma.$cachePayload<ExtArgs>
        fields: Prisma.cacheFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cacheFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cacheFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          findFirst: {
            args: Prisma.cacheFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cacheFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          findMany: {
            args: Prisma.cacheFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>[]
          }
          create: {
            args: Prisma.cacheCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          createMany: {
            args: Prisma.cacheCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cacheDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          update: {
            args: Prisma.cacheUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          deleteMany: {
            args: Prisma.cacheDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cacheUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cacheUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cachePayload>
          }
          aggregate: {
            args: Prisma.CacheAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCache>
          }
          groupBy: {
            args: Prisma.cacheGroupByArgs<ExtArgs>
            result: $Utils.Optional<CacheGroupByOutputType>[]
          }
          count: {
            args: Prisma.cacheCountArgs<ExtArgs>
            result: $Utils.Optional<CacheCountAggregateOutputType> | number
          }
        }
      }
      cache_locks: {
        payload: Prisma.$cache_locksPayload<ExtArgs>
        fields: Prisma.cache_locksFieldRefs
        operations: {
          findUnique: {
            args: Prisma.cache_locksFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.cache_locksFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>
          }
          findFirst: {
            args: Prisma.cache_locksFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.cache_locksFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>
          }
          findMany: {
            args: Prisma.cache_locksFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>[]
          }
          create: {
            args: Prisma.cache_locksCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>
          }
          createMany: {
            args: Prisma.cache_locksCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.cache_locksDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>
          }
          update: {
            args: Prisma.cache_locksUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>
          }
          deleteMany: {
            args: Prisma.cache_locksDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.cache_locksUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.cache_locksUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$cache_locksPayload>
          }
          aggregate: {
            args: Prisma.Cache_locksAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCache_locks>
          }
          groupBy: {
            args: Prisma.cache_locksGroupByArgs<ExtArgs>
            result: $Utils.Optional<Cache_locksGroupByOutputType>[]
          }
          count: {
            args: Prisma.cache_locksCountArgs<ExtArgs>
            result: $Utils.Optional<Cache_locksCountAggregateOutputType> | number
          }
        }
      }
      job_batches: {
        payload: Prisma.$job_batchesPayload<ExtArgs>
        fields: Prisma.job_batchesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.job_batchesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_batchesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.job_batchesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_batchesPayload>
          }
          findFirst: {
            args: Prisma.job_batchesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_batchesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.job_batchesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_batchesPayload>
          }
          findMany: {
            args: Prisma.job_batchesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_batchesPayload>[]
          }
          create: {
            args: Prisma.job_batchesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_batchesPayload>
          }
          createMany: {
            args: Prisma.job_batchesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.job_batchesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_batchesPayload>
          }
          update: {
            args: Prisma.job_batchesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_batchesPayload>
          }
          deleteMany: {
            args: Prisma.job_batchesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.job_batchesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.job_batchesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$job_batchesPayload>
          }
          aggregate: {
            args: Prisma.Job_batchesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJob_batches>
          }
          groupBy: {
            args: Prisma.job_batchesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Job_batchesGroupByOutputType>[]
          }
          count: {
            args: Prisma.job_batchesCountArgs<ExtArgs>
            result: $Utils.Optional<Job_batchesCountAggregateOutputType> | number
          }
        }
      }
      sessions: {
        payload: Prisma.$sessionsPayload<ExtArgs>
        fields: Prisma.sessionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.sessionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.sessionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findFirst: {
            args: Prisma.sessionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.sessionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          findMany: {
            args: Prisma.sessionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>[]
          }
          create: {
            args: Prisma.sessionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          createMany: {
            args: Prisma.sessionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.sessionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          update: {
            args: Prisma.sessionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          deleteMany: {
            args: Prisma.sessionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.sessionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.sessionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$sessionsPayload>
          }
          aggregate: {
            args: Prisma.SessionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSessions>
          }
          groupBy: {
            args: Prisma.sessionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.sessionsCountArgs<ExtArgs>
            result: $Utils.Optional<SessionsCountAggregateOutputType> | number
          }
        }
      }
      categories: {
        payload: Prisma.$categoriesPayload<ExtArgs>
        fields: Prisma.categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          findFirst: {
            args: Prisma.categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          findMany: {
            args: Prisma.categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>[]
          }
          create: {
            args: Prisma.categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          createMany: {
            args: Prisma.categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          update: {
            args: Prisma.categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          deleteMany: {
            args: Prisma.categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$categoriesPayload>
          }
          aggregate: {
            args: Prisma.CategoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCategories>
          }
          groupBy: {
            args: Prisma.categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CategoriesGroupByOutputType>[]
          }
          count: {
            args: Prisma.categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<CategoriesCountAggregateOutputType> | number
          }
        }
      }
      companies: {
        payload: Prisma.$companiesPayload<ExtArgs>
        fields: Prisma.companiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.companiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.companiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          findFirst: {
            args: Prisma.companiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.companiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          findMany: {
            args: Prisma.companiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>[]
          }
          create: {
            args: Prisma.companiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          createMany: {
            args: Prisma.companiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.companiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          update: {
            args: Prisma.companiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          deleteMany: {
            args: Prisma.companiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.companiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.companiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$companiesPayload>
          }
          aggregate: {
            args: Prisma.CompaniesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompanies>
          }
          groupBy: {
            args: Prisma.companiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CompaniesGroupByOutputType>[]
          }
          count: {
            args: Prisma.companiesCountArgs<ExtArgs>
            result: $Utils.Optional<CompaniesCountAggregateOutputType> | number
          }
        }
      }
      company_frontend_settings: {
        payload: Prisma.$company_frontend_settingsPayload<ExtArgs>
        fields: Prisma.company_frontend_settingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.company_frontend_settingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_frontend_settingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.company_frontend_settingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_frontend_settingsPayload>
          }
          findFirst: {
            args: Prisma.company_frontend_settingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_frontend_settingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.company_frontend_settingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_frontend_settingsPayload>
          }
          findMany: {
            args: Prisma.company_frontend_settingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_frontend_settingsPayload>[]
          }
          create: {
            args: Prisma.company_frontend_settingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_frontend_settingsPayload>
          }
          createMany: {
            args: Prisma.company_frontend_settingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.company_frontend_settingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_frontend_settingsPayload>
          }
          update: {
            args: Prisma.company_frontend_settingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_frontend_settingsPayload>
          }
          deleteMany: {
            args: Prisma.company_frontend_settingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.company_frontend_settingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.company_frontend_settingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_frontend_settingsPayload>
          }
          aggregate: {
            args: Prisma.Company_frontend_settingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany_frontend_settings>
          }
          groupBy: {
            args: Prisma.company_frontend_settingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Company_frontend_settingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.company_frontend_settingsCountArgs<ExtArgs>
            result: $Utils.Optional<Company_frontend_settingsCountAggregateOutputType> | number
          }
        }
      }
      company_integrations: {
        payload: Prisma.$company_integrationsPayload<ExtArgs>
        fields: Prisma.company_integrationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.company_integrationsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_integrationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.company_integrationsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_integrationsPayload>
          }
          findFirst: {
            args: Prisma.company_integrationsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_integrationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.company_integrationsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_integrationsPayload>
          }
          findMany: {
            args: Prisma.company_integrationsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_integrationsPayload>[]
          }
          create: {
            args: Prisma.company_integrationsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_integrationsPayload>
          }
          createMany: {
            args: Prisma.company_integrationsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.company_integrationsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_integrationsPayload>
          }
          update: {
            args: Prisma.company_integrationsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_integrationsPayload>
          }
          deleteMany: {
            args: Prisma.company_integrationsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.company_integrationsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.company_integrationsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_integrationsPayload>
          }
          aggregate: {
            args: Prisma.Company_integrationsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany_integrations>
          }
          groupBy: {
            args: Prisma.company_integrationsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Company_integrationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.company_integrationsCountArgs<ExtArgs>
            result: $Utils.Optional<Company_integrationsCountAggregateOutputType> | number
          }
        }
      }
      company_profiles: {
        payload: Prisma.$company_profilesPayload<ExtArgs>
        fields: Prisma.company_profilesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.company_profilesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_profilesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.company_profilesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_profilesPayload>
          }
          findFirst: {
            args: Prisma.company_profilesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_profilesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.company_profilesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_profilesPayload>
          }
          findMany: {
            args: Prisma.company_profilesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_profilesPayload>[]
          }
          create: {
            args: Prisma.company_profilesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_profilesPayload>
          }
          createMany: {
            args: Prisma.company_profilesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.company_profilesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_profilesPayload>
          }
          update: {
            args: Prisma.company_profilesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_profilesPayload>
          }
          deleteMany: {
            args: Prisma.company_profilesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.company_profilesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.company_profilesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_profilesPayload>
          }
          aggregate: {
            args: Prisma.Company_profilesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany_profiles>
          }
          groupBy: {
            args: Prisma.company_profilesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Company_profilesGroupByOutputType>[]
          }
          count: {
            args: Prisma.company_profilesCountArgs<ExtArgs>
            result: $Utils.Optional<Company_profilesCountAggregateOutputType> | number
          }
        }
      }
      company_subscriptions: {
        payload: Prisma.$company_subscriptionsPayload<ExtArgs>
        fields: Prisma.company_subscriptionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.company_subscriptionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_subscriptionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.company_subscriptionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_subscriptionsPayload>
          }
          findFirst: {
            args: Prisma.company_subscriptionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_subscriptionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.company_subscriptionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_subscriptionsPayload>
          }
          findMany: {
            args: Prisma.company_subscriptionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_subscriptionsPayload>[]
          }
          create: {
            args: Prisma.company_subscriptionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_subscriptionsPayload>
          }
          createMany: {
            args: Prisma.company_subscriptionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.company_subscriptionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_subscriptionsPayload>
          }
          update: {
            args: Prisma.company_subscriptionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_subscriptionsPayload>
          }
          deleteMany: {
            args: Prisma.company_subscriptionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.company_subscriptionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.company_subscriptionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$company_subscriptionsPayload>
          }
          aggregate: {
            args: Prisma.Company_subscriptionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCompany_subscriptions>
          }
          groupBy: {
            args: Prisma.company_subscriptionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Company_subscriptionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.company_subscriptionsCountArgs<ExtArgs>
            result: $Utils.Optional<Company_subscriptionsCountAggregateOutputType> | number
          }
        }
      }
      integration_category_mappings: {
        payload: Prisma.$integration_category_mappingsPayload<ExtArgs>
        fields: Prisma.integration_category_mappingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.integration_category_mappingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integration_category_mappingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.integration_category_mappingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integration_category_mappingsPayload>
          }
          findFirst: {
            args: Prisma.integration_category_mappingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integration_category_mappingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.integration_category_mappingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integration_category_mappingsPayload>
          }
          findMany: {
            args: Prisma.integration_category_mappingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integration_category_mappingsPayload>[]
          }
          create: {
            args: Prisma.integration_category_mappingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integration_category_mappingsPayload>
          }
          createMany: {
            args: Prisma.integration_category_mappingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.integration_category_mappingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integration_category_mappingsPayload>
          }
          update: {
            args: Prisma.integration_category_mappingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integration_category_mappingsPayload>
          }
          deleteMany: {
            args: Prisma.integration_category_mappingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.integration_category_mappingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.integration_category_mappingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$integration_category_mappingsPayload>
          }
          aggregate: {
            args: Prisma.Integration_category_mappingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateIntegration_category_mappings>
          }
          groupBy: {
            args: Prisma.integration_category_mappingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Integration_category_mappingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.integration_category_mappingsCountArgs<ExtArgs>
            result: $Utils.Optional<Integration_category_mappingsCountAggregateOutputType> | number
          }
        }
      }
      menus: {
        payload: Prisma.$menusPayload<ExtArgs>
        fields: Prisma.menusFieldRefs
        operations: {
          findUnique: {
            args: Prisma.menusFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menusPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.menusFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menusPayload>
          }
          findFirst: {
            args: Prisma.menusFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menusPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.menusFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menusPayload>
          }
          findMany: {
            args: Prisma.menusFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menusPayload>[]
          }
          create: {
            args: Prisma.menusCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menusPayload>
          }
          createMany: {
            args: Prisma.menusCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.menusDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menusPayload>
          }
          update: {
            args: Prisma.menusUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menusPayload>
          }
          deleteMany: {
            args: Prisma.menusDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.menusUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.menusUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$menusPayload>
          }
          aggregate: {
            args: Prisma.MenusAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMenus>
          }
          groupBy: {
            args: Prisma.menusGroupByArgs<ExtArgs>
            result: $Utils.Optional<MenusGroupByOutputType>[]
          }
          count: {
            args: Prisma.menusCountArgs<ExtArgs>
            result: $Utils.Optional<MenusCountAggregateOutputType> | number
          }
        }
      }
      offer_category: {
        payload: Prisma.$offer_categoryPayload<ExtArgs>
        fields: Prisma.offer_categoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.offer_categoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offer_categoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.offer_categoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offer_categoryPayload>
          }
          findFirst: {
            args: Prisma.offer_categoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offer_categoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.offer_categoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offer_categoryPayload>
          }
          findMany: {
            args: Prisma.offer_categoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offer_categoryPayload>[]
          }
          create: {
            args: Prisma.offer_categoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offer_categoryPayload>
          }
          createMany: {
            args: Prisma.offer_categoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.offer_categoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offer_categoryPayload>
          }
          update: {
            args: Prisma.offer_categoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offer_categoryPayload>
          }
          deleteMany: {
            args: Prisma.offer_categoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.offer_categoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.offer_categoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offer_categoryPayload>
          }
          aggregate: {
            args: Prisma.Offer_categoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOffer_category>
          }
          groupBy: {
            args: Prisma.offer_categoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<Offer_categoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.offer_categoryCountArgs<ExtArgs>
            result: $Utils.Optional<Offer_categoryCountAggregateOutputType> | number
          }
        }
      }
      offers: {
        payload: Prisma.$offersPayload<ExtArgs>
        fields: Prisma.offersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.offersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.offersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offersPayload>
          }
          findFirst: {
            args: Prisma.offersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.offersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offersPayload>
          }
          findMany: {
            args: Prisma.offersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offersPayload>[]
          }
          create: {
            args: Prisma.offersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offersPayload>
          }
          createMany: {
            args: Prisma.offersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.offersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offersPayload>
          }
          update: {
            args: Prisma.offersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offersPayload>
          }
          deleteMany: {
            args: Prisma.offersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.offersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.offersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$offersPayload>
          }
          aggregate: {
            args: Prisma.OffersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOffers>
          }
          groupBy: {
            args: Prisma.offersGroupByArgs<ExtArgs>
            result: $Utils.Optional<OffersGroupByOutputType>[]
          }
          count: {
            args: Prisma.offersCountArgs<ExtArgs>
            result: $Utils.Optional<OffersCountAggregateOutputType> | number
          }
        }
      }
      payments: {
        payload: Prisma.$paymentsPayload<ExtArgs>
        fields: Prisma.paymentsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.paymentsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.paymentsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findFirst: {
            args: Prisma.paymentsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.paymentsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          findMany: {
            args: Prisma.paymentsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>[]
          }
          create: {
            args: Prisma.paymentsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          createMany: {
            args: Prisma.paymentsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.paymentsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          update: {
            args: Prisma.paymentsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          deleteMany: {
            args: Prisma.paymentsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.paymentsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.paymentsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$paymentsPayload>
          }
          aggregate: {
            args: Prisma.PaymentsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayments>
          }
          groupBy: {
            args: Prisma.paymentsGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentsGroupByOutputType>[]
          }
          count: {
            args: Prisma.paymentsCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentsCountAggregateOutputType> | number
          }
        }
      }
      stores: {
        payload: Prisma.$storesPayload<ExtArgs>
        fields: Prisma.storesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.storesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.storesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload>
          }
          findFirst: {
            args: Prisma.storesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.storesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload>
          }
          findMany: {
            args: Prisma.storesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload>[]
          }
          create: {
            args: Prisma.storesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload>
          }
          createMany: {
            args: Prisma.storesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.storesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload>
          }
          update: {
            args: Prisma.storesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload>
          }
          deleteMany: {
            args: Prisma.storesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.storesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.storesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$storesPayload>
          }
          aggregate: {
            args: Prisma.StoresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStores>
          }
          groupBy: {
            args: Prisma.storesGroupByArgs<ExtArgs>
            result: $Utils.Optional<StoresGroupByOutputType>[]
          }
          count: {
            args: Prisma.storesCountArgs<ExtArgs>
            result: $Utils.Optional<StoresCountAggregateOutputType> | number
          }
        }
      }
      subscriptions: {
        payload: Prisma.$subscriptionsPayload<ExtArgs>
        fields: Prisma.subscriptionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.subscriptionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.subscriptionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          findFirst: {
            args: Prisma.subscriptionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.subscriptionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          findMany: {
            args: Prisma.subscriptionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>[]
          }
          create: {
            args: Prisma.subscriptionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          createMany: {
            args: Prisma.subscriptionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.subscriptionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          update: {
            args: Prisma.subscriptionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          deleteMany: {
            args: Prisma.subscriptionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.subscriptionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.subscriptionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$subscriptionsPayload>
          }
          aggregate: {
            args: Prisma.SubscriptionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubscriptions>
          }
          groupBy: {
            args: Prisma.subscriptionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionsGroupByOutputType>[]
          }
          count: {
            args: Prisma.subscriptionsCountArgs<ExtArgs>
            result: $Utils.Optional<SubscriptionsCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    failed_jobs?: failed_jobsOmit
    jobs?: jobsOmit
    migrations?: migrationsOmit
    model_has_permissions?: model_has_permissionsOmit
    model_has_roles?: model_has_rolesOmit
    password_reset_tokens?: password_reset_tokensOmit
    permissions?: permissionsOmit
    role_has_permissions?: role_has_permissionsOmit
    roles?: rolesOmit
    users?: usersOmit
    cache?: cacheOmit
    cache_locks?: cache_locksOmit
    job_batches?: job_batchesOmit
    sessions?: sessionsOmit
    categories?: categoriesOmit
    companies?: companiesOmit
    company_frontend_settings?: company_frontend_settingsOmit
    company_integrations?: company_integrationsOmit
    company_profiles?: company_profilesOmit
    company_subscriptions?: company_subscriptionsOmit
    integration_category_mappings?: integration_category_mappingsOmit
    menus?: menusOmit
    offer_category?: offer_categoryOmit
    offers?: offersOmit
    payments?: paymentsOmit
    stores?: storesOmit
    subscriptions?: subscriptionsOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type PermissionsCountOutputType
   */

  export type PermissionsCountOutputType = {
    model_has_permissions: number
    role_has_permissions: number
  }

  export type PermissionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model_has_permissions?: boolean | PermissionsCountOutputTypeCountModel_has_permissionsArgs
    role_has_permissions?: boolean | PermissionsCountOutputTypeCountRole_has_permissionsArgs
  }

  // Custom InputTypes
  /**
   * PermissionsCountOutputType without action
   */
  export type PermissionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PermissionsCountOutputType
     */
    select?: PermissionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PermissionsCountOutputType without action
   */
  export type PermissionsCountOutputTypeCountModel_has_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: model_has_permissionsWhereInput
  }

  /**
   * PermissionsCountOutputType without action
   */
  export type PermissionsCountOutputTypeCountRole_has_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: role_has_permissionsWhereInput
  }


  /**
   * Count Type RolesCountOutputType
   */

  export type RolesCountOutputType = {
    model_has_roles: number
    role_has_permissions: number
  }

  export type RolesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model_has_roles?: boolean | RolesCountOutputTypeCountModel_has_rolesArgs
    role_has_permissions?: boolean | RolesCountOutputTypeCountRole_has_permissionsArgs
  }

  // Custom InputTypes
  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RolesCountOutputType
     */
    select?: RolesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountModel_has_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: model_has_rolesWhereInput
  }

  /**
   * RolesCountOutputType without action
   */
  export type RolesCountOutputTypeCountRole_has_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: role_has_permissionsWhereInput
  }


  /**
   * Count Type CategoriesCountOutputType
   */

  export type CategoriesCountOutputType = {
    other_categories: number
    integration_category_mappings: number
    offer_category: number
    offers: number
  }

  export type CategoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_categories?: boolean | CategoriesCountOutputTypeCountOther_categoriesArgs
    integration_category_mappings?: boolean | CategoriesCountOutputTypeCountIntegration_category_mappingsArgs
    offer_category?: boolean | CategoriesCountOutputTypeCountOffer_categoryArgs
    offers?: boolean | CategoriesCountOutputTypeCountOffersArgs
  }

  // Custom InputTypes
  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CategoriesCountOutputType
     */
    select?: CategoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountOther_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriesWhereInput
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountIntegration_category_mappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: integration_category_mappingsWhereInput
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountOffer_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: offer_categoryWhereInput
  }

  /**
   * CategoriesCountOutputType without action
   */
  export type CategoriesCountOutputTypeCountOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: offersWhereInput
  }


  /**
   * Count Type CompaniesCountOutputType
   */

  export type CompaniesCountOutputType = {
    categories: number
    company_frontend_settings: number
    company_integrations: number
    company_profiles: number
    company_subscriptions: number
    integration_category_mappings: number
    offers: number
    stores: number
    users: number
  }

  export type CompaniesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | CompaniesCountOutputTypeCountCategoriesArgs
    company_frontend_settings?: boolean | CompaniesCountOutputTypeCountCompany_frontend_settingsArgs
    company_integrations?: boolean | CompaniesCountOutputTypeCountCompany_integrationsArgs
    company_profiles?: boolean | CompaniesCountOutputTypeCountCompany_profilesArgs
    company_subscriptions?: boolean | CompaniesCountOutputTypeCountCompany_subscriptionsArgs
    integration_category_mappings?: boolean | CompaniesCountOutputTypeCountIntegration_category_mappingsArgs
    offers?: boolean | CompaniesCountOutputTypeCountOffersArgs
    stores?: boolean | CompaniesCountOutputTypeCountStoresArgs
    users?: boolean | CompaniesCountOutputTypeCountUsersArgs
  }

  // Custom InputTypes
  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CompaniesCountOutputType
     */
    select?: CompaniesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountCategoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriesWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountCompany_frontend_settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_frontend_settingsWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountCompany_integrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_integrationsWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountCompany_profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_profilesWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountCompany_subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_subscriptionsWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountIntegration_category_mappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: integration_category_mappingsWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: offersWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountStoresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: storesWhereInput
  }

  /**
   * CompaniesCountOutputType without action
   */
  export type CompaniesCountOutputTypeCountUsersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
  }


  /**
   * Count Type Company_subscriptionsCountOutputType
   */

  export type Company_subscriptionsCountOutputType = {
    payments: number
  }

  export type Company_subscriptionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | Company_subscriptionsCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * Company_subscriptionsCountOutputType without action
   */
  export type Company_subscriptionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Company_subscriptionsCountOutputType
     */
    select?: Company_subscriptionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Company_subscriptionsCountOutputType without action
   */
  export type Company_subscriptionsCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
  }


  /**
   * Count Type MenusCountOutputType
   */

  export type MenusCountOutputType = {
    other_menus: number
  }

  export type MenusCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    other_menus?: boolean | MenusCountOutputTypeCountOther_menusArgs
  }

  // Custom InputTypes
  /**
   * MenusCountOutputType without action
   */
  export type MenusCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MenusCountOutputType
     */
    select?: MenusCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MenusCountOutputType without action
   */
  export type MenusCountOutputTypeCountOther_menusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: menusWhereInput
  }


  /**
   * Count Type OffersCountOutputType
   */

  export type OffersCountOutputType = {
    offer_category: number
  }

  export type OffersCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer_category?: boolean | OffersCountOutputTypeCountOffer_categoryArgs
  }

  // Custom InputTypes
  /**
   * OffersCountOutputType without action
   */
  export type OffersCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OffersCountOutputType
     */
    select?: OffersCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * OffersCountOutputType without action
   */
  export type OffersCountOutputTypeCountOffer_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: offer_categoryWhereInput
  }


  /**
   * Count Type StoresCountOutputType
   */

  export type StoresCountOutputType = {
    offers: number
  }

  export type StoresCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offers?: boolean | StoresCountOutputTypeCountOffersArgs
  }

  // Custom InputTypes
  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StoresCountOutputType
     */
    select?: StoresCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StoresCountOutputType without action
   */
  export type StoresCountOutputTypeCountOffersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: offersWhereInput
  }


  /**
   * Count Type SubscriptionsCountOutputType
   */

  export type SubscriptionsCountOutputType = {
    company_subscriptions: number
  }

  export type SubscriptionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_subscriptions?: boolean | SubscriptionsCountOutputTypeCountCompany_subscriptionsArgs
  }

  // Custom InputTypes
  /**
   * SubscriptionsCountOutputType without action
   */
  export type SubscriptionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubscriptionsCountOutputType
     */
    select?: SubscriptionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SubscriptionsCountOutputType without action
   */
  export type SubscriptionsCountOutputTypeCountCompany_subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_subscriptionsWhereInput
  }


  /**
   * Models
   */

  /**
   * Model failed_jobs
   */

  export type AggregateFailed_jobs = {
    _count: Failed_jobsCountAggregateOutputType | null
    _avg: Failed_jobsAvgAggregateOutputType | null
    _sum: Failed_jobsSumAggregateOutputType | null
    _min: Failed_jobsMinAggregateOutputType | null
    _max: Failed_jobsMaxAggregateOutputType | null
  }

  export type Failed_jobsAvgAggregateOutputType = {
    id: number | null
  }

  export type Failed_jobsSumAggregateOutputType = {
    id: bigint | null
  }

  export type Failed_jobsMinAggregateOutputType = {
    id: bigint | null
    uuid: string | null
    connection: string | null
    queue: string | null
    payload: string | null
    exception: string | null
    failed_at: Date | null
  }

  export type Failed_jobsMaxAggregateOutputType = {
    id: bigint | null
    uuid: string | null
    connection: string | null
    queue: string | null
    payload: string | null
    exception: string | null
    failed_at: Date | null
  }

  export type Failed_jobsCountAggregateOutputType = {
    id: number
    uuid: number
    connection: number
    queue: number
    payload: number
    exception: number
    failed_at: number
    _all: number
  }


  export type Failed_jobsAvgAggregateInputType = {
    id?: true
  }

  export type Failed_jobsSumAggregateInputType = {
    id?: true
  }

  export type Failed_jobsMinAggregateInputType = {
    id?: true
    uuid?: true
    connection?: true
    queue?: true
    payload?: true
    exception?: true
    failed_at?: true
  }

  export type Failed_jobsMaxAggregateInputType = {
    id?: true
    uuid?: true
    connection?: true
    queue?: true
    payload?: true
    exception?: true
    failed_at?: true
  }

  export type Failed_jobsCountAggregateInputType = {
    id?: true
    uuid?: true
    connection?: true
    queue?: true
    payload?: true
    exception?: true
    failed_at?: true
    _all?: true
  }

  export type Failed_jobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which failed_jobs to aggregate.
     */
    where?: failed_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of failed_jobs to fetch.
     */
    orderBy?: failed_jobsOrderByWithRelationInput | failed_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: failed_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` failed_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` failed_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned failed_jobs
    **/
    _count?: true | Failed_jobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Failed_jobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Failed_jobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Failed_jobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Failed_jobsMaxAggregateInputType
  }

  export type GetFailed_jobsAggregateType<T extends Failed_jobsAggregateArgs> = {
        [P in keyof T & keyof AggregateFailed_jobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFailed_jobs[P]>
      : GetScalarType<T[P], AggregateFailed_jobs[P]>
  }




  export type failed_jobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: failed_jobsWhereInput
    orderBy?: failed_jobsOrderByWithAggregationInput | failed_jobsOrderByWithAggregationInput[]
    by: Failed_jobsScalarFieldEnum[] | Failed_jobsScalarFieldEnum
    having?: failed_jobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Failed_jobsCountAggregateInputType | true
    _avg?: Failed_jobsAvgAggregateInputType
    _sum?: Failed_jobsSumAggregateInputType
    _min?: Failed_jobsMinAggregateInputType
    _max?: Failed_jobsMaxAggregateInputType
  }

  export type Failed_jobsGroupByOutputType = {
    id: bigint
    uuid: string
    connection: string
    queue: string
    payload: string
    exception: string
    failed_at: Date
    _count: Failed_jobsCountAggregateOutputType | null
    _avg: Failed_jobsAvgAggregateOutputType | null
    _sum: Failed_jobsSumAggregateOutputType | null
    _min: Failed_jobsMinAggregateOutputType | null
    _max: Failed_jobsMaxAggregateOutputType | null
  }

  type GetFailed_jobsGroupByPayload<T extends failed_jobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Failed_jobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Failed_jobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Failed_jobsGroupByOutputType[P]>
            : GetScalarType<T[P], Failed_jobsGroupByOutputType[P]>
        }
      >
    >


  export type failed_jobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    uuid?: boolean
    connection?: boolean
    queue?: boolean
    payload?: boolean
    exception?: boolean
    failed_at?: boolean
  }, ExtArgs["result"]["failed_jobs"]>



  export type failed_jobsSelectScalar = {
    id?: boolean
    uuid?: boolean
    connection?: boolean
    queue?: boolean
    payload?: boolean
    exception?: boolean
    failed_at?: boolean
  }

  export type failed_jobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "uuid" | "connection" | "queue" | "payload" | "exception" | "failed_at", ExtArgs["result"]["failed_jobs"]>

  export type $failed_jobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "failed_jobs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      uuid: string
      connection: string
      queue: string
      payload: string
      exception: string
      failed_at: Date
    }, ExtArgs["result"]["failed_jobs"]>
    composites: {}
  }

  type failed_jobsGetPayload<S extends boolean | null | undefined | failed_jobsDefaultArgs> = $Result.GetResult<Prisma.$failed_jobsPayload, S>

  type failed_jobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<failed_jobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Failed_jobsCountAggregateInputType | true
    }

  export interface failed_jobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['failed_jobs'], meta: { name: 'failed_jobs' } }
    /**
     * Find zero or one Failed_jobs that matches the filter.
     * @param {failed_jobsFindUniqueArgs} args - Arguments to find a Failed_jobs
     * @example
     * // Get one Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends failed_jobsFindUniqueArgs>(args: SelectSubset<T, failed_jobsFindUniqueArgs<ExtArgs>>): Prisma__failed_jobsClient<$Result.GetResult<Prisma.$failed_jobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Failed_jobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {failed_jobsFindUniqueOrThrowArgs} args - Arguments to find a Failed_jobs
     * @example
     * // Get one Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends failed_jobsFindUniqueOrThrowArgs>(args: SelectSubset<T, failed_jobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__failed_jobsClient<$Result.GetResult<Prisma.$failed_jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Failed_jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {failed_jobsFindFirstArgs} args - Arguments to find a Failed_jobs
     * @example
     * // Get one Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends failed_jobsFindFirstArgs>(args?: SelectSubset<T, failed_jobsFindFirstArgs<ExtArgs>>): Prisma__failed_jobsClient<$Result.GetResult<Prisma.$failed_jobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Failed_jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {failed_jobsFindFirstOrThrowArgs} args - Arguments to find a Failed_jobs
     * @example
     * // Get one Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends failed_jobsFindFirstOrThrowArgs>(args?: SelectSubset<T, failed_jobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__failed_jobsClient<$Result.GetResult<Prisma.$failed_jobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Failed_jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {failed_jobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.findMany()
     * 
     * // Get first 10 Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const failed_jobsWithIdOnly = await prisma.failed_jobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends failed_jobsFindManyArgs>(args?: SelectSubset<T, failed_jobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$failed_jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Failed_jobs.
     * @param {failed_jobsCreateArgs} args - Arguments to create a Failed_jobs.
     * @example
     * // Create one Failed_jobs
     * const Failed_jobs = await prisma.failed_jobs.create({
     *   data: {
     *     // ... data to create a Failed_jobs
     *   }
     * })
     * 
     */
    create<T extends failed_jobsCreateArgs>(args: SelectSubset<T, failed_jobsCreateArgs<ExtArgs>>): Prisma__failed_jobsClient<$Result.GetResult<Prisma.$failed_jobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Failed_jobs.
     * @param {failed_jobsCreateManyArgs} args - Arguments to create many Failed_jobs.
     * @example
     * // Create many Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends failed_jobsCreateManyArgs>(args?: SelectSubset<T, failed_jobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Failed_jobs.
     * @param {failed_jobsDeleteArgs} args - Arguments to delete one Failed_jobs.
     * @example
     * // Delete one Failed_jobs
     * const Failed_jobs = await prisma.failed_jobs.delete({
     *   where: {
     *     // ... filter to delete one Failed_jobs
     *   }
     * })
     * 
     */
    delete<T extends failed_jobsDeleteArgs>(args: SelectSubset<T, failed_jobsDeleteArgs<ExtArgs>>): Prisma__failed_jobsClient<$Result.GetResult<Prisma.$failed_jobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Failed_jobs.
     * @param {failed_jobsUpdateArgs} args - Arguments to update one Failed_jobs.
     * @example
     * // Update one Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends failed_jobsUpdateArgs>(args: SelectSubset<T, failed_jobsUpdateArgs<ExtArgs>>): Prisma__failed_jobsClient<$Result.GetResult<Prisma.$failed_jobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Failed_jobs.
     * @param {failed_jobsDeleteManyArgs} args - Arguments to filter Failed_jobs to delete.
     * @example
     * // Delete a few Failed_jobs
     * const { count } = await prisma.failed_jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends failed_jobsDeleteManyArgs>(args?: SelectSubset<T, failed_jobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Failed_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {failed_jobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends failed_jobsUpdateManyArgs>(args: SelectSubset<T, failed_jobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Failed_jobs.
     * @param {failed_jobsUpsertArgs} args - Arguments to update or create a Failed_jobs.
     * @example
     * // Update or create a Failed_jobs
     * const failed_jobs = await prisma.failed_jobs.upsert({
     *   create: {
     *     // ... data to create a Failed_jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Failed_jobs we want to update
     *   }
     * })
     */
    upsert<T extends failed_jobsUpsertArgs>(args: SelectSubset<T, failed_jobsUpsertArgs<ExtArgs>>): Prisma__failed_jobsClient<$Result.GetResult<Prisma.$failed_jobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Failed_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {failed_jobsCountArgs} args - Arguments to filter Failed_jobs to count.
     * @example
     * // Count the number of Failed_jobs
     * const count = await prisma.failed_jobs.count({
     *   where: {
     *     // ... the filter for the Failed_jobs we want to count
     *   }
     * })
    **/
    count<T extends failed_jobsCountArgs>(
      args?: Subset<T, failed_jobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Failed_jobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Failed_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Failed_jobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Failed_jobsAggregateArgs>(args: Subset<T, Failed_jobsAggregateArgs>): Prisma.PrismaPromise<GetFailed_jobsAggregateType<T>>

    /**
     * Group by Failed_jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {failed_jobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends failed_jobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: failed_jobsGroupByArgs['orderBy'] }
        : { orderBy?: failed_jobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, failed_jobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFailed_jobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the failed_jobs model
   */
  readonly fields: failed_jobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for failed_jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__failed_jobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the failed_jobs model
   */
  interface failed_jobsFieldRefs {
    readonly id: FieldRef<"failed_jobs", 'BigInt'>
    readonly uuid: FieldRef<"failed_jobs", 'String'>
    readonly connection: FieldRef<"failed_jobs", 'String'>
    readonly queue: FieldRef<"failed_jobs", 'String'>
    readonly payload: FieldRef<"failed_jobs", 'String'>
    readonly exception: FieldRef<"failed_jobs", 'String'>
    readonly failed_at: FieldRef<"failed_jobs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * failed_jobs findUnique
   */
  export type failed_jobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
    /**
     * Filter, which failed_jobs to fetch.
     */
    where: failed_jobsWhereUniqueInput
  }

  /**
   * failed_jobs findUniqueOrThrow
   */
  export type failed_jobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
    /**
     * Filter, which failed_jobs to fetch.
     */
    where: failed_jobsWhereUniqueInput
  }

  /**
   * failed_jobs findFirst
   */
  export type failed_jobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
    /**
     * Filter, which failed_jobs to fetch.
     */
    where?: failed_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of failed_jobs to fetch.
     */
    orderBy?: failed_jobsOrderByWithRelationInput | failed_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for failed_jobs.
     */
    cursor?: failed_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` failed_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` failed_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of failed_jobs.
     */
    distinct?: Failed_jobsScalarFieldEnum | Failed_jobsScalarFieldEnum[]
  }

  /**
   * failed_jobs findFirstOrThrow
   */
  export type failed_jobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
    /**
     * Filter, which failed_jobs to fetch.
     */
    where?: failed_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of failed_jobs to fetch.
     */
    orderBy?: failed_jobsOrderByWithRelationInput | failed_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for failed_jobs.
     */
    cursor?: failed_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` failed_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` failed_jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of failed_jobs.
     */
    distinct?: Failed_jobsScalarFieldEnum | Failed_jobsScalarFieldEnum[]
  }

  /**
   * failed_jobs findMany
   */
  export type failed_jobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
    /**
     * Filter, which failed_jobs to fetch.
     */
    where?: failed_jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of failed_jobs to fetch.
     */
    orderBy?: failed_jobsOrderByWithRelationInput | failed_jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing failed_jobs.
     */
    cursor?: failed_jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` failed_jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` failed_jobs.
     */
    skip?: number
    distinct?: Failed_jobsScalarFieldEnum | Failed_jobsScalarFieldEnum[]
  }

  /**
   * failed_jobs create
   */
  export type failed_jobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
    /**
     * The data needed to create a failed_jobs.
     */
    data: XOR<failed_jobsCreateInput, failed_jobsUncheckedCreateInput>
  }

  /**
   * failed_jobs createMany
   */
  export type failed_jobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many failed_jobs.
     */
    data: failed_jobsCreateManyInput | failed_jobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * failed_jobs update
   */
  export type failed_jobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
    /**
     * The data needed to update a failed_jobs.
     */
    data: XOR<failed_jobsUpdateInput, failed_jobsUncheckedUpdateInput>
    /**
     * Choose, which failed_jobs to update.
     */
    where: failed_jobsWhereUniqueInput
  }

  /**
   * failed_jobs updateMany
   */
  export type failed_jobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update failed_jobs.
     */
    data: XOR<failed_jobsUpdateManyMutationInput, failed_jobsUncheckedUpdateManyInput>
    /**
     * Filter which failed_jobs to update
     */
    where?: failed_jobsWhereInput
    /**
     * Limit how many failed_jobs to update.
     */
    limit?: number
  }

  /**
   * failed_jobs upsert
   */
  export type failed_jobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
    /**
     * The filter to search for the failed_jobs to update in case it exists.
     */
    where: failed_jobsWhereUniqueInput
    /**
     * In case the failed_jobs found by the `where` argument doesn't exist, create a new failed_jobs with this data.
     */
    create: XOR<failed_jobsCreateInput, failed_jobsUncheckedCreateInput>
    /**
     * In case the failed_jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<failed_jobsUpdateInput, failed_jobsUncheckedUpdateInput>
  }

  /**
   * failed_jobs delete
   */
  export type failed_jobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
    /**
     * Filter which failed_jobs to delete.
     */
    where: failed_jobsWhereUniqueInput
  }

  /**
   * failed_jobs deleteMany
   */
  export type failed_jobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which failed_jobs to delete
     */
    where?: failed_jobsWhereInput
    /**
     * Limit how many failed_jobs to delete.
     */
    limit?: number
  }

  /**
   * failed_jobs without action
   */
  export type failed_jobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the failed_jobs
     */
    select?: failed_jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the failed_jobs
     */
    omit?: failed_jobsOmit<ExtArgs> | null
  }


  /**
   * Model jobs
   */

  export type AggregateJobs = {
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  export type JobsAvgAggregateOutputType = {
    id: number | null
    attempts: number | null
    reserved_at: number | null
    available_at: number | null
    created_at: number | null
  }

  export type JobsSumAggregateOutputType = {
    id: bigint | null
    attempts: number | null
    reserved_at: number | null
    available_at: number | null
    created_at: number | null
  }

  export type JobsMinAggregateOutputType = {
    id: bigint | null
    queue: string | null
    payload: string | null
    attempts: number | null
    reserved_at: number | null
    available_at: number | null
    created_at: number | null
  }

  export type JobsMaxAggregateOutputType = {
    id: bigint | null
    queue: string | null
    payload: string | null
    attempts: number | null
    reserved_at: number | null
    available_at: number | null
    created_at: number | null
  }

  export type JobsCountAggregateOutputType = {
    id: number
    queue: number
    payload: number
    attempts: number
    reserved_at: number
    available_at: number
    created_at: number
    _all: number
  }


  export type JobsAvgAggregateInputType = {
    id?: true
    attempts?: true
    reserved_at?: true
    available_at?: true
    created_at?: true
  }

  export type JobsSumAggregateInputType = {
    id?: true
    attempts?: true
    reserved_at?: true
    available_at?: true
    created_at?: true
  }

  export type JobsMinAggregateInputType = {
    id?: true
    queue?: true
    payload?: true
    attempts?: true
    reserved_at?: true
    available_at?: true
    created_at?: true
  }

  export type JobsMaxAggregateInputType = {
    id?: true
    queue?: true
    payload?: true
    attempts?: true
    reserved_at?: true
    available_at?: true
    created_at?: true
  }

  export type JobsCountAggregateInputType = {
    id?: true
    queue?: true
    payload?: true
    attempts?: true
    reserved_at?: true
    available_at?: true
    created_at?: true
    _all?: true
  }

  export type JobsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobs to aggregate.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned jobs
    **/
    _count?: true | JobsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JobsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JobsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JobsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JobsMaxAggregateInputType
  }

  export type GetJobsAggregateType<T extends JobsAggregateArgs> = {
        [P in keyof T & keyof AggregateJobs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJobs[P]>
      : GetScalarType<T[P], AggregateJobs[P]>
  }




  export type jobsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: jobsWhereInput
    orderBy?: jobsOrderByWithAggregationInput | jobsOrderByWithAggregationInput[]
    by: JobsScalarFieldEnum[] | JobsScalarFieldEnum
    having?: jobsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JobsCountAggregateInputType | true
    _avg?: JobsAvgAggregateInputType
    _sum?: JobsSumAggregateInputType
    _min?: JobsMinAggregateInputType
    _max?: JobsMaxAggregateInputType
  }

  export type JobsGroupByOutputType = {
    id: bigint
    queue: string
    payload: string
    attempts: number
    reserved_at: number | null
    available_at: number
    created_at: number
    _count: JobsCountAggregateOutputType | null
    _avg: JobsAvgAggregateOutputType | null
    _sum: JobsSumAggregateOutputType | null
    _min: JobsMinAggregateOutputType | null
    _max: JobsMaxAggregateOutputType | null
  }

  type GetJobsGroupByPayload<T extends jobsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JobsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JobsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JobsGroupByOutputType[P]>
            : GetScalarType<T[P], JobsGroupByOutputType[P]>
        }
      >
    >


  export type jobsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    queue?: boolean
    payload?: boolean
    attempts?: boolean
    reserved_at?: boolean
    available_at?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["jobs"]>



  export type jobsSelectScalar = {
    id?: boolean
    queue?: boolean
    payload?: boolean
    attempts?: boolean
    reserved_at?: boolean
    available_at?: boolean
    created_at?: boolean
  }

  export type jobsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "queue" | "payload" | "attempts" | "reserved_at" | "available_at" | "created_at", ExtArgs["result"]["jobs"]>

  export type $jobsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "jobs"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      queue: string
      payload: string
      attempts: number
      reserved_at: number | null
      available_at: number
      created_at: number
    }, ExtArgs["result"]["jobs"]>
    composites: {}
  }

  type jobsGetPayload<S extends boolean | null | undefined | jobsDefaultArgs> = $Result.GetResult<Prisma.$jobsPayload, S>

  type jobsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<jobsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JobsCountAggregateInputType | true
    }

  export interface jobsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['jobs'], meta: { name: 'jobs' } }
    /**
     * Find zero or one Jobs that matches the filter.
     * @param {jobsFindUniqueArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends jobsFindUniqueArgs>(args: SelectSubset<T, jobsFindUniqueArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Jobs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {jobsFindUniqueOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends jobsFindUniqueOrThrowArgs>(args: SelectSubset<T, jobsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsFindFirstArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends jobsFindFirstArgs>(args?: SelectSubset<T, jobsFindFirstArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Jobs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsFindFirstOrThrowArgs} args - Arguments to find a Jobs
     * @example
     * // Get one Jobs
     * const jobs = await prisma.jobs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends jobsFindFirstOrThrowArgs>(args?: SelectSubset<T, jobsFindFirstOrThrowArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Jobs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Jobs
     * const jobs = await prisma.jobs.findMany()
     * 
     * // Get first 10 Jobs
     * const jobs = await prisma.jobs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jobsWithIdOnly = await prisma.jobs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends jobsFindManyArgs>(args?: SelectSubset<T, jobsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Jobs.
     * @param {jobsCreateArgs} args - Arguments to create a Jobs.
     * @example
     * // Create one Jobs
     * const Jobs = await prisma.jobs.create({
     *   data: {
     *     // ... data to create a Jobs
     *   }
     * })
     * 
     */
    create<T extends jobsCreateArgs>(args: SelectSubset<T, jobsCreateArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Jobs.
     * @param {jobsCreateManyArgs} args - Arguments to create many Jobs.
     * @example
     * // Create many Jobs
     * const jobs = await prisma.jobs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends jobsCreateManyArgs>(args?: SelectSubset<T, jobsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Jobs.
     * @param {jobsDeleteArgs} args - Arguments to delete one Jobs.
     * @example
     * // Delete one Jobs
     * const Jobs = await prisma.jobs.delete({
     *   where: {
     *     // ... filter to delete one Jobs
     *   }
     * })
     * 
     */
    delete<T extends jobsDeleteArgs>(args: SelectSubset<T, jobsDeleteArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Jobs.
     * @param {jobsUpdateArgs} args - Arguments to update one Jobs.
     * @example
     * // Update one Jobs
     * const jobs = await prisma.jobs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends jobsUpdateArgs>(args: SelectSubset<T, jobsUpdateArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Jobs.
     * @param {jobsDeleteManyArgs} args - Arguments to filter Jobs to delete.
     * @example
     * // Delete a few Jobs
     * const { count } = await prisma.jobs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends jobsDeleteManyArgs>(args?: SelectSubset<T, jobsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Jobs
     * const jobs = await prisma.jobs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends jobsUpdateManyArgs>(args: SelectSubset<T, jobsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Jobs.
     * @param {jobsUpsertArgs} args - Arguments to update or create a Jobs.
     * @example
     * // Update or create a Jobs
     * const jobs = await prisma.jobs.upsert({
     *   create: {
     *     // ... data to create a Jobs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Jobs we want to update
     *   }
     * })
     */
    upsert<T extends jobsUpsertArgs>(args: SelectSubset<T, jobsUpsertArgs<ExtArgs>>): Prisma__jobsClient<$Result.GetResult<Prisma.$jobsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsCountArgs} args - Arguments to filter Jobs to count.
     * @example
     * // Count the number of Jobs
     * const count = await prisma.jobs.count({
     *   where: {
     *     // ... the filter for the Jobs we want to count
     *   }
     * })
    **/
    count<T extends jobsCountArgs>(
      args?: Subset<T, jobsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JobsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JobsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JobsAggregateArgs>(args: Subset<T, JobsAggregateArgs>): Prisma.PrismaPromise<GetJobsAggregateType<T>>

    /**
     * Group by Jobs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {jobsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends jobsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: jobsGroupByArgs['orderBy'] }
        : { orderBy?: jobsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, jobsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJobsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the jobs model
   */
  readonly fields: jobsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for jobs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__jobsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the jobs model
   */
  interface jobsFieldRefs {
    readonly id: FieldRef<"jobs", 'BigInt'>
    readonly queue: FieldRef<"jobs", 'String'>
    readonly payload: FieldRef<"jobs", 'String'>
    readonly attempts: FieldRef<"jobs", 'Int'>
    readonly reserved_at: FieldRef<"jobs", 'Int'>
    readonly available_at: FieldRef<"jobs", 'Int'>
    readonly created_at: FieldRef<"jobs", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * jobs findUnique
   */
  export type jobsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs findUniqueOrThrow
   */
  export type jobsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs findFirst
   */
  export type jobsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobs.
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * jobs findFirstOrThrow
   */
  export type jobsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for jobs.
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of jobs.
     */
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * jobs findMany
   */
  export type jobsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Filter, which jobs to fetch.
     */
    where?: jobsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of jobs to fetch.
     */
    orderBy?: jobsOrderByWithRelationInput | jobsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing jobs.
     */
    cursor?: jobsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` jobs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` jobs.
     */
    skip?: number
    distinct?: JobsScalarFieldEnum | JobsScalarFieldEnum[]
  }

  /**
   * jobs create
   */
  export type jobsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * The data needed to create a jobs.
     */
    data: XOR<jobsCreateInput, jobsUncheckedCreateInput>
  }

  /**
   * jobs createMany
   */
  export type jobsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many jobs.
     */
    data: jobsCreateManyInput | jobsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * jobs update
   */
  export type jobsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * The data needed to update a jobs.
     */
    data: XOR<jobsUpdateInput, jobsUncheckedUpdateInput>
    /**
     * Choose, which jobs to update.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs updateMany
   */
  export type jobsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update jobs.
     */
    data: XOR<jobsUpdateManyMutationInput, jobsUncheckedUpdateManyInput>
    /**
     * Filter which jobs to update
     */
    where?: jobsWhereInput
    /**
     * Limit how many jobs to update.
     */
    limit?: number
  }

  /**
   * jobs upsert
   */
  export type jobsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * The filter to search for the jobs to update in case it exists.
     */
    where: jobsWhereUniqueInput
    /**
     * In case the jobs found by the `where` argument doesn't exist, create a new jobs with this data.
     */
    create: XOR<jobsCreateInput, jobsUncheckedCreateInput>
    /**
     * In case the jobs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<jobsUpdateInput, jobsUncheckedUpdateInput>
  }

  /**
   * jobs delete
   */
  export type jobsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
    /**
     * Filter which jobs to delete.
     */
    where: jobsWhereUniqueInput
  }

  /**
   * jobs deleteMany
   */
  export type jobsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which jobs to delete
     */
    where?: jobsWhereInput
    /**
     * Limit how many jobs to delete.
     */
    limit?: number
  }

  /**
   * jobs without action
   */
  export type jobsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the jobs
     */
    select?: jobsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the jobs
     */
    omit?: jobsOmit<ExtArgs> | null
  }


  /**
   * Model migrations
   */

  export type AggregateMigrations = {
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  export type MigrationsAvgAggregateOutputType = {
    id: number | null
    batch: number | null
  }

  export type MigrationsSumAggregateOutputType = {
    id: number | null
    batch: number | null
  }

  export type MigrationsMinAggregateOutputType = {
    id: number | null
    migration: string | null
    batch: number | null
  }

  export type MigrationsMaxAggregateOutputType = {
    id: number | null
    migration: string | null
    batch: number | null
  }

  export type MigrationsCountAggregateOutputType = {
    id: number
    migration: number
    batch: number
    _all: number
  }


  export type MigrationsAvgAggregateInputType = {
    id?: true
    batch?: true
  }

  export type MigrationsSumAggregateInputType = {
    id?: true
    batch?: true
  }

  export type MigrationsMinAggregateInputType = {
    id?: true
    migration?: true
    batch?: true
  }

  export type MigrationsMaxAggregateInputType = {
    id?: true
    migration?: true
    batch?: true
  }

  export type MigrationsCountAggregateInputType = {
    id?: true
    migration?: true
    batch?: true
    _all?: true
  }

  export type MigrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to aggregate.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned migrations
    **/
    _count?: true | MigrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MigrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MigrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MigrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MigrationsMaxAggregateInputType
  }

  export type GetMigrationsAggregateType<T extends MigrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateMigrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMigrations[P]>
      : GetScalarType<T[P], AggregateMigrations[P]>
  }




  export type migrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: migrationsWhereInput
    orderBy?: migrationsOrderByWithAggregationInput | migrationsOrderByWithAggregationInput[]
    by: MigrationsScalarFieldEnum[] | MigrationsScalarFieldEnum
    having?: migrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MigrationsCountAggregateInputType | true
    _avg?: MigrationsAvgAggregateInputType
    _sum?: MigrationsSumAggregateInputType
    _min?: MigrationsMinAggregateInputType
    _max?: MigrationsMaxAggregateInputType
  }

  export type MigrationsGroupByOutputType = {
    id: number
    migration: string
    batch: number
    _count: MigrationsCountAggregateOutputType | null
    _avg: MigrationsAvgAggregateOutputType | null
    _sum: MigrationsSumAggregateOutputType | null
    _min: MigrationsMinAggregateOutputType | null
    _max: MigrationsMaxAggregateOutputType | null
  }

  type GetMigrationsGroupByPayload<T extends migrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MigrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MigrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
            : GetScalarType<T[P], MigrationsGroupByOutputType[P]>
        }
      >
    >


  export type migrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    migration?: boolean
    batch?: boolean
  }, ExtArgs["result"]["migrations"]>



  export type migrationsSelectScalar = {
    id?: boolean
    migration?: boolean
    batch?: boolean
  }

  export type migrationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "migration" | "batch", ExtArgs["result"]["migrations"]>

  export type $migrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "migrations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      migration: string
      batch: number
    }, ExtArgs["result"]["migrations"]>
    composites: {}
  }

  type migrationsGetPayload<S extends boolean | null | undefined | migrationsDefaultArgs> = $Result.GetResult<Prisma.$migrationsPayload, S>

  type migrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<migrationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MigrationsCountAggregateInputType | true
    }

  export interface migrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['migrations'], meta: { name: 'migrations' } }
    /**
     * Find zero or one Migrations that matches the filter.
     * @param {migrationsFindUniqueArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends migrationsFindUniqueArgs>(args: SelectSubset<T, migrationsFindUniqueArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Migrations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {migrationsFindUniqueOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends migrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, migrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends migrationsFindFirstArgs>(args?: SelectSubset<T, migrationsFindFirstArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Migrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindFirstOrThrowArgs} args - Arguments to find a Migrations
     * @example
     * // Get one Migrations
     * const migrations = await prisma.migrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends migrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, migrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Migrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Migrations
     * const migrations = await prisma.migrations.findMany()
     * 
     * // Get first 10 Migrations
     * const migrations = await prisma.migrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const migrationsWithIdOnly = await prisma.migrations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends migrationsFindManyArgs>(args?: SelectSubset<T, migrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Migrations.
     * @param {migrationsCreateArgs} args - Arguments to create a Migrations.
     * @example
     * // Create one Migrations
     * const Migrations = await prisma.migrations.create({
     *   data: {
     *     // ... data to create a Migrations
     *   }
     * })
     * 
     */
    create<T extends migrationsCreateArgs>(args: SelectSubset<T, migrationsCreateArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Migrations.
     * @param {migrationsCreateManyArgs} args - Arguments to create many Migrations.
     * @example
     * // Create many Migrations
     * const migrations = await prisma.migrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends migrationsCreateManyArgs>(args?: SelectSubset<T, migrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Migrations.
     * @param {migrationsDeleteArgs} args - Arguments to delete one Migrations.
     * @example
     * // Delete one Migrations
     * const Migrations = await prisma.migrations.delete({
     *   where: {
     *     // ... filter to delete one Migrations
     *   }
     * })
     * 
     */
    delete<T extends migrationsDeleteArgs>(args: SelectSubset<T, migrationsDeleteArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Migrations.
     * @param {migrationsUpdateArgs} args - Arguments to update one Migrations.
     * @example
     * // Update one Migrations
     * const migrations = await prisma.migrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends migrationsUpdateArgs>(args: SelectSubset<T, migrationsUpdateArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Migrations.
     * @param {migrationsDeleteManyArgs} args - Arguments to filter Migrations to delete.
     * @example
     * // Delete a few Migrations
     * const { count } = await prisma.migrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends migrationsDeleteManyArgs>(args?: SelectSubset<T, migrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Migrations
     * const migrations = await prisma.migrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends migrationsUpdateManyArgs>(args: SelectSubset<T, migrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Migrations.
     * @param {migrationsUpsertArgs} args - Arguments to update or create a Migrations.
     * @example
     * // Update or create a Migrations
     * const migrations = await prisma.migrations.upsert({
     *   create: {
     *     // ... data to create a Migrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Migrations we want to update
     *   }
     * })
     */
    upsert<T extends migrationsUpsertArgs>(args: SelectSubset<T, migrationsUpsertArgs<ExtArgs>>): Prisma__migrationsClient<$Result.GetResult<Prisma.$migrationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsCountArgs} args - Arguments to filter Migrations to count.
     * @example
     * // Count the number of Migrations
     * const count = await prisma.migrations.count({
     *   where: {
     *     // ... the filter for the Migrations we want to count
     *   }
     * })
    **/
    count<T extends migrationsCountArgs>(
      args?: Subset<T, migrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MigrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MigrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MigrationsAggregateArgs>(args: Subset<T, MigrationsAggregateArgs>): Prisma.PrismaPromise<GetMigrationsAggregateType<T>>

    /**
     * Group by Migrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {migrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends migrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: migrationsGroupByArgs['orderBy'] }
        : { orderBy?: migrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, migrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMigrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the migrations model
   */
  readonly fields: migrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for migrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__migrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the migrations model
   */
  interface migrationsFieldRefs {
    readonly id: FieldRef<"migrations", 'Int'>
    readonly migration: FieldRef<"migrations", 'String'>
    readonly batch: FieldRef<"migrations", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * migrations findUnique
   */
  export type migrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations findUniqueOrThrow
   */
  export type migrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations findFirst
   */
  export type migrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations findFirstOrThrow
   */
  export type migrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of migrations.
     */
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations findMany
   */
  export type migrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter, which migrations to fetch.
     */
    where?: migrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of migrations to fetch.
     */
    orderBy?: migrationsOrderByWithRelationInput | migrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing migrations.
     */
    cursor?: migrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` migrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` migrations.
     */
    skip?: number
    distinct?: MigrationsScalarFieldEnum | MigrationsScalarFieldEnum[]
  }

  /**
   * migrations create
   */
  export type migrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data needed to create a migrations.
     */
    data: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
  }

  /**
   * migrations createMany
   */
  export type migrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many migrations.
     */
    data: migrationsCreateManyInput | migrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * migrations update
   */
  export type migrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The data needed to update a migrations.
     */
    data: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
    /**
     * Choose, which migrations to update.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations updateMany
   */
  export type migrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update migrations.
     */
    data: XOR<migrationsUpdateManyMutationInput, migrationsUncheckedUpdateManyInput>
    /**
     * Filter which migrations to update
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to update.
     */
    limit?: number
  }

  /**
   * migrations upsert
   */
  export type migrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * The filter to search for the migrations to update in case it exists.
     */
    where: migrationsWhereUniqueInput
    /**
     * In case the migrations found by the `where` argument doesn't exist, create a new migrations with this data.
     */
    create: XOR<migrationsCreateInput, migrationsUncheckedCreateInput>
    /**
     * In case the migrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<migrationsUpdateInput, migrationsUncheckedUpdateInput>
  }

  /**
   * migrations delete
   */
  export type migrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
    /**
     * Filter which migrations to delete.
     */
    where: migrationsWhereUniqueInput
  }

  /**
   * migrations deleteMany
   */
  export type migrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which migrations to delete
     */
    where?: migrationsWhereInput
    /**
     * Limit how many migrations to delete.
     */
    limit?: number
  }

  /**
   * migrations without action
   */
  export type migrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the migrations
     */
    select?: migrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the migrations
     */
    omit?: migrationsOmit<ExtArgs> | null
  }


  /**
   * Model model_has_permissions
   */

  export type AggregateModel_has_permissions = {
    _count: Model_has_permissionsCountAggregateOutputType | null
    _avg: Model_has_permissionsAvgAggregateOutputType | null
    _sum: Model_has_permissionsSumAggregateOutputType | null
    _min: Model_has_permissionsMinAggregateOutputType | null
    _max: Model_has_permissionsMaxAggregateOutputType | null
  }

  export type Model_has_permissionsAvgAggregateOutputType = {
    permission_id: number | null
    model_id: number | null
  }

  export type Model_has_permissionsSumAggregateOutputType = {
    permission_id: bigint | null
    model_id: bigint | null
  }

  export type Model_has_permissionsMinAggregateOutputType = {
    permission_id: bigint | null
    model_type: string | null
    model_id: bigint | null
  }

  export type Model_has_permissionsMaxAggregateOutputType = {
    permission_id: bigint | null
    model_type: string | null
    model_id: bigint | null
  }

  export type Model_has_permissionsCountAggregateOutputType = {
    permission_id: number
    model_type: number
    model_id: number
    _all: number
  }


  export type Model_has_permissionsAvgAggregateInputType = {
    permission_id?: true
    model_id?: true
  }

  export type Model_has_permissionsSumAggregateInputType = {
    permission_id?: true
    model_id?: true
  }

  export type Model_has_permissionsMinAggregateInputType = {
    permission_id?: true
    model_type?: true
    model_id?: true
  }

  export type Model_has_permissionsMaxAggregateInputType = {
    permission_id?: true
    model_type?: true
    model_id?: true
  }

  export type Model_has_permissionsCountAggregateInputType = {
    permission_id?: true
    model_type?: true
    model_id?: true
    _all?: true
  }

  export type Model_has_permissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which model_has_permissions to aggregate.
     */
    where?: model_has_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_has_permissions to fetch.
     */
    orderBy?: model_has_permissionsOrderByWithRelationInput | model_has_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: model_has_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_has_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_has_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned model_has_permissions
    **/
    _count?: true | Model_has_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Model_has_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Model_has_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Model_has_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Model_has_permissionsMaxAggregateInputType
  }

  export type GetModel_has_permissionsAggregateType<T extends Model_has_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateModel_has_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModel_has_permissions[P]>
      : GetScalarType<T[P], AggregateModel_has_permissions[P]>
  }




  export type model_has_permissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: model_has_permissionsWhereInput
    orderBy?: model_has_permissionsOrderByWithAggregationInput | model_has_permissionsOrderByWithAggregationInput[]
    by: Model_has_permissionsScalarFieldEnum[] | Model_has_permissionsScalarFieldEnum
    having?: model_has_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Model_has_permissionsCountAggregateInputType | true
    _avg?: Model_has_permissionsAvgAggregateInputType
    _sum?: Model_has_permissionsSumAggregateInputType
    _min?: Model_has_permissionsMinAggregateInputType
    _max?: Model_has_permissionsMaxAggregateInputType
  }

  export type Model_has_permissionsGroupByOutputType = {
    permission_id: bigint
    model_type: string
    model_id: bigint
    _count: Model_has_permissionsCountAggregateOutputType | null
    _avg: Model_has_permissionsAvgAggregateOutputType | null
    _sum: Model_has_permissionsSumAggregateOutputType | null
    _min: Model_has_permissionsMinAggregateOutputType | null
    _max: Model_has_permissionsMaxAggregateOutputType | null
  }

  type GetModel_has_permissionsGroupByPayload<T extends model_has_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Model_has_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Model_has_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Model_has_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Model_has_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type model_has_permissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permission_id?: boolean
    model_type?: boolean
    model_id?: boolean
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model_has_permissions"]>



  export type model_has_permissionsSelectScalar = {
    permission_id?: boolean
    model_type?: boolean
    model_id?: boolean
  }

  export type model_has_permissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"permission_id" | "model_type" | "model_id", ExtArgs["result"]["model_has_permissions"]>
  export type model_has_permissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
  }

  export type $model_has_permissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "model_has_permissions"
    objects: {
      permissions: Prisma.$permissionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      permission_id: bigint
      model_type: string
      model_id: bigint
    }, ExtArgs["result"]["model_has_permissions"]>
    composites: {}
  }

  type model_has_permissionsGetPayload<S extends boolean | null | undefined | model_has_permissionsDefaultArgs> = $Result.GetResult<Prisma.$model_has_permissionsPayload, S>

  type model_has_permissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<model_has_permissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Model_has_permissionsCountAggregateInputType | true
    }

  export interface model_has_permissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['model_has_permissions'], meta: { name: 'model_has_permissions' } }
    /**
     * Find zero or one Model_has_permissions that matches the filter.
     * @param {model_has_permissionsFindUniqueArgs} args - Arguments to find a Model_has_permissions
     * @example
     * // Get one Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends model_has_permissionsFindUniqueArgs>(args: SelectSubset<T, model_has_permissionsFindUniqueArgs<ExtArgs>>): Prisma__model_has_permissionsClient<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Model_has_permissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {model_has_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Model_has_permissions
     * @example
     * // Get one Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends model_has_permissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, model_has_permissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__model_has_permissionsClient<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Model_has_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_permissionsFindFirstArgs} args - Arguments to find a Model_has_permissions
     * @example
     * // Get one Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends model_has_permissionsFindFirstArgs>(args?: SelectSubset<T, model_has_permissionsFindFirstArgs<ExtArgs>>): Prisma__model_has_permissionsClient<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Model_has_permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_permissionsFindFirstOrThrowArgs} args - Arguments to find a Model_has_permissions
     * @example
     * // Get one Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends model_has_permissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, model_has_permissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__model_has_permissionsClient<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Model_has_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_permissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.findMany()
     * 
     * // Get first 10 Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.findMany({ take: 10 })
     * 
     * // Only select the `permission_id`
     * const model_has_permissionsWithPermission_idOnly = await prisma.model_has_permissions.findMany({ select: { permission_id: true } })
     * 
     */
    findMany<T extends model_has_permissionsFindManyArgs>(args?: SelectSubset<T, model_has_permissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Model_has_permissions.
     * @param {model_has_permissionsCreateArgs} args - Arguments to create a Model_has_permissions.
     * @example
     * // Create one Model_has_permissions
     * const Model_has_permissions = await prisma.model_has_permissions.create({
     *   data: {
     *     // ... data to create a Model_has_permissions
     *   }
     * })
     * 
     */
    create<T extends model_has_permissionsCreateArgs>(args: SelectSubset<T, model_has_permissionsCreateArgs<ExtArgs>>): Prisma__model_has_permissionsClient<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Model_has_permissions.
     * @param {model_has_permissionsCreateManyArgs} args - Arguments to create many Model_has_permissions.
     * @example
     * // Create many Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends model_has_permissionsCreateManyArgs>(args?: SelectSubset<T, model_has_permissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Model_has_permissions.
     * @param {model_has_permissionsDeleteArgs} args - Arguments to delete one Model_has_permissions.
     * @example
     * // Delete one Model_has_permissions
     * const Model_has_permissions = await prisma.model_has_permissions.delete({
     *   where: {
     *     // ... filter to delete one Model_has_permissions
     *   }
     * })
     * 
     */
    delete<T extends model_has_permissionsDeleteArgs>(args: SelectSubset<T, model_has_permissionsDeleteArgs<ExtArgs>>): Prisma__model_has_permissionsClient<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Model_has_permissions.
     * @param {model_has_permissionsUpdateArgs} args - Arguments to update one Model_has_permissions.
     * @example
     * // Update one Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends model_has_permissionsUpdateArgs>(args: SelectSubset<T, model_has_permissionsUpdateArgs<ExtArgs>>): Prisma__model_has_permissionsClient<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Model_has_permissions.
     * @param {model_has_permissionsDeleteManyArgs} args - Arguments to filter Model_has_permissions to delete.
     * @example
     * // Delete a few Model_has_permissions
     * const { count } = await prisma.model_has_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends model_has_permissionsDeleteManyArgs>(args?: SelectSubset<T, model_has_permissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Model_has_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends model_has_permissionsUpdateManyArgs>(args: SelectSubset<T, model_has_permissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Model_has_permissions.
     * @param {model_has_permissionsUpsertArgs} args - Arguments to update or create a Model_has_permissions.
     * @example
     * // Update or create a Model_has_permissions
     * const model_has_permissions = await prisma.model_has_permissions.upsert({
     *   create: {
     *     // ... data to create a Model_has_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Model_has_permissions we want to update
     *   }
     * })
     */
    upsert<T extends model_has_permissionsUpsertArgs>(args: SelectSubset<T, model_has_permissionsUpsertArgs<ExtArgs>>): Prisma__model_has_permissionsClient<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Model_has_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_permissionsCountArgs} args - Arguments to filter Model_has_permissions to count.
     * @example
     * // Count the number of Model_has_permissions
     * const count = await prisma.model_has_permissions.count({
     *   where: {
     *     // ... the filter for the Model_has_permissions we want to count
     *   }
     * })
    **/
    count<T extends model_has_permissionsCountArgs>(
      args?: Subset<T, model_has_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Model_has_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Model_has_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Model_has_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Model_has_permissionsAggregateArgs>(args: Subset<T, Model_has_permissionsAggregateArgs>): Prisma.PrismaPromise<GetModel_has_permissionsAggregateType<T>>

    /**
     * Group by Model_has_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends model_has_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: model_has_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: model_has_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, model_has_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModel_has_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the model_has_permissions model
   */
  readonly fields: model_has_permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for model_has_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__model_has_permissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends permissionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, permissionsDefaultArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the model_has_permissions model
   */
  interface model_has_permissionsFieldRefs {
    readonly permission_id: FieldRef<"model_has_permissions", 'BigInt'>
    readonly model_type: FieldRef<"model_has_permissions", 'String'>
    readonly model_id: FieldRef<"model_has_permissions", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * model_has_permissions findUnique
   */
  export type model_has_permissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which model_has_permissions to fetch.
     */
    where: model_has_permissionsWhereUniqueInput
  }

  /**
   * model_has_permissions findUniqueOrThrow
   */
  export type model_has_permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which model_has_permissions to fetch.
     */
    where: model_has_permissionsWhereUniqueInput
  }

  /**
   * model_has_permissions findFirst
   */
  export type model_has_permissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which model_has_permissions to fetch.
     */
    where?: model_has_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_has_permissions to fetch.
     */
    orderBy?: model_has_permissionsOrderByWithRelationInput | model_has_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for model_has_permissions.
     */
    cursor?: model_has_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_has_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_has_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of model_has_permissions.
     */
    distinct?: Model_has_permissionsScalarFieldEnum | Model_has_permissionsScalarFieldEnum[]
  }

  /**
   * model_has_permissions findFirstOrThrow
   */
  export type model_has_permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which model_has_permissions to fetch.
     */
    where?: model_has_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_has_permissions to fetch.
     */
    orderBy?: model_has_permissionsOrderByWithRelationInput | model_has_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for model_has_permissions.
     */
    cursor?: model_has_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_has_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_has_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of model_has_permissions.
     */
    distinct?: Model_has_permissionsScalarFieldEnum | Model_has_permissionsScalarFieldEnum[]
  }

  /**
   * model_has_permissions findMany
   */
  export type model_has_permissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which model_has_permissions to fetch.
     */
    where?: model_has_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_has_permissions to fetch.
     */
    orderBy?: model_has_permissionsOrderByWithRelationInput | model_has_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing model_has_permissions.
     */
    cursor?: model_has_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_has_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_has_permissions.
     */
    skip?: number
    distinct?: Model_has_permissionsScalarFieldEnum | Model_has_permissionsScalarFieldEnum[]
  }

  /**
   * model_has_permissions create
   */
  export type model_has_permissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a model_has_permissions.
     */
    data: XOR<model_has_permissionsCreateInput, model_has_permissionsUncheckedCreateInput>
  }

  /**
   * model_has_permissions createMany
   */
  export type model_has_permissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many model_has_permissions.
     */
    data: model_has_permissionsCreateManyInput | model_has_permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * model_has_permissions update
   */
  export type model_has_permissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a model_has_permissions.
     */
    data: XOR<model_has_permissionsUpdateInput, model_has_permissionsUncheckedUpdateInput>
    /**
     * Choose, which model_has_permissions to update.
     */
    where: model_has_permissionsWhereUniqueInput
  }

  /**
   * model_has_permissions updateMany
   */
  export type model_has_permissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update model_has_permissions.
     */
    data: XOR<model_has_permissionsUpdateManyMutationInput, model_has_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which model_has_permissions to update
     */
    where?: model_has_permissionsWhereInput
    /**
     * Limit how many model_has_permissions to update.
     */
    limit?: number
  }

  /**
   * model_has_permissions upsert
   */
  export type model_has_permissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the model_has_permissions to update in case it exists.
     */
    where: model_has_permissionsWhereUniqueInput
    /**
     * In case the model_has_permissions found by the `where` argument doesn't exist, create a new model_has_permissions with this data.
     */
    create: XOR<model_has_permissionsCreateInput, model_has_permissionsUncheckedCreateInput>
    /**
     * In case the model_has_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<model_has_permissionsUpdateInput, model_has_permissionsUncheckedUpdateInput>
  }

  /**
   * model_has_permissions delete
   */
  export type model_has_permissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter which model_has_permissions to delete.
     */
    where: model_has_permissionsWhereUniqueInput
  }

  /**
   * model_has_permissions deleteMany
   */
  export type model_has_permissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which model_has_permissions to delete
     */
    where?: model_has_permissionsWhereInput
    /**
     * Limit how many model_has_permissions to delete.
     */
    limit?: number
  }

  /**
   * model_has_permissions without action
   */
  export type model_has_permissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
  }


  /**
   * Model model_has_roles
   */

  export type AggregateModel_has_roles = {
    _count: Model_has_rolesCountAggregateOutputType | null
    _avg: Model_has_rolesAvgAggregateOutputType | null
    _sum: Model_has_rolesSumAggregateOutputType | null
    _min: Model_has_rolesMinAggregateOutputType | null
    _max: Model_has_rolesMaxAggregateOutputType | null
  }

  export type Model_has_rolesAvgAggregateOutputType = {
    role_id: number | null
    model_id: number | null
  }

  export type Model_has_rolesSumAggregateOutputType = {
    role_id: bigint | null
    model_id: bigint | null
  }

  export type Model_has_rolesMinAggregateOutputType = {
    role_id: bigint | null
    model_type: string | null
    model_id: bigint | null
  }

  export type Model_has_rolesMaxAggregateOutputType = {
    role_id: bigint | null
    model_type: string | null
    model_id: bigint | null
  }

  export type Model_has_rolesCountAggregateOutputType = {
    role_id: number
    model_type: number
    model_id: number
    _all: number
  }


  export type Model_has_rolesAvgAggregateInputType = {
    role_id?: true
    model_id?: true
  }

  export type Model_has_rolesSumAggregateInputType = {
    role_id?: true
    model_id?: true
  }

  export type Model_has_rolesMinAggregateInputType = {
    role_id?: true
    model_type?: true
    model_id?: true
  }

  export type Model_has_rolesMaxAggregateInputType = {
    role_id?: true
    model_type?: true
    model_id?: true
  }

  export type Model_has_rolesCountAggregateInputType = {
    role_id?: true
    model_type?: true
    model_id?: true
    _all?: true
  }

  export type Model_has_rolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which model_has_roles to aggregate.
     */
    where?: model_has_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_has_roles to fetch.
     */
    orderBy?: model_has_rolesOrderByWithRelationInput | model_has_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: model_has_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_has_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_has_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned model_has_roles
    **/
    _count?: true | Model_has_rolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Model_has_rolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Model_has_rolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Model_has_rolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Model_has_rolesMaxAggregateInputType
  }

  export type GetModel_has_rolesAggregateType<T extends Model_has_rolesAggregateArgs> = {
        [P in keyof T & keyof AggregateModel_has_roles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModel_has_roles[P]>
      : GetScalarType<T[P], AggregateModel_has_roles[P]>
  }




  export type model_has_rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: model_has_rolesWhereInput
    orderBy?: model_has_rolesOrderByWithAggregationInput | model_has_rolesOrderByWithAggregationInput[]
    by: Model_has_rolesScalarFieldEnum[] | Model_has_rolesScalarFieldEnum
    having?: model_has_rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Model_has_rolesCountAggregateInputType | true
    _avg?: Model_has_rolesAvgAggregateInputType
    _sum?: Model_has_rolesSumAggregateInputType
    _min?: Model_has_rolesMinAggregateInputType
    _max?: Model_has_rolesMaxAggregateInputType
  }

  export type Model_has_rolesGroupByOutputType = {
    role_id: bigint
    model_type: string
    model_id: bigint
    _count: Model_has_rolesCountAggregateOutputType | null
    _avg: Model_has_rolesAvgAggregateOutputType | null
    _sum: Model_has_rolesSumAggregateOutputType | null
    _min: Model_has_rolesMinAggregateOutputType | null
    _max: Model_has_rolesMaxAggregateOutputType | null
  }

  type GetModel_has_rolesGroupByPayload<T extends model_has_rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Model_has_rolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Model_has_rolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Model_has_rolesGroupByOutputType[P]>
            : GetScalarType<T[P], Model_has_rolesGroupByOutputType[P]>
        }
      >
    >


  export type model_has_rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    role_id?: boolean
    model_type?: boolean
    model_id?: boolean
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["model_has_roles"]>



  export type model_has_rolesSelectScalar = {
    role_id?: boolean
    model_type?: boolean
    model_id?: boolean
  }

  export type model_has_rolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"role_id" | "model_type" | "model_id", ExtArgs["result"]["model_has_roles"]>
  export type model_has_rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }

  export type $model_has_rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "model_has_roles"
    objects: {
      roles: Prisma.$rolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      role_id: bigint
      model_type: string
      model_id: bigint
    }, ExtArgs["result"]["model_has_roles"]>
    composites: {}
  }

  type model_has_rolesGetPayload<S extends boolean | null | undefined | model_has_rolesDefaultArgs> = $Result.GetResult<Prisma.$model_has_rolesPayload, S>

  type model_has_rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<model_has_rolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Model_has_rolesCountAggregateInputType | true
    }

  export interface model_has_rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['model_has_roles'], meta: { name: 'model_has_roles' } }
    /**
     * Find zero or one Model_has_roles that matches the filter.
     * @param {model_has_rolesFindUniqueArgs} args - Arguments to find a Model_has_roles
     * @example
     * // Get one Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends model_has_rolesFindUniqueArgs>(args: SelectSubset<T, model_has_rolesFindUniqueArgs<ExtArgs>>): Prisma__model_has_rolesClient<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Model_has_roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {model_has_rolesFindUniqueOrThrowArgs} args - Arguments to find a Model_has_roles
     * @example
     * // Get one Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends model_has_rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, model_has_rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__model_has_rolesClient<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Model_has_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_rolesFindFirstArgs} args - Arguments to find a Model_has_roles
     * @example
     * // Get one Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends model_has_rolesFindFirstArgs>(args?: SelectSubset<T, model_has_rolesFindFirstArgs<ExtArgs>>): Prisma__model_has_rolesClient<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Model_has_roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_rolesFindFirstOrThrowArgs} args - Arguments to find a Model_has_roles
     * @example
     * // Get one Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends model_has_rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, model_has_rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__model_has_rolesClient<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Model_has_roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.findMany()
     * 
     * // Get first 10 Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.findMany({ take: 10 })
     * 
     * // Only select the `role_id`
     * const model_has_rolesWithRole_idOnly = await prisma.model_has_roles.findMany({ select: { role_id: true } })
     * 
     */
    findMany<T extends model_has_rolesFindManyArgs>(args?: SelectSubset<T, model_has_rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Model_has_roles.
     * @param {model_has_rolesCreateArgs} args - Arguments to create a Model_has_roles.
     * @example
     * // Create one Model_has_roles
     * const Model_has_roles = await prisma.model_has_roles.create({
     *   data: {
     *     // ... data to create a Model_has_roles
     *   }
     * })
     * 
     */
    create<T extends model_has_rolesCreateArgs>(args: SelectSubset<T, model_has_rolesCreateArgs<ExtArgs>>): Prisma__model_has_rolesClient<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Model_has_roles.
     * @param {model_has_rolesCreateManyArgs} args - Arguments to create many Model_has_roles.
     * @example
     * // Create many Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends model_has_rolesCreateManyArgs>(args?: SelectSubset<T, model_has_rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Model_has_roles.
     * @param {model_has_rolesDeleteArgs} args - Arguments to delete one Model_has_roles.
     * @example
     * // Delete one Model_has_roles
     * const Model_has_roles = await prisma.model_has_roles.delete({
     *   where: {
     *     // ... filter to delete one Model_has_roles
     *   }
     * })
     * 
     */
    delete<T extends model_has_rolesDeleteArgs>(args: SelectSubset<T, model_has_rolesDeleteArgs<ExtArgs>>): Prisma__model_has_rolesClient<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Model_has_roles.
     * @param {model_has_rolesUpdateArgs} args - Arguments to update one Model_has_roles.
     * @example
     * // Update one Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends model_has_rolesUpdateArgs>(args: SelectSubset<T, model_has_rolesUpdateArgs<ExtArgs>>): Prisma__model_has_rolesClient<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Model_has_roles.
     * @param {model_has_rolesDeleteManyArgs} args - Arguments to filter Model_has_roles to delete.
     * @example
     * // Delete a few Model_has_roles
     * const { count } = await prisma.model_has_roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends model_has_rolesDeleteManyArgs>(args?: SelectSubset<T, model_has_rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Model_has_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends model_has_rolesUpdateManyArgs>(args: SelectSubset<T, model_has_rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Model_has_roles.
     * @param {model_has_rolesUpsertArgs} args - Arguments to update or create a Model_has_roles.
     * @example
     * // Update or create a Model_has_roles
     * const model_has_roles = await prisma.model_has_roles.upsert({
     *   create: {
     *     // ... data to create a Model_has_roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Model_has_roles we want to update
     *   }
     * })
     */
    upsert<T extends model_has_rolesUpsertArgs>(args: SelectSubset<T, model_has_rolesUpsertArgs<ExtArgs>>): Prisma__model_has_rolesClient<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Model_has_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_rolesCountArgs} args - Arguments to filter Model_has_roles to count.
     * @example
     * // Count the number of Model_has_roles
     * const count = await prisma.model_has_roles.count({
     *   where: {
     *     // ... the filter for the Model_has_roles we want to count
     *   }
     * })
    **/
    count<T extends model_has_rolesCountArgs>(
      args?: Subset<T, model_has_rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Model_has_rolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Model_has_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Model_has_rolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Model_has_rolesAggregateArgs>(args: Subset<T, Model_has_rolesAggregateArgs>): Prisma.PrismaPromise<GetModel_has_rolesAggregateType<T>>

    /**
     * Group by Model_has_roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {model_has_rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends model_has_rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: model_has_rolesGroupByArgs['orderBy'] }
        : { orderBy?: model_has_rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, model_has_rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModel_has_rolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the model_has_roles model
   */
  readonly fields: model_has_rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for model_has_roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__model_has_rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the model_has_roles model
   */
  interface model_has_rolesFieldRefs {
    readonly role_id: FieldRef<"model_has_roles", 'BigInt'>
    readonly model_type: FieldRef<"model_has_roles", 'String'>
    readonly model_id: FieldRef<"model_has_roles", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * model_has_roles findUnique
   */
  export type model_has_rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    /**
     * Filter, which model_has_roles to fetch.
     */
    where: model_has_rolesWhereUniqueInput
  }

  /**
   * model_has_roles findUniqueOrThrow
   */
  export type model_has_rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    /**
     * Filter, which model_has_roles to fetch.
     */
    where: model_has_rolesWhereUniqueInput
  }

  /**
   * model_has_roles findFirst
   */
  export type model_has_rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    /**
     * Filter, which model_has_roles to fetch.
     */
    where?: model_has_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_has_roles to fetch.
     */
    orderBy?: model_has_rolesOrderByWithRelationInput | model_has_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for model_has_roles.
     */
    cursor?: model_has_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_has_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_has_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of model_has_roles.
     */
    distinct?: Model_has_rolesScalarFieldEnum | Model_has_rolesScalarFieldEnum[]
  }

  /**
   * model_has_roles findFirstOrThrow
   */
  export type model_has_rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    /**
     * Filter, which model_has_roles to fetch.
     */
    where?: model_has_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_has_roles to fetch.
     */
    orderBy?: model_has_rolesOrderByWithRelationInput | model_has_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for model_has_roles.
     */
    cursor?: model_has_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_has_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_has_roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of model_has_roles.
     */
    distinct?: Model_has_rolesScalarFieldEnum | Model_has_rolesScalarFieldEnum[]
  }

  /**
   * model_has_roles findMany
   */
  export type model_has_rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    /**
     * Filter, which model_has_roles to fetch.
     */
    where?: model_has_rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of model_has_roles to fetch.
     */
    orderBy?: model_has_rolesOrderByWithRelationInput | model_has_rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing model_has_roles.
     */
    cursor?: model_has_rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` model_has_roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` model_has_roles.
     */
    skip?: number
    distinct?: Model_has_rolesScalarFieldEnum | Model_has_rolesScalarFieldEnum[]
  }

  /**
   * model_has_roles create
   */
  export type model_has_rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a model_has_roles.
     */
    data: XOR<model_has_rolesCreateInput, model_has_rolesUncheckedCreateInput>
  }

  /**
   * model_has_roles createMany
   */
  export type model_has_rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many model_has_roles.
     */
    data: model_has_rolesCreateManyInput | model_has_rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * model_has_roles update
   */
  export type model_has_rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a model_has_roles.
     */
    data: XOR<model_has_rolesUpdateInput, model_has_rolesUncheckedUpdateInput>
    /**
     * Choose, which model_has_roles to update.
     */
    where: model_has_rolesWhereUniqueInput
  }

  /**
   * model_has_roles updateMany
   */
  export type model_has_rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update model_has_roles.
     */
    data: XOR<model_has_rolesUpdateManyMutationInput, model_has_rolesUncheckedUpdateManyInput>
    /**
     * Filter which model_has_roles to update
     */
    where?: model_has_rolesWhereInput
    /**
     * Limit how many model_has_roles to update.
     */
    limit?: number
  }

  /**
   * model_has_roles upsert
   */
  export type model_has_rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the model_has_roles to update in case it exists.
     */
    where: model_has_rolesWhereUniqueInput
    /**
     * In case the model_has_roles found by the `where` argument doesn't exist, create a new model_has_roles with this data.
     */
    create: XOR<model_has_rolesCreateInput, model_has_rolesUncheckedCreateInput>
    /**
     * In case the model_has_roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<model_has_rolesUpdateInput, model_has_rolesUncheckedUpdateInput>
  }

  /**
   * model_has_roles delete
   */
  export type model_has_rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    /**
     * Filter which model_has_roles to delete.
     */
    where: model_has_rolesWhereUniqueInput
  }

  /**
   * model_has_roles deleteMany
   */
  export type model_has_rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which model_has_roles to delete
     */
    where?: model_has_rolesWhereInput
    /**
     * Limit how many model_has_roles to delete.
     */
    limit?: number
  }

  /**
   * model_has_roles without action
   */
  export type model_has_rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
  }


  /**
   * Model password_reset_tokens
   */

  export type AggregatePassword_reset_tokens = {
    _count: Password_reset_tokensCountAggregateOutputType | null
    _min: Password_reset_tokensMinAggregateOutputType | null
    _max: Password_reset_tokensMaxAggregateOutputType | null
  }

  export type Password_reset_tokensMinAggregateOutputType = {
    email: string | null
    token: string | null
    created_at: Date | null
  }

  export type Password_reset_tokensMaxAggregateOutputType = {
    email: string | null
    token: string | null
    created_at: Date | null
  }

  export type Password_reset_tokensCountAggregateOutputType = {
    email: number
    token: number
    created_at: number
    _all: number
  }


  export type Password_reset_tokensMinAggregateInputType = {
    email?: true
    token?: true
    created_at?: true
  }

  export type Password_reset_tokensMaxAggregateInputType = {
    email?: true
    token?: true
    created_at?: true
  }

  export type Password_reset_tokensCountAggregateInputType = {
    email?: true
    token?: true
    created_at?: true
    _all?: true
  }

  export type Password_reset_tokensAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which password_reset_tokens to aggregate.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned password_reset_tokens
    **/
    _count?: true | Password_reset_tokensCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Password_reset_tokensMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Password_reset_tokensMaxAggregateInputType
  }

  export type GetPassword_reset_tokensAggregateType<T extends Password_reset_tokensAggregateArgs> = {
        [P in keyof T & keyof AggregatePassword_reset_tokens]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePassword_reset_tokens[P]>
      : GetScalarType<T[P], AggregatePassword_reset_tokens[P]>
  }




  export type password_reset_tokensGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: password_reset_tokensWhereInput
    orderBy?: password_reset_tokensOrderByWithAggregationInput | password_reset_tokensOrderByWithAggregationInput[]
    by: Password_reset_tokensScalarFieldEnum[] | Password_reset_tokensScalarFieldEnum
    having?: password_reset_tokensScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Password_reset_tokensCountAggregateInputType | true
    _min?: Password_reset_tokensMinAggregateInputType
    _max?: Password_reset_tokensMaxAggregateInputType
  }

  export type Password_reset_tokensGroupByOutputType = {
    email: string
    token: string
    created_at: Date | null
    _count: Password_reset_tokensCountAggregateOutputType | null
    _min: Password_reset_tokensMinAggregateOutputType | null
    _max: Password_reset_tokensMaxAggregateOutputType | null
  }

  type GetPassword_reset_tokensGroupByPayload<T extends password_reset_tokensGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Password_reset_tokensGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Password_reset_tokensGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Password_reset_tokensGroupByOutputType[P]>
            : GetScalarType<T[P], Password_reset_tokensGroupByOutputType[P]>
        }
      >
    >


  export type password_reset_tokensSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    token?: boolean
    created_at?: boolean
  }, ExtArgs["result"]["password_reset_tokens"]>



  export type password_reset_tokensSelectScalar = {
    email?: boolean
    token?: boolean
    created_at?: boolean
  }

  export type password_reset_tokensOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"email" | "token" | "created_at", ExtArgs["result"]["password_reset_tokens"]>

  export type $password_reset_tokensPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "password_reset_tokens"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      email: string
      token: string
      created_at: Date | null
    }, ExtArgs["result"]["password_reset_tokens"]>
    composites: {}
  }

  type password_reset_tokensGetPayload<S extends boolean | null | undefined | password_reset_tokensDefaultArgs> = $Result.GetResult<Prisma.$password_reset_tokensPayload, S>

  type password_reset_tokensCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<password_reset_tokensFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Password_reset_tokensCountAggregateInputType | true
    }

  export interface password_reset_tokensDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['password_reset_tokens'], meta: { name: 'password_reset_tokens' } }
    /**
     * Find zero or one Password_reset_tokens that matches the filter.
     * @param {password_reset_tokensFindUniqueArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends password_reset_tokensFindUniqueArgs>(args: SelectSubset<T, password_reset_tokensFindUniqueArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Password_reset_tokens that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {password_reset_tokensFindUniqueOrThrowArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends password_reset_tokensFindUniqueOrThrowArgs>(args: SelectSubset<T, password_reset_tokensFindUniqueOrThrowArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password_reset_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensFindFirstArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends password_reset_tokensFindFirstArgs>(args?: SelectSubset<T, password_reset_tokensFindFirstArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Password_reset_tokens that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensFindFirstOrThrowArgs} args - Arguments to find a Password_reset_tokens
     * @example
     * // Get one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends password_reset_tokensFindFirstOrThrowArgs>(args?: SelectSubset<T, password_reset_tokensFindFirstOrThrowArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Password_reset_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findMany()
     * 
     * // Get first 10 Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.findMany({ take: 10 })
     * 
     * // Only select the `email`
     * const password_reset_tokensWithEmailOnly = await prisma.password_reset_tokens.findMany({ select: { email: true } })
     * 
     */
    findMany<T extends password_reset_tokensFindManyArgs>(args?: SelectSubset<T, password_reset_tokensFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Password_reset_tokens.
     * @param {password_reset_tokensCreateArgs} args - Arguments to create a Password_reset_tokens.
     * @example
     * // Create one Password_reset_tokens
     * const Password_reset_tokens = await prisma.password_reset_tokens.create({
     *   data: {
     *     // ... data to create a Password_reset_tokens
     *   }
     * })
     * 
     */
    create<T extends password_reset_tokensCreateArgs>(args: SelectSubset<T, password_reset_tokensCreateArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Password_reset_tokens.
     * @param {password_reset_tokensCreateManyArgs} args - Arguments to create many Password_reset_tokens.
     * @example
     * // Create many Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends password_reset_tokensCreateManyArgs>(args?: SelectSubset<T, password_reset_tokensCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Password_reset_tokens.
     * @param {password_reset_tokensDeleteArgs} args - Arguments to delete one Password_reset_tokens.
     * @example
     * // Delete one Password_reset_tokens
     * const Password_reset_tokens = await prisma.password_reset_tokens.delete({
     *   where: {
     *     // ... filter to delete one Password_reset_tokens
     *   }
     * })
     * 
     */
    delete<T extends password_reset_tokensDeleteArgs>(args: SelectSubset<T, password_reset_tokensDeleteArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Password_reset_tokens.
     * @param {password_reset_tokensUpdateArgs} args - Arguments to update one Password_reset_tokens.
     * @example
     * // Update one Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends password_reset_tokensUpdateArgs>(args: SelectSubset<T, password_reset_tokensUpdateArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Password_reset_tokens.
     * @param {password_reset_tokensDeleteManyArgs} args - Arguments to filter Password_reset_tokens to delete.
     * @example
     * // Delete a few Password_reset_tokens
     * const { count } = await prisma.password_reset_tokens.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends password_reset_tokensDeleteManyArgs>(args?: SelectSubset<T, password_reset_tokensDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends password_reset_tokensUpdateManyArgs>(args: SelectSubset<T, password_reset_tokensUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Password_reset_tokens.
     * @param {password_reset_tokensUpsertArgs} args - Arguments to update or create a Password_reset_tokens.
     * @example
     * // Update or create a Password_reset_tokens
     * const password_reset_tokens = await prisma.password_reset_tokens.upsert({
     *   create: {
     *     // ... data to create a Password_reset_tokens
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Password_reset_tokens we want to update
     *   }
     * })
     */
    upsert<T extends password_reset_tokensUpsertArgs>(args: SelectSubset<T, password_reset_tokensUpsertArgs<ExtArgs>>): Prisma__password_reset_tokensClient<$Result.GetResult<Prisma.$password_reset_tokensPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensCountArgs} args - Arguments to filter Password_reset_tokens to count.
     * @example
     * // Count the number of Password_reset_tokens
     * const count = await prisma.password_reset_tokens.count({
     *   where: {
     *     // ... the filter for the Password_reset_tokens we want to count
     *   }
     * })
    **/
    count<T extends password_reset_tokensCountArgs>(
      args?: Subset<T, password_reset_tokensCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Password_reset_tokensCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Password_reset_tokensAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Password_reset_tokensAggregateArgs>(args: Subset<T, Password_reset_tokensAggregateArgs>): Prisma.PrismaPromise<GetPassword_reset_tokensAggregateType<T>>

    /**
     * Group by Password_reset_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {password_reset_tokensGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends password_reset_tokensGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: password_reset_tokensGroupByArgs['orderBy'] }
        : { orderBy?: password_reset_tokensGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, password_reset_tokensGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPassword_reset_tokensGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the password_reset_tokens model
   */
  readonly fields: password_reset_tokensFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for password_reset_tokens.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__password_reset_tokensClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the password_reset_tokens model
   */
  interface password_reset_tokensFieldRefs {
    readonly email: FieldRef<"password_reset_tokens", 'String'>
    readonly token: FieldRef<"password_reset_tokens", 'String'>
    readonly created_at: FieldRef<"password_reset_tokens", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * password_reset_tokens findUnique
   */
  export type password_reset_tokensFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens findUniqueOrThrow
   */
  export type password_reset_tokensFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens findFirst
   */
  export type password_reset_tokensFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for password_reset_tokens.
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of password_reset_tokens.
     */
    distinct?: Password_reset_tokensScalarFieldEnum | Password_reset_tokensScalarFieldEnum[]
  }

  /**
   * password_reset_tokens findFirstOrThrow
   */
  export type password_reset_tokensFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for password_reset_tokens.
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of password_reset_tokens.
     */
    distinct?: Password_reset_tokensScalarFieldEnum | Password_reset_tokensScalarFieldEnum[]
  }

  /**
   * password_reset_tokens findMany
   */
  export type password_reset_tokensFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Filter, which password_reset_tokens to fetch.
     */
    where?: password_reset_tokensWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of password_reset_tokens to fetch.
     */
    orderBy?: password_reset_tokensOrderByWithRelationInput | password_reset_tokensOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing password_reset_tokens.
     */
    cursor?: password_reset_tokensWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` password_reset_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` password_reset_tokens.
     */
    skip?: number
    distinct?: Password_reset_tokensScalarFieldEnum | Password_reset_tokensScalarFieldEnum[]
  }

  /**
   * password_reset_tokens create
   */
  export type password_reset_tokensCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * The data needed to create a password_reset_tokens.
     */
    data: XOR<password_reset_tokensCreateInput, password_reset_tokensUncheckedCreateInput>
  }

  /**
   * password_reset_tokens createMany
   */
  export type password_reset_tokensCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many password_reset_tokens.
     */
    data: password_reset_tokensCreateManyInput | password_reset_tokensCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * password_reset_tokens update
   */
  export type password_reset_tokensUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * The data needed to update a password_reset_tokens.
     */
    data: XOR<password_reset_tokensUpdateInput, password_reset_tokensUncheckedUpdateInput>
    /**
     * Choose, which password_reset_tokens to update.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens updateMany
   */
  export type password_reset_tokensUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update password_reset_tokens.
     */
    data: XOR<password_reset_tokensUpdateManyMutationInput, password_reset_tokensUncheckedUpdateManyInput>
    /**
     * Filter which password_reset_tokens to update
     */
    where?: password_reset_tokensWhereInput
    /**
     * Limit how many password_reset_tokens to update.
     */
    limit?: number
  }

  /**
   * password_reset_tokens upsert
   */
  export type password_reset_tokensUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * The filter to search for the password_reset_tokens to update in case it exists.
     */
    where: password_reset_tokensWhereUniqueInput
    /**
     * In case the password_reset_tokens found by the `where` argument doesn't exist, create a new password_reset_tokens with this data.
     */
    create: XOR<password_reset_tokensCreateInput, password_reset_tokensUncheckedCreateInput>
    /**
     * In case the password_reset_tokens was found with the provided `where` argument, update it with this data.
     */
    update: XOR<password_reset_tokensUpdateInput, password_reset_tokensUncheckedUpdateInput>
  }

  /**
   * password_reset_tokens delete
   */
  export type password_reset_tokensDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
    /**
     * Filter which password_reset_tokens to delete.
     */
    where: password_reset_tokensWhereUniqueInput
  }

  /**
   * password_reset_tokens deleteMany
   */
  export type password_reset_tokensDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which password_reset_tokens to delete
     */
    where?: password_reset_tokensWhereInput
    /**
     * Limit how many password_reset_tokens to delete.
     */
    limit?: number
  }

  /**
   * password_reset_tokens without action
   */
  export type password_reset_tokensDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the password_reset_tokens
     */
    select?: password_reset_tokensSelect<ExtArgs> | null
    /**
     * Omit specific fields from the password_reset_tokens
     */
    omit?: password_reset_tokensOmit<ExtArgs> | null
  }


  /**
   * Model permissions
   */

  export type AggregatePermissions = {
    _count: PermissionsCountAggregateOutputType | null
    _avg: PermissionsAvgAggregateOutputType | null
    _sum: PermissionsSumAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  export type PermissionsAvgAggregateOutputType = {
    id: number | null
  }

  export type PermissionsSumAggregateOutputType = {
    id: bigint | null
  }

  export type PermissionsMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    guard_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PermissionsMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    guard_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PermissionsCountAggregateOutputType = {
    id: number
    name: number
    guard_name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PermissionsAvgAggregateInputType = {
    id?: true
  }

  export type PermissionsSumAggregateInputType = {
    id?: true
  }

  export type PermissionsMinAggregateInputType = {
    id?: true
    name?: true
    guard_name?: true
    created_at?: true
    updated_at?: true
  }

  export type PermissionsMaxAggregateInputType = {
    id?: true
    name?: true
    guard_name?: true
    created_at?: true
    updated_at?: true
  }

  export type PermissionsCountAggregateInputType = {
    id?: true
    name?: true
    guard_name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PermissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to aggregate.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permissions
    **/
    _count?: true | PermissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PermissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PermissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionsMaxAggregateInputType
  }

  export type GetPermissionsAggregateType<T extends PermissionsAggregateArgs> = {
        [P in keyof T & keyof AggregatePermissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermissions[P]>
      : GetScalarType<T[P], AggregatePermissions[P]>
  }




  export type permissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: permissionsWhereInput
    orderBy?: permissionsOrderByWithAggregationInput | permissionsOrderByWithAggregationInput[]
    by: PermissionsScalarFieldEnum[] | PermissionsScalarFieldEnum
    having?: permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionsCountAggregateInputType | true
    _avg?: PermissionsAvgAggregateInputType
    _sum?: PermissionsSumAggregateInputType
    _min?: PermissionsMinAggregateInputType
    _max?: PermissionsMaxAggregateInputType
  }

  export type PermissionsGroupByOutputType = {
    id: bigint
    name: string
    guard_name: string
    created_at: Date | null
    updated_at: Date | null
    _count: PermissionsCountAggregateOutputType | null
    _avg: PermissionsAvgAggregateOutputType | null
    _sum: PermissionsSumAggregateOutputType | null
    _min: PermissionsMinAggregateOutputType | null
    _max: PermissionsMaxAggregateOutputType | null
  }

  type GetPermissionsGroupByPayload<T extends permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PermissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionsGroupByOutputType[P]>
        }
      >
    >


  export type permissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    guard_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    model_has_permissions?: boolean | permissions$model_has_permissionsArgs<ExtArgs>
    role_has_permissions?: boolean | permissions$role_has_permissionsArgs<ExtArgs>
    _count?: boolean | PermissionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["permissions"]>



  export type permissionsSelectScalar = {
    id?: boolean
    name?: boolean
    guard_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type permissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "guard_name" | "created_at" | "updated_at", ExtArgs["result"]["permissions"]>
  export type permissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model_has_permissions?: boolean | permissions$model_has_permissionsArgs<ExtArgs>
    role_has_permissions?: boolean | permissions$role_has_permissionsArgs<ExtArgs>
    _count?: boolean | PermissionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $permissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "permissions"
    objects: {
      model_has_permissions: Prisma.$model_has_permissionsPayload<ExtArgs>[]
      role_has_permissions: Prisma.$role_has_permissionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      guard_name: string
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["permissions"]>
    composites: {}
  }

  type permissionsGetPayload<S extends boolean | null | undefined | permissionsDefaultArgs> = $Result.GetResult<Prisma.$permissionsPayload, S>

  type permissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<permissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PermissionsCountAggregateInputType | true
    }

  export interface permissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['permissions'], meta: { name: 'permissions' } }
    /**
     * Find zero or one Permissions that matches the filter.
     * @param {permissionsFindUniqueArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends permissionsFindUniqueArgs>(args: SelectSubset<T, permissionsFindUniqueArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Permissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {permissionsFindUniqueOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends permissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, permissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindFirstArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends permissionsFindFirstArgs>(args?: SelectSubset<T, permissionsFindFirstArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindFirstOrThrowArgs} args - Arguments to find a Permissions
     * @example
     * // Get one Permissions
     * const permissions = await prisma.permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends permissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, permissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permissions.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permissions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionsWithIdOnly = await prisma.permissions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends permissionsFindManyArgs>(args?: SelectSubset<T, permissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Permissions.
     * @param {permissionsCreateArgs} args - Arguments to create a Permissions.
     * @example
     * // Create one Permissions
     * const Permissions = await prisma.permissions.create({
     *   data: {
     *     // ... data to create a Permissions
     *   }
     * })
     * 
     */
    create<T extends permissionsCreateArgs>(args: SelectSubset<T, permissionsCreateArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Permissions.
     * @param {permissionsCreateManyArgs} args - Arguments to create many Permissions.
     * @example
     * // Create many Permissions
     * const permissions = await prisma.permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends permissionsCreateManyArgs>(args?: SelectSubset<T, permissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Permissions.
     * @param {permissionsDeleteArgs} args - Arguments to delete one Permissions.
     * @example
     * // Delete one Permissions
     * const Permissions = await prisma.permissions.delete({
     *   where: {
     *     // ... filter to delete one Permissions
     *   }
     * })
     * 
     */
    delete<T extends permissionsDeleteArgs>(args: SelectSubset<T, permissionsDeleteArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Permissions.
     * @param {permissionsUpdateArgs} args - Arguments to update one Permissions.
     * @example
     * // Update one Permissions
     * const permissions = await prisma.permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends permissionsUpdateArgs>(args: SelectSubset<T, permissionsUpdateArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Permissions.
     * @param {permissionsDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends permissionsDeleteManyArgs>(args?: SelectSubset<T, permissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permissions = await prisma.permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends permissionsUpdateManyArgs>(args: SelectSubset<T, permissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permissions.
     * @param {permissionsUpsertArgs} args - Arguments to update or create a Permissions.
     * @example
     * // Update or create a Permissions
     * const permissions = await prisma.permissions.upsert({
     *   create: {
     *     // ... data to create a Permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permissions we want to update
     *   }
     * })
     */
    upsert<T extends permissionsUpsertArgs>(args: SelectSubset<T, permissionsUpsertArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permissions.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends permissionsCountArgs>(
      args?: Subset<T, permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionsAggregateArgs>(args: Subset<T, PermissionsAggregateArgs>): Prisma.PrismaPromise<GetPermissionsAggregateType<T>>

    /**
     * Group by Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: permissionsGroupByArgs['orderBy'] }
        : { orderBy?: permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the permissions model
   */
  readonly fields: permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__permissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    model_has_permissions<T extends permissions$model_has_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, permissions$model_has_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$model_has_permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    role_has_permissions<T extends permissions$role_has_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, permissions$role_has_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the permissions model
   */
  interface permissionsFieldRefs {
    readonly id: FieldRef<"permissions", 'BigInt'>
    readonly name: FieldRef<"permissions", 'String'>
    readonly guard_name: FieldRef<"permissions", 'String'>
    readonly created_at: FieldRef<"permissions", 'DateTime'>
    readonly updated_at: FieldRef<"permissions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * permissions findUnique
   */
  export type permissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions findUniqueOrThrow
   */
  export type permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions findFirst
   */
  export type permissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permissions findFirstOrThrow
   */
  export type permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permissions findMany
   */
  export type permissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: permissionsOrderByWithRelationInput | permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permissions.
     */
    cursor?: permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    distinct?: PermissionsScalarFieldEnum | PermissionsScalarFieldEnum[]
  }

  /**
   * permissions create
   */
  export type permissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a permissions.
     */
    data: XOR<permissionsCreateInput, permissionsUncheckedCreateInput>
  }

  /**
   * permissions createMany
   */
  export type permissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many permissions.
     */
    data: permissionsCreateManyInput | permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * permissions update
   */
  export type permissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a permissions.
     */
    data: XOR<permissionsUpdateInput, permissionsUncheckedUpdateInput>
    /**
     * Choose, which permissions to update.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions updateMany
   */
  export type permissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionsUpdateManyMutationInput, permissionsUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionsWhereInput
    /**
     * Limit how many permissions to update.
     */
    limit?: number
  }

  /**
   * permissions upsert
   */
  export type permissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the permissions to update in case it exists.
     */
    where: permissionsWhereUniqueInput
    /**
     * In case the permissions found by the `where` argument doesn't exist, create a new permissions with this data.
     */
    create: XOR<permissionsCreateInput, permissionsUncheckedCreateInput>
    /**
     * In case the permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissionsUpdateInput, permissionsUncheckedUpdateInput>
  }

  /**
   * permissions delete
   */
  export type permissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
    /**
     * Filter which permissions to delete.
     */
    where: permissionsWhereUniqueInput
  }

  /**
   * permissions deleteMany
   */
  export type permissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which permissions to delete
     */
    where?: permissionsWhereInput
    /**
     * Limit how many permissions to delete.
     */
    limit?: number
  }

  /**
   * permissions.model_has_permissions
   */
  export type permissions$model_has_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_permissions
     */
    select?: model_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_permissions
     */
    omit?: model_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_permissionsInclude<ExtArgs> | null
    where?: model_has_permissionsWhereInput
    orderBy?: model_has_permissionsOrderByWithRelationInput | model_has_permissionsOrderByWithRelationInput[]
    cursor?: model_has_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Model_has_permissionsScalarFieldEnum | Model_has_permissionsScalarFieldEnum[]
  }

  /**
   * permissions.role_has_permissions
   */
  export type permissions$role_has_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    where?: role_has_permissionsWhereInput
    orderBy?: role_has_permissionsOrderByWithRelationInput | role_has_permissionsOrderByWithRelationInput[]
    cursor?: role_has_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Role_has_permissionsScalarFieldEnum | Role_has_permissionsScalarFieldEnum[]
  }

  /**
   * permissions without action
   */
  export type permissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the permissions
     */
    select?: permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the permissions
     */
    omit?: permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: permissionsInclude<ExtArgs> | null
  }


  /**
   * Model role_has_permissions
   */

  export type AggregateRole_has_permissions = {
    _count: Role_has_permissionsCountAggregateOutputType | null
    _avg: Role_has_permissionsAvgAggregateOutputType | null
    _sum: Role_has_permissionsSumAggregateOutputType | null
    _min: Role_has_permissionsMinAggregateOutputType | null
    _max: Role_has_permissionsMaxAggregateOutputType | null
  }

  export type Role_has_permissionsAvgAggregateOutputType = {
    permission_id: number | null
    role_id: number | null
  }

  export type Role_has_permissionsSumAggregateOutputType = {
    permission_id: bigint | null
    role_id: bigint | null
  }

  export type Role_has_permissionsMinAggregateOutputType = {
    permission_id: bigint | null
    role_id: bigint | null
  }

  export type Role_has_permissionsMaxAggregateOutputType = {
    permission_id: bigint | null
    role_id: bigint | null
  }

  export type Role_has_permissionsCountAggregateOutputType = {
    permission_id: number
    role_id: number
    _all: number
  }


  export type Role_has_permissionsAvgAggregateInputType = {
    permission_id?: true
    role_id?: true
  }

  export type Role_has_permissionsSumAggregateInputType = {
    permission_id?: true
    role_id?: true
  }

  export type Role_has_permissionsMinAggregateInputType = {
    permission_id?: true
    role_id?: true
  }

  export type Role_has_permissionsMaxAggregateInputType = {
    permission_id?: true
    role_id?: true
  }

  export type Role_has_permissionsCountAggregateInputType = {
    permission_id?: true
    role_id?: true
    _all?: true
  }

  export type Role_has_permissionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role_has_permissions to aggregate.
     */
    where?: role_has_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_has_permissions to fetch.
     */
    orderBy?: role_has_permissionsOrderByWithRelationInput | role_has_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: role_has_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_has_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_has_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned role_has_permissions
    **/
    _count?: true | Role_has_permissionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Role_has_permissionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Role_has_permissionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Role_has_permissionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Role_has_permissionsMaxAggregateInputType
  }

  export type GetRole_has_permissionsAggregateType<T extends Role_has_permissionsAggregateArgs> = {
        [P in keyof T & keyof AggregateRole_has_permissions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRole_has_permissions[P]>
      : GetScalarType<T[P], AggregateRole_has_permissions[P]>
  }




  export type role_has_permissionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: role_has_permissionsWhereInput
    orderBy?: role_has_permissionsOrderByWithAggregationInput | role_has_permissionsOrderByWithAggregationInput[]
    by: Role_has_permissionsScalarFieldEnum[] | Role_has_permissionsScalarFieldEnum
    having?: role_has_permissionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Role_has_permissionsCountAggregateInputType | true
    _avg?: Role_has_permissionsAvgAggregateInputType
    _sum?: Role_has_permissionsSumAggregateInputType
    _min?: Role_has_permissionsMinAggregateInputType
    _max?: Role_has_permissionsMaxAggregateInputType
  }

  export type Role_has_permissionsGroupByOutputType = {
    permission_id: bigint
    role_id: bigint
    _count: Role_has_permissionsCountAggregateOutputType | null
    _avg: Role_has_permissionsAvgAggregateOutputType | null
    _sum: Role_has_permissionsSumAggregateOutputType | null
    _min: Role_has_permissionsMinAggregateOutputType | null
    _max: Role_has_permissionsMaxAggregateOutputType | null
  }

  type GetRole_has_permissionsGroupByPayload<T extends role_has_permissionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Role_has_permissionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Role_has_permissionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Role_has_permissionsGroupByOutputType[P]>
            : GetScalarType<T[P], Role_has_permissionsGroupByOutputType[P]>
        }
      >
    >


  export type role_has_permissionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    permission_id?: boolean
    role_id?: boolean
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["role_has_permissions"]>



  export type role_has_permissionsSelectScalar = {
    permission_id?: boolean
    role_id?: boolean
  }

  export type role_has_permissionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"permission_id" | "role_id", ExtArgs["result"]["role_has_permissions"]>
  export type role_has_permissionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    permissions?: boolean | permissionsDefaultArgs<ExtArgs>
    roles?: boolean | rolesDefaultArgs<ExtArgs>
  }

  export type $role_has_permissionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "role_has_permissions"
    objects: {
      permissions: Prisma.$permissionsPayload<ExtArgs>
      roles: Prisma.$rolesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      permission_id: bigint
      role_id: bigint
    }, ExtArgs["result"]["role_has_permissions"]>
    composites: {}
  }

  type role_has_permissionsGetPayload<S extends boolean | null | undefined | role_has_permissionsDefaultArgs> = $Result.GetResult<Prisma.$role_has_permissionsPayload, S>

  type role_has_permissionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<role_has_permissionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Role_has_permissionsCountAggregateInputType | true
    }

  export interface role_has_permissionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['role_has_permissions'], meta: { name: 'role_has_permissions' } }
    /**
     * Find zero or one Role_has_permissions that matches the filter.
     * @param {role_has_permissionsFindUniqueArgs} args - Arguments to find a Role_has_permissions
     * @example
     * // Get one Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends role_has_permissionsFindUniqueArgs>(args: SelectSubset<T, role_has_permissionsFindUniqueArgs<ExtArgs>>): Prisma__role_has_permissionsClient<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Role_has_permissions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {role_has_permissionsFindUniqueOrThrowArgs} args - Arguments to find a Role_has_permissions
     * @example
     * // Get one Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends role_has_permissionsFindUniqueOrThrowArgs>(args: SelectSubset<T, role_has_permissionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__role_has_permissionsClient<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role_has_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_has_permissionsFindFirstArgs} args - Arguments to find a Role_has_permissions
     * @example
     * // Get one Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends role_has_permissionsFindFirstArgs>(args?: SelectSubset<T, role_has_permissionsFindFirstArgs<ExtArgs>>): Prisma__role_has_permissionsClient<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Role_has_permissions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_has_permissionsFindFirstOrThrowArgs} args - Arguments to find a Role_has_permissions
     * @example
     * // Get one Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends role_has_permissionsFindFirstOrThrowArgs>(args?: SelectSubset<T, role_has_permissionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__role_has_permissionsClient<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Role_has_permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_has_permissionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.findMany()
     * 
     * // Get first 10 Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.findMany({ take: 10 })
     * 
     * // Only select the `permission_id`
     * const role_has_permissionsWithPermission_idOnly = await prisma.role_has_permissions.findMany({ select: { permission_id: true } })
     * 
     */
    findMany<T extends role_has_permissionsFindManyArgs>(args?: SelectSubset<T, role_has_permissionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Role_has_permissions.
     * @param {role_has_permissionsCreateArgs} args - Arguments to create a Role_has_permissions.
     * @example
     * // Create one Role_has_permissions
     * const Role_has_permissions = await prisma.role_has_permissions.create({
     *   data: {
     *     // ... data to create a Role_has_permissions
     *   }
     * })
     * 
     */
    create<T extends role_has_permissionsCreateArgs>(args: SelectSubset<T, role_has_permissionsCreateArgs<ExtArgs>>): Prisma__role_has_permissionsClient<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Role_has_permissions.
     * @param {role_has_permissionsCreateManyArgs} args - Arguments to create many Role_has_permissions.
     * @example
     * // Create many Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends role_has_permissionsCreateManyArgs>(args?: SelectSubset<T, role_has_permissionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Role_has_permissions.
     * @param {role_has_permissionsDeleteArgs} args - Arguments to delete one Role_has_permissions.
     * @example
     * // Delete one Role_has_permissions
     * const Role_has_permissions = await prisma.role_has_permissions.delete({
     *   where: {
     *     // ... filter to delete one Role_has_permissions
     *   }
     * })
     * 
     */
    delete<T extends role_has_permissionsDeleteArgs>(args: SelectSubset<T, role_has_permissionsDeleteArgs<ExtArgs>>): Prisma__role_has_permissionsClient<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Role_has_permissions.
     * @param {role_has_permissionsUpdateArgs} args - Arguments to update one Role_has_permissions.
     * @example
     * // Update one Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends role_has_permissionsUpdateArgs>(args: SelectSubset<T, role_has_permissionsUpdateArgs<ExtArgs>>): Prisma__role_has_permissionsClient<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Role_has_permissions.
     * @param {role_has_permissionsDeleteManyArgs} args - Arguments to filter Role_has_permissions to delete.
     * @example
     * // Delete a few Role_has_permissions
     * const { count } = await prisma.role_has_permissions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends role_has_permissionsDeleteManyArgs>(args?: SelectSubset<T, role_has_permissionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Role_has_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_has_permissionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends role_has_permissionsUpdateManyArgs>(args: SelectSubset<T, role_has_permissionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Role_has_permissions.
     * @param {role_has_permissionsUpsertArgs} args - Arguments to update or create a Role_has_permissions.
     * @example
     * // Update or create a Role_has_permissions
     * const role_has_permissions = await prisma.role_has_permissions.upsert({
     *   create: {
     *     // ... data to create a Role_has_permissions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Role_has_permissions we want to update
     *   }
     * })
     */
    upsert<T extends role_has_permissionsUpsertArgs>(args: SelectSubset<T, role_has_permissionsUpsertArgs<ExtArgs>>): Prisma__role_has_permissionsClient<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Role_has_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_has_permissionsCountArgs} args - Arguments to filter Role_has_permissions to count.
     * @example
     * // Count the number of Role_has_permissions
     * const count = await prisma.role_has_permissions.count({
     *   where: {
     *     // ... the filter for the Role_has_permissions we want to count
     *   }
     * })
    **/
    count<T extends role_has_permissionsCountArgs>(
      args?: Subset<T, role_has_permissionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Role_has_permissionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Role_has_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Role_has_permissionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Role_has_permissionsAggregateArgs>(args: Subset<T, Role_has_permissionsAggregateArgs>): Prisma.PrismaPromise<GetRole_has_permissionsAggregateType<T>>

    /**
     * Group by Role_has_permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {role_has_permissionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends role_has_permissionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: role_has_permissionsGroupByArgs['orderBy'] }
        : { orderBy?: role_has_permissionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, role_has_permissionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRole_has_permissionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the role_has_permissions model
   */
  readonly fields: role_has_permissionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for role_has_permissions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__role_has_permissionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    permissions<T extends permissionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, permissionsDefaultArgs<ExtArgs>>): Prisma__permissionsClient<$Result.GetResult<Prisma.$permissionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    roles<T extends rolesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, rolesDefaultArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the role_has_permissions model
   */
  interface role_has_permissionsFieldRefs {
    readonly permission_id: FieldRef<"role_has_permissions", 'BigInt'>
    readonly role_id: FieldRef<"role_has_permissions", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * role_has_permissions findUnique
   */
  export type role_has_permissionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_has_permissions to fetch.
     */
    where: role_has_permissionsWhereUniqueInput
  }

  /**
   * role_has_permissions findUniqueOrThrow
   */
  export type role_has_permissionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_has_permissions to fetch.
     */
    where: role_has_permissionsWhereUniqueInput
  }

  /**
   * role_has_permissions findFirst
   */
  export type role_has_permissionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_has_permissions to fetch.
     */
    where?: role_has_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_has_permissions to fetch.
     */
    orderBy?: role_has_permissionsOrderByWithRelationInput | role_has_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for role_has_permissions.
     */
    cursor?: role_has_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_has_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_has_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of role_has_permissions.
     */
    distinct?: Role_has_permissionsScalarFieldEnum | Role_has_permissionsScalarFieldEnum[]
  }

  /**
   * role_has_permissions findFirstOrThrow
   */
  export type role_has_permissionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_has_permissions to fetch.
     */
    where?: role_has_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_has_permissions to fetch.
     */
    orderBy?: role_has_permissionsOrderByWithRelationInput | role_has_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for role_has_permissions.
     */
    cursor?: role_has_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_has_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_has_permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of role_has_permissions.
     */
    distinct?: Role_has_permissionsScalarFieldEnum | Role_has_permissionsScalarFieldEnum[]
  }

  /**
   * role_has_permissions findMany
   */
  export type role_has_permissionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter, which role_has_permissions to fetch.
     */
    where?: role_has_permissionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of role_has_permissions to fetch.
     */
    orderBy?: role_has_permissionsOrderByWithRelationInput | role_has_permissionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing role_has_permissions.
     */
    cursor?: role_has_permissionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` role_has_permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` role_has_permissions.
     */
    skip?: number
    distinct?: Role_has_permissionsScalarFieldEnum | Role_has_permissionsScalarFieldEnum[]
  }

  /**
   * role_has_permissions create
   */
  export type role_has_permissionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to create a role_has_permissions.
     */
    data: XOR<role_has_permissionsCreateInput, role_has_permissionsUncheckedCreateInput>
  }

  /**
   * role_has_permissions createMany
   */
  export type role_has_permissionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many role_has_permissions.
     */
    data: role_has_permissionsCreateManyInput | role_has_permissionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * role_has_permissions update
   */
  export type role_has_permissionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    /**
     * The data needed to update a role_has_permissions.
     */
    data: XOR<role_has_permissionsUpdateInput, role_has_permissionsUncheckedUpdateInput>
    /**
     * Choose, which role_has_permissions to update.
     */
    where: role_has_permissionsWhereUniqueInput
  }

  /**
   * role_has_permissions updateMany
   */
  export type role_has_permissionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update role_has_permissions.
     */
    data: XOR<role_has_permissionsUpdateManyMutationInput, role_has_permissionsUncheckedUpdateManyInput>
    /**
     * Filter which role_has_permissions to update
     */
    where?: role_has_permissionsWhereInput
    /**
     * Limit how many role_has_permissions to update.
     */
    limit?: number
  }

  /**
   * role_has_permissions upsert
   */
  export type role_has_permissionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    /**
     * The filter to search for the role_has_permissions to update in case it exists.
     */
    where: role_has_permissionsWhereUniqueInput
    /**
     * In case the role_has_permissions found by the `where` argument doesn't exist, create a new role_has_permissions with this data.
     */
    create: XOR<role_has_permissionsCreateInput, role_has_permissionsUncheckedCreateInput>
    /**
     * In case the role_has_permissions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<role_has_permissionsUpdateInput, role_has_permissionsUncheckedUpdateInput>
  }

  /**
   * role_has_permissions delete
   */
  export type role_has_permissionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    /**
     * Filter which role_has_permissions to delete.
     */
    where: role_has_permissionsWhereUniqueInput
  }

  /**
   * role_has_permissions deleteMany
   */
  export type role_has_permissionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which role_has_permissions to delete
     */
    where?: role_has_permissionsWhereInput
    /**
     * Limit how many role_has_permissions to delete.
     */
    limit?: number
  }

  /**
   * role_has_permissions without action
   */
  export type role_has_permissionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
  }


  /**
   * Model roles
   */

  export type AggregateRoles = {
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  export type RolesAvgAggregateOutputType = {
    id: number | null
  }

  export type RolesSumAggregateOutputType = {
    id: bigint | null
  }

  export type RolesMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    guard_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RolesMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    guard_name: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RolesCountAggregateOutputType = {
    id: number
    name: number
    guard_name: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type RolesAvgAggregateInputType = {
    id?: true
  }

  export type RolesSumAggregateInputType = {
    id?: true
  }

  export type RolesMinAggregateInputType = {
    id?: true
    name?: true
    guard_name?: true
    created_at?: true
    updated_at?: true
  }

  export type RolesMaxAggregateInputType = {
    id?: true
    name?: true
    guard_name?: true
    created_at?: true
    updated_at?: true
  }

  export type RolesCountAggregateInputType = {
    id?: true
    name?: true
    guard_name?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type RolesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to aggregate.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned roles
    **/
    _count?: true | RolesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RolesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RolesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RolesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RolesMaxAggregateInputType
  }

  export type GetRolesAggregateType<T extends RolesAggregateArgs> = {
        [P in keyof T & keyof AggregateRoles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoles[P]>
      : GetScalarType<T[P], AggregateRoles[P]>
  }




  export type rolesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: rolesWhereInput
    orderBy?: rolesOrderByWithAggregationInput | rolesOrderByWithAggregationInput[]
    by: RolesScalarFieldEnum[] | RolesScalarFieldEnum
    having?: rolesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RolesCountAggregateInputType | true
    _avg?: RolesAvgAggregateInputType
    _sum?: RolesSumAggregateInputType
    _min?: RolesMinAggregateInputType
    _max?: RolesMaxAggregateInputType
  }

  export type RolesGroupByOutputType = {
    id: bigint
    name: string
    guard_name: string
    created_at: Date | null
    updated_at: Date | null
    _count: RolesCountAggregateOutputType | null
    _avg: RolesAvgAggregateOutputType | null
    _sum: RolesSumAggregateOutputType | null
    _min: RolesMinAggregateOutputType | null
    _max: RolesMaxAggregateOutputType | null
  }

  type GetRolesGroupByPayload<T extends rolesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RolesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RolesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RolesGroupByOutputType[P]>
            : GetScalarType<T[P], RolesGroupByOutputType[P]>
        }
      >
    >


  export type rolesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    guard_name?: boolean
    created_at?: boolean
    updated_at?: boolean
    model_has_roles?: boolean | roles$model_has_rolesArgs<ExtArgs>
    role_has_permissions?: boolean | roles$role_has_permissionsArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roles"]>



  export type rolesSelectScalar = {
    id?: boolean
    name?: boolean
    guard_name?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type rolesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "guard_name" | "created_at" | "updated_at", ExtArgs["result"]["roles"]>
  export type rolesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model_has_roles?: boolean | roles$model_has_rolesArgs<ExtArgs>
    role_has_permissions?: boolean | roles$role_has_permissionsArgs<ExtArgs>
    _count?: boolean | RolesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $rolesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "roles"
    objects: {
      model_has_roles: Prisma.$model_has_rolesPayload<ExtArgs>[]
      role_has_permissions: Prisma.$role_has_permissionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      guard_name: string
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["roles"]>
    composites: {}
  }

  type rolesGetPayload<S extends boolean | null | undefined | rolesDefaultArgs> = $Result.GetResult<Prisma.$rolesPayload, S>

  type rolesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<rolesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RolesCountAggregateInputType | true
    }

  export interface rolesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['roles'], meta: { name: 'roles' } }
    /**
     * Find zero or one Roles that matches the filter.
     * @param {rolesFindUniqueArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends rolesFindUniqueArgs>(args: SelectSubset<T, rolesFindUniqueArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Roles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {rolesFindUniqueOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends rolesFindUniqueOrThrowArgs>(args: SelectSubset<T, rolesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends rolesFindFirstArgs>(args?: SelectSubset<T, rolesFindFirstArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Roles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindFirstOrThrowArgs} args - Arguments to find a Roles
     * @example
     * // Get one Roles
     * const roles = await prisma.roles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends rolesFindFirstOrThrowArgs>(args?: SelectSubset<T, rolesFindFirstOrThrowArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Roles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roles
     * const roles = await prisma.roles.findMany()
     * 
     * // Get first 10 Roles
     * const roles = await prisma.roles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const rolesWithIdOnly = await prisma.roles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends rolesFindManyArgs>(args?: SelectSubset<T, rolesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Roles.
     * @param {rolesCreateArgs} args - Arguments to create a Roles.
     * @example
     * // Create one Roles
     * const Roles = await prisma.roles.create({
     *   data: {
     *     // ... data to create a Roles
     *   }
     * })
     * 
     */
    create<T extends rolesCreateArgs>(args: SelectSubset<T, rolesCreateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Roles.
     * @param {rolesCreateManyArgs} args - Arguments to create many Roles.
     * @example
     * // Create many Roles
     * const roles = await prisma.roles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends rolesCreateManyArgs>(args?: SelectSubset<T, rolesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roles.
     * @param {rolesDeleteArgs} args - Arguments to delete one Roles.
     * @example
     * // Delete one Roles
     * const Roles = await prisma.roles.delete({
     *   where: {
     *     // ... filter to delete one Roles
     *   }
     * })
     * 
     */
    delete<T extends rolesDeleteArgs>(args: SelectSubset<T, rolesDeleteArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Roles.
     * @param {rolesUpdateArgs} args - Arguments to update one Roles.
     * @example
     * // Update one Roles
     * const roles = await prisma.roles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends rolesUpdateArgs>(args: SelectSubset<T, rolesUpdateArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Roles.
     * @param {rolesDeleteManyArgs} args - Arguments to filter Roles to delete.
     * @example
     * // Delete a few Roles
     * const { count } = await prisma.roles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends rolesDeleteManyArgs>(args?: SelectSubset<T, rolesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roles
     * const roles = await prisma.roles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends rolesUpdateManyArgs>(args: SelectSubset<T, rolesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roles.
     * @param {rolesUpsertArgs} args - Arguments to update or create a Roles.
     * @example
     * // Update or create a Roles
     * const roles = await prisma.roles.upsert({
     *   create: {
     *     // ... data to create a Roles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roles we want to update
     *   }
     * })
     */
    upsert<T extends rolesUpsertArgs>(args: SelectSubset<T, rolesUpsertArgs<ExtArgs>>): Prisma__rolesClient<$Result.GetResult<Prisma.$rolesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesCountArgs} args - Arguments to filter Roles to count.
     * @example
     * // Count the number of Roles
     * const count = await prisma.roles.count({
     *   where: {
     *     // ... the filter for the Roles we want to count
     *   }
     * })
    **/
    count<T extends rolesCountArgs>(
      args?: Subset<T, rolesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RolesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RolesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RolesAggregateArgs>(args: Subset<T, RolesAggregateArgs>): Prisma.PrismaPromise<GetRolesAggregateType<T>>

    /**
     * Group by Roles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {rolesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends rolesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: rolesGroupByArgs['orderBy'] }
        : { orderBy?: rolesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, rolesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRolesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the roles model
   */
  readonly fields: rolesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for roles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__rolesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    model_has_roles<T extends roles$model_has_rolesArgs<ExtArgs> = {}>(args?: Subset<T, roles$model_has_rolesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$model_has_rolesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    role_has_permissions<T extends roles$role_has_permissionsArgs<ExtArgs> = {}>(args?: Subset<T, roles$role_has_permissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$role_has_permissionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the roles model
   */
  interface rolesFieldRefs {
    readonly id: FieldRef<"roles", 'BigInt'>
    readonly name: FieldRef<"roles", 'String'>
    readonly guard_name: FieldRef<"roles", 'String'>
    readonly created_at: FieldRef<"roles", 'DateTime'>
    readonly updated_at: FieldRef<"roles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * roles findUnique
   */
  export type rolesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findUniqueOrThrow
   */
  export type rolesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles findFirst
   */
  export type rolesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findFirstOrThrow
   */
  export type rolesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of roles.
     */
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles findMany
   */
  export type rolesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter, which roles to fetch.
     */
    where?: rolesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of roles to fetch.
     */
    orderBy?: rolesOrderByWithRelationInput | rolesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing roles.
     */
    cursor?: rolesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` roles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` roles.
     */
    skip?: number
    distinct?: RolesScalarFieldEnum | RolesScalarFieldEnum[]
  }

  /**
   * roles create
   */
  export type rolesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to create a roles.
     */
    data: XOR<rolesCreateInput, rolesUncheckedCreateInput>
  }

  /**
   * roles createMany
   */
  export type rolesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many roles.
     */
    data: rolesCreateManyInput | rolesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * roles update
   */
  export type rolesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The data needed to update a roles.
     */
    data: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
    /**
     * Choose, which roles to update.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles updateMany
   */
  export type rolesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update roles.
     */
    data: XOR<rolesUpdateManyMutationInput, rolesUncheckedUpdateManyInput>
    /**
     * Filter which roles to update
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to update.
     */
    limit?: number
  }

  /**
   * roles upsert
   */
  export type rolesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * The filter to search for the roles to update in case it exists.
     */
    where: rolesWhereUniqueInput
    /**
     * In case the roles found by the `where` argument doesn't exist, create a new roles with this data.
     */
    create: XOR<rolesCreateInput, rolesUncheckedCreateInput>
    /**
     * In case the roles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<rolesUpdateInput, rolesUncheckedUpdateInput>
  }

  /**
   * roles delete
   */
  export type rolesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
    /**
     * Filter which roles to delete.
     */
    where: rolesWhereUniqueInput
  }

  /**
   * roles deleteMany
   */
  export type rolesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which roles to delete
     */
    where?: rolesWhereInput
    /**
     * Limit how many roles to delete.
     */
    limit?: number
  }

  /**
   * roles.model_has_roles
   */
  export type roles$model_has_rolesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the model_has_roles
     */
    select?: model_has_rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the model_has_roles
     */
    omit?: model_has_rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: model_has_rolesInclude<ExtArgs> | null
    where?: model_has_rolesWhereInput
    orderBy?: model_has_rolesOrderByWithRelationInput | model_has_rolesOrderByWithRelationInput[]
    cursor?: model_has_rolesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Model_has_rolesScalarFieldEnum | Model_has_rolesScalarFieldEnum[]
  }

  /**
   * roles.role_has_permissions
   */
  export type roles$role_has_permissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the role_has_permissions
     */
    select?: role_has_permissionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the role_has_permissions
     */
    omit?: role_has_permissionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: role_has_permissionsInclude<ExtArgs> | null
    where?: role_has_permissionsWhereInput
    orderBy?: role_has_permissionsOrderByWithRelationInput | role_has_permissionsOrderByWithRelationInput[]
    cursor?: role_has_permissionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Role_has_permissionsScalarFieldEnum | Role_has_permissionsScalarFieldEnum[]
  }

  /**
   * roles without action
   */
  export type rolesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the roles
     */
    select?: rolesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the roles
     */
    omit?: rolesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: rolesInclude<ExtArgs> | null
  }


  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type UsersSumAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
  }

  export type UsersMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    email: string | null
    email_verified_at: Date | null
    password: string | null
    company_id: bigint | null
    remember_token: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    email: string | null
    email_verified_at: Date | null
    password: string | null
    company_id: bigint | null
    remember_token: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    email: number
    email_verified_at: number
    password: number
    company_id: number
    remember_token: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UsersAvgAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type UsersSumAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    email_verified_at?: true
    password?: true
    company_id?: true
    remember_token?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    email_verified_at?: true
    password?: true
    company_id?: true
    remember_token?: true
    created_at?: true
    updated_at?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    email_verified_at?: true
    password?: true
    company_id?: true
    remember_token?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _avg?: UsersAvgAggregateInputType
    _sum?: UsersSumAggregateInputType
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: bigint
    name: string
    email: string
    email_verified_at: Date | null
    password: string
    company_id: bigint | null
    remember_token: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: UsersCountAggregateOutputType | null
    _avg: UsersAvgAggregateOutputType | null
    _sum: UsersSumAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    email_verified_at?: boolean
    password?: boolean
    company_id?: boolean
    remember_token?: boolean
    created_at?: boolean
    updated_at?: boolean
    companies?: boolean | users$companiesArgs<ExtArgs>
  }, ExtArgs["result"]["users"]>



  export type usersSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    email_verified_at?: boolean
    password?: boolean
    company_id?: boolean
    remember_token?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "email_verified_at" | "password" | "company_id" | "remember_token" | "created_at" | "updated_at", ExtArgs["result"]["users"]>
  export type usersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | users$companiesArgs<ExtArgs>
  }

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      email: string
      email_verified_at: Date | null
      password: string
      company_id: bigint | null
      remember_token: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends users$companiesArgs<ExtArgs> = {}>(args?: Subset<T, users$companiesArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'BigInt'>
    readonly name: FieldRef<"users", 'String'>
    readonly email: FieldRef<"users", 'String'>
    readonly email_verified_at: FieldRef<"users", 'DateTime'>
    readonly password: FieldRef<"users", 'String'>
    readonly company_id: FieldRef<"users", 'BigInt'>
    readonly remember_token: FieldRef<"users", 'String'>
    readonly created_at: FieldRef<"users", 'DateTime'>
    readonly updated_at: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users.companies
   */
  export type users$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    where?: companiesWhereInput
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
  }


  /**
   * Model cache
   */

  export type AggregateCache = {
    _count: CacheCountAggregateOutputType | null
    _avg: CacheAvgAggregateOutputType | null
    _sum: CacheSumAggregateOutputType | null
    _min: CacheMinAggregateOutputType | null
    _max: CacheMaxAggregateOutputType | null
  }

  export type CacheAvgAggregateOutputType = {
    expiration: number | null
  }

  export type CacheSumAggregateOutputType = {
    expiration: number | null
  }

  export type CacheMinAggregateOutputType = {
    key: string | null
    value: string | null
    expiration: number | null
  }

  export type CacheMaxAggregateOutputType = {
    key: string | null
    value: string | null
    expiration: number | null
  }

  export type CacheCountAggregateOutputType = {
    key: number
    value: number
    expiration: number
    _all: number
  }


  export type CacheAvgAggregateInputType = {
    expiration?: true
  }

  export type CacheSumAggregateInputType = {
    expiration?: true
  }

  export type CacheMinAggregateInputType = {
    key?: true
    value?: true
    expiration?: true
  }

  export type CacheMaxAggregateInputType = {
    key?: true
    value?: true
    expiration?: true
  }

  export type CacheCountAggregateInputType = {
    key?: true
    value?: true
    expiration?: true
    _all?: true
  }

  export type CacheAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cache to aggregate.
     */
    where?: cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caches to fetch.
     */
    orderBy?: cacheOrderByWithRelationInput | cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned caches
    **/
    _count?: true | CacheCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CacheAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CacheSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CacheMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CacheMaxAggregateInputType
  }

  export type GetCacheAggregateType<T extends CacheAggregateArgs> = {
        [P in keyof T & keyof AggregateCache]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCache[P]>
      : GetScalarType<T[P], AggregateCache[P]>
  }




  export type cacheGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cacheWhereInput
    orderBy?: cacheOrderByWithAggregationInput | cacheOrderByWithAggregationInput[]
    by: CacheScalarFieldEnum[] | CacheScalarFieldEnum
    having?: cacheScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CacheCountAggregateInputType | true
    _avg?: CacheAvgAggregateInputType
    _sum?: CacheSumAggregateInputType
    _min?: CacheMinAggregateInputType
    _max?: CacheMaxAggregateInputType
  }

  export type CacheGroupByOutputType = {
    key: string
    value: string
    expiration: number
    _count: CacheCountAggregateOutputType | null
    _avg: CacheAvgAggregateOutputType | null
    _sum: CacheSumAggregateOutputType | null
    _min: CacheMinAggregateOutputType | null
    _max: CacheMaxAggregateOutputType | null
  }

  type GetCacheGroupByPayload<T extends cacheGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CacheGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CacheGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CacheGroupByOutputType[P]>
            : GetScalarType<T[P], CacheGroupByOutputType[P]>
        }
      >
    >


  export type cacheSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    value?: boolean
    expiration?: boolean
  }, ExtArgs["result"]["cache"]>



  export type cacheSelectScalar = {
    key?: boolean
    value?: boolean
    expiration?: boolean
  }

  export type cacheOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "value" | "expiration", ExtArgs["result"]["cache"]>

  export type $cachePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cache"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      value: string
      expiration: number
    }, ExtArgs["result"]["cache"]>
    composites: {}
  }

  type cacheGetPayload<S extends boolean | null | undefined | cacheDefaultArgs> = $Result.GetResult<Prisma.$cachePayload, S>

  type cacheCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cacheFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CacheCountAggregateInputType | true
    }

  export interface cacheDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cache'], meta: { name: 'cache' } }
    /**
     * Find zero or one Cache that matches the filter.
     * @param {cacheFindUniqueArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cacheFindUniqueArgs>(args: SelectSubset<T, cacheFindUniqueArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cache that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cacheFindUniqueOrThrowArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cacheFindUniqueOrThrowArgs>(args: SelectSubset<T, cacheFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheFindFirstArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cacheFindFirstArgs>(args?: SelectSubset<T, cacheFindFirstArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheFindFirstOrThrowArgs} args - Arguments to find a Cache
     * @example
     * // Get one Cache
     * const cache = await prisma.cache.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cacheFindFirstOrThrowArgs>(args?: SelectSubset<T, cacheFindFirstOrThrowArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Caches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Caches
     * const caches = await prisma.cache.findMany()
     * 
     * // Get first 10 Caches
     * const caches = await prisma.cache.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const cacheWithKeyOnly = await prisma.cache.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends cacheFindManyArgs>(args?: SelectSubset<T, cacheFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cache.
     * @param {cacheCreateArgs} args - Arguments to create a Cache.
     * @example
     * // Create one Cache
     * const Cache = await prisma.cache.create({
     *   data: {
     *     // ... data to create a Cache
     *   }
     * })
     * 
     */
    create<T extends cacheCreateArgs>(args: SelectSubset<T, cacheCreateArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Caches.
     * @param {cacheCreateManyArgs} args - Arguments to create many Caches.
     * @example
     * // Create many Caches
     * const cache = await prisma.cache.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cacheCreateManyArgs>(args?: SelectSubset<T, cacheCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cache.
     * @param {cacheDeleteArgs} args - Arguments to delete one Cache.
     * @example
     * // Delete one Cache
     * const Cache = await prisma.cache.delete({
     *   where: {
     *     // ... filter to delete one Cache
     *   }
     * })
     * 
     */
    delete<T extends cacheDeleteArgs>(args: SelectSubset<T, cacheDeleteArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cache.
     * @param {cacheUpdateArgs} args - Arguments to update one Cache.
     * @example
     * // Update one Cache
     * const cache = await prisma.cache.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cacheUpdateArgs>(args: SelectSubset<T, cacheUpdateArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Caches.
     * @param {cacheDeleteManyArgs} args - Arguments to filter Caches to delete.
     * @example
     * // Delete a few Caches
     * const { count } = await prisma.cache.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cacheDeleteManyArgs>(args?: SelectSubset<T, cacheDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Caches
     * const cache = await prisma.cache.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cacheUpdateManyArgs>(args: SelectSubset<T, cacheUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cache.
     * @param {cacheUpsertArgs} args - Arguments to update or create a Cache.
     * @example
     * // Update or create a Cache
     * const cache = await prisma.cache.upsert({
     *   create: {
     *     // ... data to create a Cache
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cache we want to update
     *   }
     * })
     */
    upsert<T extends cacheUpsertArgs>(args: SelectSubset<T, cacheUpsertArgs<ExtArgs>>): Prisma__cacheClient<$Result.GetResult<Prisma.$cachePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Caches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheCountArgs} args - Arguments to filter Caches to count.
     * @example
     * // Count the number of Caches
     * const count = await prisma.cache.count({
     *   where: {
     *     // ... the filter for the Caches we want to count
     *   }
     * })
    **/
    count<T extends cacheCountArgs>(
      args?: Subset<T, cacheCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CacheCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CacheAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CacheAggregateArgs>(args: Subset<T, CacheAggregateArgs>): Prisma.PrismaPromise<GetCacheAggregateType<T>>

    /**
     * Group by Cache.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cacheGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cacheGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cacheGroupByArgs['orderBy'] }
        : { orderBy?: cacheGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cacheGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCacheGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cache model
   */
  readonly fields: cacheFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cache.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cacheClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cache model
   */
  interface cacheFieldRefs {
    readonly key: FieldRef<"cache", 'String'>
    readonly value: FieldRef<"cache", 'String'>
    readonly expiration: FieldRef<"cache", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * cache findUnique
   */
  export type cacheFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which cache to fetch.
     */
    where: cacheWhereUniqueInput
  }

  /**
   * cache findUniqueOrThrow
   */
  export type cacheFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which cache to fetch.
     */
    where: cacheWhereUniqueInput
  }

  /**
   * cache findFirst
   */
  export type cacheFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which cache to fetch.
     */
    where?: cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caches to fetch.
     */
    orderBy?: cacheOrderByWithRelationInput | cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caches.
     */
    cursor?: cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caches.
     */
    distinct?: CacheScalarFieldEnum | CacheScalarFieldEnum[]
  }

  /**
   * cache findFirstOrThrow
   */
  export type cacheFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which cache to fetch.
     */
    where?: cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caches to fetch.
     */
    orderBy?: cacheOrderByWithRelationInput | cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for caches.
     */
    cursor?: cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of caches.
     */
    distinct?: CacheScalarFieldEnum | CacheScalarFieldEnum[]
  }

  /**
   * cache findMany
   */
  export type cacheFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter, which caches to fetch.
     */
    where?: cacheWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of caches to fetch.
     */
    orderBy?: cacheOrderByWithRelationInput | cacheOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing caches.
     */
    cursor?: cacheWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` caches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` caches.
     */
    skip?: number
    distinct?: CacheScalarFieldEnum | CacheScalarFieldEnum[]
  }

  /**
   * cache create
   */
  export type cacheCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * The data needed to create a cache.
     */
    data: XOR<cacheCreateInput, cacheUncheckedCreateInput>
  }

  /**
   * cache createMany
   */
  export type cacheCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many caches.
     */
    data: cacheCreateManyInput | cacheCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cache update
   */
  export type cacheUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * The data needed to update a cache.
     */
    data: XOR<cacheUpdateInput, cacheUncheckedUpdateInput>
    /**
     * Choose, which cache to update.
     */
    where: cacheWhereUniqueInput
  }

  /**
   * cache updateMany
   */
  export type cacheUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update caches.
     */
    data: XOR<cacheUpdateManyMutationInput, cacheUncheckedUpdateManyInput>
    /**
     * Filter which caches to update
     */
    where?: cacheWhereInput
    /**
     * Limit how many caches to update.
     */
    limit?: number
  }

  /**
   * cache upsert
   */
  export type cacheUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * The filter to search for the cache to update in case it exists.
     */
    where: cacheWhereUniqueInput
    /**
     * In case the cache found by the `where` argument doesn't exist, create a new cache with this data.
     */
    create: XOR<cacheCreateInput, cacheUncheckedCreateInput>
    /**
     * In case the cache was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cacheUpdateInput, cacheUncheckedUpdateInput>
  }

  /**
   * cache delete
   */
  export type cacheDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
    /**
     * Filter which cache to delete.
     */
    where: cacheWhereUniqueInput
  }

  /**
   * cache deleteMany
   */
  export type cacheDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which caches to delete
     */
    where?: cacheWhereInput
    /**
     * Limit how many caches to delete.
     */
    limit?: number
  }

  /**
   * cache without action
   */
  export type cacheDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache
     */
    select?: cacheSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache
     */
    omit?: cacheOmit<ExtArgs> | null
  }


  /**
   * Model cache_locks
   */

  export type AggregateCache_locks = {
    _count: Cache_locksCountAggregateOutputType | null
    _avg: Cache_locksAvgAggregateOutputType | null
    _sum: Cache_locksSumAggregateOutputType | null
    _min: Cache_locksMinAggregateOutputType | null
    _max: Cache_locksMaxAggregateOutputType | null
  }

  export type Cache_locksAvgAggregateOutputType = {
    expiration: number | null
  }

  export type Cache_locksSumAggregateOutputType = {
    expiration: number | null
  }

  export type Cache_locksMinAggregateOutputType = {
    key: string | null
    owner: string | null
    expiration: number | null
  }

  export type Cache_locksMaxAggregateOutputType = {
    key: string | null
    owner: string | null
    expiration: number | null
  }

  export type Cache_locksCountAggregateOutputType = {
    key: number
    owner: number
    expiration: number
    _all: number
  }


  export type Cache_locksAvgAggregateInputType = {
    expiration?: true
  }

  export type Cache_locksSumAggregateInputType = {
    expiration?: true
  }

  export type Cache_locksMinAggregateInputType = {
    key?: true
    owner?: true
    expiration?: true
  }

  export type Cache_locksMaxAggregateInputType = {
    key?: true
    owner?: true
    expiration?: true
  }

  export type Cache_locksCountAggregateInputType = {
    key?: true
    owner?: true
    expiration?: true
    _all?: true
  }

  export type Cache_locksAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cache_locks to aggregate.
     */
    where?: cache_locksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_locks to fetch.
     */
    orderBy?: cache_locksOrderByWithRelationInput | cache_locksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: cache_locksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_locks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_locks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cache_locks
    **/
    _count?: true | Cache_locksCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Cache_locksAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Cache_locksSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Cache_locksMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Cache_locksMaxAggregateInputType
  }

  export type GetCache_locksAggregateType<T extends Cache_locksAggregateArgs> = {
        [P in keyof T & keyof AggregateCache_locks]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCache_locks[P]>
      : GetScalarType<T[P], AggregateCache_locks[P]>
  }




  export type cache_locksGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: cache_locksWhereInput
    orderBy?: cache_locksOrderByWithAggregationInput | cache_locksOrderByWithAggregationInput[]
    by: Cache_locksScalarFieldEnum[] | Cache_locksScalarFieldEnum
    having?: cache_locksScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Cache_locksCountAggregateInputType | true
    _avg?: Cache_locksAvgAggregateInputType
    _sum?: Cache_locksSumAggregateInputType
    _min?: Cache_locksMinAggregateInputType
    _max?: Cache_locksMaxAggregateInputType
  }

  export type Cache_locksGroupByOutputType = {
    key: string
    owner: string
    expiration: number
    _count: Cache_locksCountAggregateOutputType | null
    _avg: Cache_locksAvgAggregateOutputType | null
    _sum: Cache_locksSumAggregateOutputType | null
    _min: Cache_locksMinAggregateOutputType | null
    _max: Cache_locksMaxAggregateOutputType | null
  }

  type GetCache_locksGroupByPayload<T extends cache_locksGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Cache_locksGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Cache_locksGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Cache_locksGroupByOutputType[P]>
            : GetScalarType<T[P], Cache_locksGroupByOutputType[P]>
        }
      >
    >


  export type cache_locksSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    key?: boolean
    owner?: boolean
    expiration?: boolean
  }, ExtArgs["result"]["cache_locks"]>



  export type cache_locksSelectScalar = {
    key?: boolean
    owner?: boolean
    expiration?: boolean
  }

  export type cache_locksOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"key" | "owner" | "expiration", ExtArgs["result"]["cache_locks"]>

  export type $cache_locksPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cache_locks"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      key: string
      owner: string
      expiration: number
    }, ExtArgs["result"]["cache_locks"]>
    composites: {}
  }

  type cache_locksGetPayload<S extends boolean | null | undefined | cache_locksDefaultArgs> = $Result.GetResult<Prisma.$cache_locksPayload, S>

  type cache_locksCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<cache_locksFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Cache_locksCountAggregateInputType | true
    }

  export interface cache_locksDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cache_locks'], meta: { name: 'cache_locks' } }
    /**
     * Find zero or one Cache_locks that matches the filter.
     * @param {cache_locksFindUniqueArgs} args - Arguments to find a Cache_locks
     * @example
     * // Get one Cache_locks
     * const cache_locks = await prisma.cache_locks.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends cache_locksFindUniqueArgs>(args: SelectSubset<T, cache_locksFindUniqueArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cache_locks that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {cache_locksFindUniqueOrThrowArgs} args - Arguments to find a Cache_locks
     * @example
     * // Get one Cache_locks
     * const cache_locks = await prisma.cache_locks.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends cache_locksFindUniqueOrThrowArgs>(args: SelectSubset<T, cache_locksFindUniqueOrThrowArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache_locks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_locksFindFirstArgs} args - Arguments to find a Cache_locks
     * @example
     * // Get one Cache_locks
     * const cache_locks = await prisma.cache_locks.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends cache_locksFindFirstArgs>(args?: SelectSubset<T, cache_locksFindFirstArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cache_locks that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_locksFindFirstOrThrowArgs} args - Arguments to find a Cache_locks
     * @example
     * // Get one Cache_locks
     * const cache_locks = await prisma.cache_locks.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends cache_locksFindFirstOrThrowArgs>(args?: SelectSubset<T, cache_locksFindFirstOrThrowArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cache_locks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_locksFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cache_locks
     * const cache_locks = await prisma.cache_locks.findMany()
     * 
     * // Get first 10 Cache_locks
     * const cache_locks = await prisma.cache_locks.findMany({ take: 10 })
     * 
     * // Only select the `key`
     * const cache_locksWithKeyOnly = await prisma.cache_locks.findMany({ select: { key: true } })
     * 
     */
    findMany<T extends cache_locksFindManyArgs>(args?: SelectSubset<T, cache_locksFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cache_locks.
     * @param {cache_locksCreateArgs} args - Arguments to create a Cache_locks.
     * @example
     * // Create one Cache_locks
     * const Cache_locks = await prisma.cache_locks.create({
     *   data: {
     *     // ... data to create a Cache_locks
     *   }
     * })
     * 
     */
    create<T extends cache_locksCreateArgs>(args: SelectSubset<T, cache_locksCreateArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cache_locks.
     * @param {cache_locksCreateManyArgs} args - Arguments to create many Cache_locks.
     * @example
     * // Create many Cache_locks
     * const cache_locks = await prisma.cache_locks.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends cache_locksCreateManyArgs>(args?: SelectSubset<T, cache_locksCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cache_locks.
     * @param {cache_locksDeleteArgs} args - Arguments to delete one Cache_locks.
     * @example
     * // Delete one Cache_locks
     * const Cache_locks = await prisma.cache_locks.delete({
     *   where: {
     *     // ... filter to delete one Cache_locks
     *   }
     * })
     * 
     */
    delete<T extends cache_locksDeleteArgs>(args: SelectSubset<T, cache_locksDeleteArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cache_locks.
     * @param {cache_locksUpdateArgs} args - Arguments to update one Cache_locks.
     * @example
     * // Update one Cache_locks
     * const cache_locks = await prisma.cache_locks.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends cache_locksUpdateArgs>(args: SelectSubset<T, cache_locksUpdateArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cache_locks.
     * @param {cache_locksDeleteManyArgs} args - Arguments to filter Cache_locks to delete.
     * @example
     * // Delete a few Cache_locks
     * const { count } = await prisma.cache_locks.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends cache_locksDeleteManyArgs>(args?: SelectSubset<T, cache_locksDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cache_locks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_locksUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cache_locks
     * const cache_locks = await prisma.cache_locks.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends cache_locksUpdateManyArgs>(args: SelectSubset<T, cache_locksUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cache_locks.
     * @param {cache_locksUpsertArgs} args - Arguments to update or create a Cache_locks.
     * @example
     * // Update or create a Cache_locks
     * const cache_locks = await prisma.cache_locks.upsert({
     *   create: {
     *     // ... data to create a Cache_locks
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cache_locks we want to update
     *   }
     * })
     */
    upsert<T extends cache_locksUpsertArgs>(args: SelectSubset<T, cache_locksUpsertArgs<ExtArgs>>): Prisma__cache_locksClient<$Result.GetResult<Prisma.$cache_locksPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Cache_locks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_locksCountArgs} args - Arguments to filter Cache_locks to count.
     * @example
     * // Count the number of Cache_locks
     * const count = await prisma.cache_locks.count({
     *   where: {
     *     // ... the filter for the Cache_locks we want to count
     *   }
     * })
    **/
    count<T extends cache_locksCountArgs>(
      args?: Subset<T, cache_locksCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Cache_locksCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cache_locks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Cache_locksAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Cache_locksAggregateArgs>(args: Subset<T, Cache_locksAggregateArgs>): Prisma.PrismaPromise<GetCache_locksAggregateType<T>>

    /**
     * Group by Cache_locks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {cache_locksGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends cache_locksGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: cache_locksGroupByArgs['orderBy'] }
        : { orderBy?: cache_locksGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, cache_locksGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCache_locksGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cache_locks model
   */
  readonly fields: cache_locksFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cache_locks.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__cache_locksClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cache_locks model
   */
  interface cache_locksFieldRefs {
    readonly key: FieldRef<"cache_locks", 'String'>
    readonly owner: FieldRef<"cache_locks", 'String'>
    readonly expiration: FieldRef<"cache_locks", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * cache_locks findUnique
   */
  export type cache_locksFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * Filter, which cache_locks to fetch.
     */
    where: cache_locksWhereUniqueInput
  }

  /**
   * cache_locks findUniqueOrThrow
   */
  export type cache_locksFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * Filter, which cache_locks to fetch.
     */
    where: cache_locksWhereUniqueInput
  }

  /**
   * cache_locks findFirst
   */
  export type cache_locksFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * Filter, which cache_locks to fetch.
     */
    where?: cache_locksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_locks to fetch.
     */
    orderBy?: cache_locksOrderByWithRelationInput | cache_locksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cache_locks.
     */
    cursor?: cache_locksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_locks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_locks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cache_locks.
     */
    distinct?: Cache_locksScalarFieldEnum | Cache_locksScalarFieldEnum[]
  }

  /**
   * cache_locks findFirstOrThrow
   */
  export type cache_locksFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * Filter, which cache_locks to fetch.
     */
    where?: cache_locksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_locks to fetch.
     */
    orderBy?: cache_locksOrderByWithRelationInput | cache_locksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cache_locks.
     */
    cursor?: cache_locksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_locks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_locks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cache_locks.
     */
    distinct?: Cache_locksScalarFieldEnum | Cache_locksScalarFieldEnum[]
  }

  /**
   * cache_locks findMany
   */
  export type cache_locksFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * Filter, which cache_locks to fetch.
     */
    where?: cache_locksWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cache_locks to fetch.
     */
    orderBy?: cache_locksOrderByWithRelationInput | cache_locksOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cache_locks.
     */
    cursor?: cache_locksWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cache_locks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cache_locks.
     */
    skip?: number
    distinct?: Cache_locksScalarFieldEnum | Cache_locksScalarFieldEnum[]
  }

  /**
   * cache_locks create
   */
  export type cache_locksCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * The data needed to create a cache_locks.
     */
    data: XOR<cache_locksCreateInput, cache_locksUncheckedCreateInput>
  }

  /**
   * cache_locks createMany
   */
  export type cache_locksCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cache_locks.
     */
    data: cache_locksCreateManyInput | cache_locksCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * cache_locks update
   */
  export type cache_locksUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * The data needed to update a cache_locks.
     */
    data: XOR<cache_locksUpdateInput, cache_locksUncheckedUpdateInput>
    /**
     * Choose, which cache_locks to update.
     */
    where: cache_locksWhereUniqueInput
  }

  /**
   * cache_locks updateMany
   */
  export type cache_locksUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cache_locks.
     */
    data: XOR<cache_locksUpdateManyMutationInput, cache_locksUncheckedUpdateManyInput>
    /**
     * Filter which cache_locks to update
     */
    where?: cache_locksWhereInput
    /**
     * Limit how many cache_locks to update.
     */
    limit?: number
  }

  /**
   * cache_locks upsert
   */
  export type cache_locksUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * The filter to search for the cache_locks to update in case it exists.
     */
    where: cache_locksWhereUniqueInput
    /**
     * In case the cache_locks found by the `where` argument doesn't exist, create a new cache_locks with this data.
     */
    create: XOR<cache_locksCreateInput, cache_locksUncheckedCreateInput>
    /**
     * In case the cache_locks was found with the provided `where` argument, update it with this data.
     */
    update: XOR<cache_locksUpdateInput, cache_locksUncheckedUpdateInput>
  }

  /**
   * cache_locks delete
   */
  export type cache_locksDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
    /**
     * Filter which cache_locks to delete.
     */
    where: cache_locksWhereUniqueInput
  }

  /**
   * cache_locks deleteMany
   */
  export type cache_locksDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cache_locks to delete
     */
    where?: cache_locksWhereInput
    /**
     * Limit how many cache_locks to delete.
     */
    limit?: number
  }

  /**
   * cache_locks without action
   */
  export type cache_locksDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cache_locks
     */
    select?: cache_locksSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cache_locks
     */
    omit?: cache_locksOmit<ExtArgs> | null
  }


  /**
   * Model job_batches
   */

  export type AggregateJob_batches = {
    _count: Job_batchesCountAggregateOutputType | null
    _avg: Job_batchesAvgAggregateOutputType | null
    _sum: Job_batchesSumAggregateOutputType | null
    _min: Job_batchesMinAggregateOutputType | null
    _max: Job_batchesMaxAggregateOutputType | null
  }

  export type Job_batchesAvgAggregateOutputType = {
    total_jobs: number | null
    pending_jobs: number | null
    failed_jobs: number | null
    cancelled_at: number | null
    created_at: number | null
    finished_at: number | null
  }

  export type Job_batchesSumAggregateOutputType = {
    total_jobs: number | null
    pending_jobs: number | null
    failed_jobs: number | null
    cancelled_at: number | null
    created_at: number | null
    finished_at: number | null
  }

  export type Job_batchesMinAggregateOutputType = {
    id: string | null
    name: string | null
    total_jobs: number | null
    pending_jobs: number | null
    failed_jobs: number | null
    failed_job_ids: string | null
    options: string | null
    cancelled_at: number | null
    created_at: number | null
    finished_at: number | null
  }

  export type Job_batchesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    total_jobs: number | null
    pending_jobs: number | null
    failed_jobs: number | null
    failed_job_ids: string | null
    options: string | null
    cancelled_at: number | null
    created_at: number | null
    finished_at: number | null
  }

  export type Job_batchesCountAggregateOutputType = {
    id: number
    name: number
    total_jobs: number
    pending_jobs: number
    failed_jobs: number
    failed_job_ids: number
    options: number
    cancelled_at: number
    created_at: number
    finished_at: number
    _all: number
  }


  export type Job_batchesAvgAggregateInputType = {
    total_jobs?: true
    pending_jobs?: true
    failed_jobs?: true
    cancelled_at?: true
    created_at?: true
    finished_at?: true
  }

  export type Job_batchesSumAggregateInputType = {
    total_jobs?: true
    pending_jobs?: true
    failed_jobs?: true
    cancelled_at?: true
    created_at?: true
    finished_at?: true
  }

  export type Job_batchesMinAggregateInputType = {
    id?: true
    name?: true
    total_jobs?: true
    pending_jobs?: true
    failed_jobs?: true
    failed_job_ids?: true
    options?: true
    cancelled_at?: true
    created_at?: true
    finished_at?: true
  }

  export type Job_batchesMaxAggregateInputType = {
    id?: true
    name?: true
    total_jobs?: true
    pending_jobs?: true
    failed_jobs?: true
    failed_job_ids?: true
    options?: true
    cancelled_at?: true
    created_at?: true
    finished_at?: true
  }

  export type Job_batchesCountAggregateInputType = {
    id?: true
    name?: true
    total_jobs?: true
    pending_jobs?: true
    failed_jobs?: true
    failed_job_ids?: true
    options?: true
    cancelled_at?: true
    created_at?: true
    finished_at?: true
    _all?: true
  }

  export type Job_batchesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_batches to aggregate.
     */
    where?: job_batchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_batches to fetch.
     */
    orderBy?: job_batchesOrderByWithRelationInput | job_batchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: job_batchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned job_batches
    **/
    _count?: true | Job_batchesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Job_batchesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Job_batchesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Job_batchesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Job_batchesMaxAggregateInputType
  }

  export type GetJob_batchesAggregateType<T extends Job_batchesAggregateArgs> = {
        [P in keyof T & keyof AggregateJob_batches]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJob_batches[P]>
      : GetScalarType<T[P], AggregateJob_batches[P]>
  }




  export type job_batchesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: job_batchesWhereInput
    orderBy?: job_batchesOrderByWithAggregationInput | job_batchesOrderByWithAggregationInput[]
    by: Job_batchesScalarFieldEnum[] | Job_batchesScalarFieldEnum
    having?: job_batchesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Job_batchesCountAggregateInputType | true
    _avg?: Job_batchesAvgAggregateInputType
    _sum?: Job_batchesSumAggregateInputType
    _min?: Job_batchesMinAggregateInputType
    _max?: Job_batchesMaxAggregateInputType
  }

  export type Job_batchesGroupByOutputType = {
    id: string
    name: string
    total_jobs: number
    pending_jobs: number
    failed_jobs: number
    failed_job_ids: string
    options: string | null
    cancelled_at: number | null
    created_at: number
    finished_at: number | null
    _count: Job_batchesCountAggregateOutputType | null
    _avg: Job_batchesAvgAggregateOutputType | null
    _sum: Job_batchesSumAggregateOutputType | null
    _min: Job_batchesMinAggregateOutputType | null
    _max: Job_batchesMaxAggregateOutputType | null
  }

  type GetJob_batchesGroupByPayload<T extends job_batchesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Job_batchesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Job_batchesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Job_batchesGroupByOutputType[P]>
            : GetScalarType<T[P], Job_batchesGroupByOutputType[P]>
        }
      >
    >


  export type job_batchesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    total_jobs?: boolean
    pending_jobs?: boolean
    failed_jobs?: boolean
    failed_job_ids?: boolean
    options?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    finished_at?: boolean
  }, ExtArgs["result"]["job_batches"]>



  export type job_batchesSelectScalar = {
    id?: boolean
    name?: boolean
    total_jobs?: boolean
    pending_jobs?: boolean
    failed_jobs?: boolean
    failed_job_ids?: boolean
    options?: boolean
    cancelled_at?: boolean
    created_at?: boolean
    finished_at?: boolean
  }

  export type job_batchesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "total_jobs" | "pending_jobs" | "failed_jobs" | "failed_job_ids" | "options" | "cancelled_at" | "created_at" | "finished_at", ExtArgs["result"]["job_batches"]>

  export type $job_batchesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "job_batches"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      total_jobs: number
      pending_jobs: number
      failed_jobs: number
      failed_job_ids: string
      options: string | null
      cancelled_at: number | null
      created_at: number
      finished_at: number | null
    }, ExtArgs["result"]["job_batches"]>
    composites: {}
  }

  type job_batchesGetPayload<S extends boolean | null | undefined | job_batchesDefaultArgs> = $Result.GetResult<Prisma.$job_batchesPayload, S>

  type job_batchesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<job_batchesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Job_batchesCountAggregateInputType | true
    }

  export interface job_batchesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['job_batches'], meta: { name: 'job_batches' } }
    /**
     * Find zero or one Job_batches that matches the filter.
     * @param {job_batchesFindUniqueArgs} args - Arguments to find a Job_batches
     * @example
     * // Get one Job_batches
     * const job_batches = await prisma.job_batches.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends job_batchesFindUniqueArgs>(args: SelectSubset<T, job_batchesFindUniqueArgs<ExtArgs>>): Prisma__job_batchesClient<$Result.GetResult<Prisma.$job_batchesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Job_batches that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {job_batchesFindUniqueOrThrowArgs} args - Arguments to find a Job_batches
     * @example
     * // Get one Job_batches
     * const job_batches = await prisma.job_batches.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends job_batchesFindUniqueOrThrowArgs>(args: SelectSubset<T, job_batchesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__job_batchesClient<$Result.GetResult<Prisma.$job_batchesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_batches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_batchesFindFirstArgs} args - Arguments to find a Job_batches
     * @example
     * // Get one Job_batches
     * const job_batches = await prisma.job_batches.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends job_batchesFindFirstArgs>(args?: SelectSubset<T, job_batchesFindFirstArgs<ExtArgs>>): Prisma__job_batchesClient<$Result.GetResult<Prisma.$job_batchesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Job_batches that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_batchesFindFirstOrThrowArgs} args - Arguments to find a Job_batches
     * @example
     * // Get one Job_batches
     * const job_batches = await prisma.job_batches.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends job_batchesFindFirstOrThrowArgs>(args?: SelectSubset<T, job_batchesFindFirstOrThrowArgs<ExtArgs>>): Prisma__job_batchesClient<$Result.GetResult<Prisma.$job_batchesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Job_batches that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_batchesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Job_batches
     * const job_batches = await prisma.job_batches.findMany()
     * 
     * // Get first 10 Job_batches
     * const job_batches = await prisma.job_batches.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const job_batchesWithIdOnly = await prisma.job_batches.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends job_batchesFindManyArgs>(args?: SelectSubset<T, job_batchesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$job_batchesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Job_batches.
     * @param {job_batchesCreateArgs} args - Arguments to create a Job_batches.
     * @example
     * // Create one Job_batches
     * const Job_batches = await prisma.job_batches.create({
     *   data: {
     *     // ... data to create a Job_batches
     *   }
     * })
     * 
     */
    create<T extends job_batchesCreateArgs>(args: SelectSubset<T, job_batchesCreateArgs<ExtArgs>>): Prisma__job_batchesClient<$Result.GetResult<Prisma.$job_batchesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Job_batches.
     * @param {job_batchesCreateManyArgs} args - Arguments to create many Job_batches.
     * @example
     * // Create many Job_batches
     * const job_batches = await prisma.job_batches.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends job_batchesCreateManyArgs>(args?: SelectSubset<T, job_batchesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Job_batches.
     * @param {job_batchesDeleteArgs} args - Arguments to delete one Job_batches.
     * @example
     * // Delete one Job_batches
     * const Job_batches = await prisma.job_batches.delete({
     *   where: {
     *     // ... filter to delete one Job_batches
     *   }
     * })
     * 
     */
    delete<T extends job_batchesDeleteArgs>(args: SelectSubset<T, job_batchesDeleteArgs<ExtArgs>>): Prisma__job_batchesClient<$Result.GetResult<Prisma.$job_batchesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Job_batches.
     * @param {job_batchesUpdateArgs} args - Arguments to update one Job_batches.
     * @example
     * // Update one Job_batches
     * const job_batches = await prisma.job_batches.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends job_batchesUpdateArgs>(args: SelectSubset<T, job_batchesUpdateArgs<ExtArgs>>): Prisma__job_batchesClient<$Result.GetResult<Prisma.$job_batchesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Job_batches.
     * @param {job_batchesDeleteManyArgs} args - Arguments to filter Job_batches to delete.
     * @example
     * // Delete a few Job_batches
     * const { count } = await prisma.job_batches.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends job_batchesDeleteManyArgs>(args?: SelectSubset<T, job_batchesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Job_batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_batchesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Job_batches
     * const job_batches = await prisma.job_batches.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends job_batchesUpdateManyArgs>(args: SelectSubset<T, job_batchesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Job_batches.
     * @param {job_batchesUpsertArgs} args - Arguments to update or create a Job_batches.
     * @example
     * // Update or create a Job_batches
     * const job_batches = await prisma.job_batches.upsert({
     *   create: {
     *     // ... data to create a Job_batches
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Job_batches we want to update
     *   }
     * })
     */
    upsert<T extends job_batchesUpsertArgs>(args: SelectSubset<T, job_batchesUpsertArgs<ExtArgs>>): Prisma__job_batchesClient<$Result.GetResult<Prisma.$job_batchesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Job_batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_batchesCountArgs} args - Arguments to filter Job_batches to count.
     * @example
     * // Count the number of Job_batches
     * const count = await prisma.job_batches.count({
     *   where: {
     *     // ... the filter for the Job_batches we want to count
     *   }
     * })
    **/
    count<T extends job_batchesCountArgs>(
      args?: Subset<T, job_batchesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Job_batchesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Job_batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Job_batchesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Job_batchesAggregateArgs>(args: Subset<T, Job_batchesAggregateArgs>): Prisma.PrismaPromise<GetJob_batchesAggregateType<T>>

    /**
     * Group by Job_batches.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {job_batchesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends job_batchesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: job_batchesGroupByArgs['orderBy'] }
        : { orderBy?: job_batchesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, job_batchesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJob_batchesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the job_batches model
   */
  readonly fields: job_batchesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for job_batches.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__job_batchesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the job_batches model
   */
  interface job_batchesFieldRefs {
    readonly id: FieldRef<"job_batches", 'String'>
    readonly name: FieldRef<"job_batches", 'String'>
    readonly total_jobs: FieldRef<"job_batches", 'Int'>
    readonly pending_jobs: FieldRef<"job_batches", 'Int'>
    readonly failed_jobs: FieldRef<"job_batches", 'Int'>
    readonly failed_job_ids: FieldRef<"job_batches", 'String'>
    readonly options: FieldRef<"job_batches", 'String'>
    readonly cancelled_at: FieldRef<"job_batches", 'Int'>
    readonly created_at: FieldRef<"job_batches", 'Int'>
    readonly finished_at: FieldRef<"job_batches", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * job_batches findUnique
   */
  export type job_batchesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
    /**
     * Filter, which job_batches to fetch.
     */
    where: job_batchesWhereUniqueInput
  }

  /**
   * job_batches findUniqueOrThrow
   */
  export type job_batchesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
    /**
     * Filter, which job_batches to fetch.
     */
    where: job_batchesWhereUniqueInput
  }

  /**
   * job_batches findFirst
   */
  export type job_batchesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
    /**
     * Filter, which job_batches to fetch.
     */
    where?: job_batchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_batches to fetch.
     */
    orderBy?: job_batchesOrderByWithRelationInput | job_batchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_batches.
     */
    cursor?: job_batchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_batches.
     */
    distinct?: Job_batchesScalarFieldEnum | Job_batchesScalarFieldEnum[]
  }

  /**
   * job_batches findFirstOrThrow
   */
  export type job_batchesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
    /**
     * Filter, which job_batches to fetch.
     */
    where?: job_batchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_batches to fetch.
     */
    orderBy?: job_batchesOrderByWithRelationInput | job_batchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for job_batches.
     */
    cursor?: job_batchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_batches.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of job_batches.
     */
    distinct?: Job_batchesScalarFieldEnum | Job_batchesScalarFieldEnum[]
  }

  /**
   * job_batches findMany
   */
  export type job_batchesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
    /**
     * Filter, which job_batches to fetch.
     */
    where?: job_batchesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of job_batches to fetch.
     */
    orderBy?: job_batchesOrderByWithRelationInput | job_batchesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing job_batches.
     */
    cursor?: job_batchesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` job_batches from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` job_batches.
     */
    skip?: number
    distinct?: Job_batchesScalarFieldEnum | Job_batchesScalarFieldEnum[]
  }

  /**
   * job_batches create
   */
  export type job_batchesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
    /**
     * The data needed to create a job_batches.
     */
    data: XOR<job_batchesCreateInput, job_batchesUncheckedCreateInput>
  }

  /**
   * job_batches createMany
   */
  export type job_batchesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many job_batches.
     */
    data: job_batchesCreateManyInput | job_batchesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * job_batches update
   */
  export type job_batchesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
    /**
     * The data needed to update a job_batches.
     */
    data: XOR<job_batchesUpdateInput, job_batchesUncheckedUpdateInput>
    /**
     * Choose, which job_batches to update.
     */
    where: job_batchesWhereUniqueInput
  }

  /**
   * job_batches updateMany
   */
  export type job_batchesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update job_batches.
     */
    data: XOR<job_batchesUpdateManyMutationInput, job_batchesUncheckedUpdateManyInput>
    /**
     * Filter which job_batches to update
     */
    where?: job_batchesWhereInput
    /**
     * Limit how many job_batches to update.
     */
    limit?: number
  }

  /**
   * job_batches upsert
   */
  export type job_batchesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
    /**
     * The filter to search for the job_batches to update in case it exists.
     */
    where: job_batchesWhereUniqueInput
    /**
     * In case the job_batches found by the `where` argument doesn't exist, create a new job_batches with this data.
     */
    create: XOR<job_batchesCreateInput, job_batchesUncheckedCreateInput>
    /**
     * In case the job_batches was found with the provided `where` argument, update it with this data.
     */
    update: XOR<job_batchesUpdateInput, job_batchesUncheckedUpdateInput>
  }

  /**
   * job_batches delete
   */
  export type job_batchesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
    /**
     * Filter which job_batches to delete.
     */
    where: job_batchesWhereUniqueInput
  }

  /**
   * job_batches deleteMany
   */
  export type job_batchesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which job_batches to delete
     */
    where?: job_batchesWhereInput
    /**
     * Limit how many job_batches to delete.
     */
    limit?: number
  }

  /**
   * job_batches without action
   */
  export type job_batchesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the job_batches
     */
    select?: job_batchesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the job_batches
     */
    omit?: job_batchesOmit<ExtArgs> | null
  }


  /**
   * Model sessions
   */

  export type AggregateSessions = {
    _count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  export type SessionsAvgAggregateOutputType = {
    user_id: number | null
    last_activity: number | null
  }

  export type SessionsSumAggregateOutputType = {
    user_id: bigint | null
    last_activity: number | null
  }

  export type SessionsMinAggregateOutputType = {
    id: string | null
    user_id: bigint | null
    ip_address: string | null
    user_agent: string | null
    payload: string | null
    last_activity: number | null
  }

  export type SessionsMaxAggregateOutputType = {
    id: string | null
    user_id: bigint | null
    ip_address: string | null
    user_agent: string | null
    payload: string | null
    last_activity: number | null
  }

  export type SessionsCountAggregateOutputType = {
    id: number
    user_id: number
    ip_address: number
    user_agent: number
    payload: number
    last_activity: number
    _all: number
  }


  export type SessionsAvgAggregateInputType = {
    user_id?: true
    last_activity?: true
  }

  export type SessionsSumAggregateInputType = {
    user_id?: true
    last_activity?: true
  }

  export type SessionsMinAggregateInputType = {
    id?: true
    user_id?: true
    ip_address?: true
    user_agent?: true
    payload?: true
    last_activity?: true
  }

  export type SessionsMaxAggregateInputType = {
    id?: true
    user_id?: true
    ip_address?: true
    user_agent?: true
    payload?: true
    last_activity?: true
  }

  export type SessionsCountAggregateInputType = {
    id?: true
    user_id?: true
    ip_address?: true
    user_agent?: true
    payload?: true
    last_activity?: true
    _all?: true
  }

  export type SessionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to aggregate.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned sessions
    **/
    _count?: true | SessionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SessionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SessionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionsMaxAggregateInputType
  }

  export type GetSessionsAggregateType<T extends SessionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSessions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSessions[P]>
      : GetScalarType<T[P], AggregateSessions[P]>
  }




  export type sessionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: sessionsWhereInput
    orderBy?: sessionsOrderByWithAggregationInput | sessionsOrderByWithAggregationInput[]
    by: SessionsScalarFieldEnum[] | SessionsScalarFieldEnum
    having?: sessionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionsCountAggregateInputType | true
    _avg?: SessionsAvgAggregateInputType
    _sum?: SessionsSumAggregateInputType
    _min?: SessionsMinAggregateInputType
    _max?: SessionsMaxAggregateInputType
  }

  export type SessionsGroupByOutputType = {
    id: string
    user_id: bigint | null
    ip_address: string | null
    user_agent: string | null
    payload: string
    last_activity: number
    _count: SessionsCountAggregateOutputType | null
    _avg: SessionsAvgAggregateOutputType | null
    _sum: SessionsSumAggregateOutputType | null
    _min: SessionsMinAggregateOutputType | null
    _max: SessionsMaxAggregateOutputType | null
  }

  type GetSessionsGroupByPayload<T extends sessionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionsGroupByOutputType[P]>
            : GetScalarType<T[P], SessionsGroupByOutputType[P]>
        }
      >
    >


  export type sessionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    payload?: boolean
    last_activity?: boolean
  }, ExtArgs["result"]["sessions"]>



  export type sessionsSelectScalar = {
    id?: boolean
    user_id?: boolean
    ip_address?: boolean
    user_agent?: boolean
    payload?: boolean
    last_activity?: boolean
  }

  export type sessionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "ip_address" | "user_agent" | "payload" | "last_activity", ExtArgs["result"]["sessions"]>

  export type $sessionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "sessions"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: bigint | null
      ip_address: string | null
      user_agent: string | null
      payload: string
      last_activity: number
    }, ExtArgs["result"]["sessions"]>
    composites: {}
  }

  type sessionsGetPayload<S extends boolean | null | undefined | sessionsDefaultArgs> = $Result.GetResult<Prisma.$sessionsPayload, S>

  type sessionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<sessionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionsCountAggregateInputType | true
    }

  export interface sessionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['sessions'], meta: { name: 'sessions' } }
    /**
     * Find zero or one Sessions that matches the filter.
     * @param {sessionsFindUniqueArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends sessionsFindUniqueArgs>(args: SelectSubset<T, sessionsFindUniqueArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Sessions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {sessionsFindUniqueOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends sessionsFindUniqueOrThrowArgs>(args: SelectSubset<T, sessionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends sessionsFindFirstArgs>(args?: SelectSubset<T, sessionsFindFirstArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Sessions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindFirstOrThrowArgs} args - Arguments to find a Sessions
     * @example
     * // Get one Sessions
     * const sessions = await prisma.sessions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends sessionsFindFirstOrThrowArgs>(args?: SelectSubset<T, sessionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.sessions.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.sessions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionsWithIdOnly = await prisma.sessions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends sessionsFindManyArgs>(args?: SelectSubset<T, sessionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Sessions.
     * @param {sessionsCreateArgs} args - Arguments to create a Sessions.
     * @example
     * // Create one Sessions
     * const Sessions = await prisma.sessions.create({
     *   data: {
     *     // ... data to create a Sessions
     *   }
     * })
     * 
     */
    create<T extends sessionsCreateArgs>(args: SelectSubset<T, sessionsCreateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {sessionsCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const sessions = await prisma.sessions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends sessionsCreateManyArgs>(args?: SelectSubset<T, sessionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Sessions.
     * @param {sessionsDeleteArgs} args - Arguments to delete one Sessions.
     * @example
     * // Delete one Sessions
     * const Sessions = await prisma.sessions.delete({
     *   where: {
     *     // ... filter to delete one Sessions
     *   }
     * })
     * 
     */
    delete<T extends sessionsDeleteArgs>(args: SelectSubset<T, sessionsDeleteArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Sessions.
     * @param {sessionsUpdateArgs} args - Arguments to update one Sessions.
     * @example
     * // Update one Sessions
     * const sessions = await prisma.sessions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends sessionsUpdateArgs>(args: SelectSubset<T, sessionsUpdateArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {sessionsDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.sessions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends sessionsDeleteManyArgs>(args?: SelectSubset<T, sessionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const sessions = await prisma.sessions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends sessionsUpdateManyArgs>(args: SelectSubset<T, sessionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sessions.
     * @param {sessionsUpsertArgs} args - Arguments to update or create a Sessions.
     * @example
     * // Update or create a Sessions
     * const sessions = await prisma.sessions.upsert({
     *   create: {
     *     // ... data to create a Sessions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sessions we want to update
     *   }
     * })
     */
    upsert<T extends sessionsUpsertArgs>(args: SelectSubset<T, sessionsUpsertArgs<ExtArgs>>): Prisma__sessionsClient<$Result.GetResult<Prisma.$sessionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.sessions.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends sessionsCountArgs>(
      args?: Subset<T, sessionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionsAggregateArgs>(args: Subset<T, SessionsAggregateArgs>): Prisma.PrismaPromise<GetSessionsAggregateType<T>>

    /**
     * Group by Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {sessionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends sessionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: sessionsGroupByArgs['orderBy'] }
        : { orderBy?: sessionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, sessionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the sessions model
   */
  readonly fields: sessionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for sessions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__sessionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the sessions model
   */
  interface sessionsFieldRefs {
    readonly id: FieldRef<"sessions", 'String'>
    readonly user_id: FieldRef<"sessions", 'BigInt'>
    readonly ip_address: FieldRef<"sessions", 'String'>
    readonly user_agent: FieldRef<"sessions", 'String'>
    readonly payload: FieldRef<"sessions", 'String'>
    readonly last_activity: FieldRef<"sessions", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * sessions findUnique
   */
  export type sessionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findUniqueOrThrow
   */
  export type sessionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions findFirst
   */
  export type sessionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findFirstOrThrow
   */
  export type sessionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of sessions.
     */
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions findMany
   */
  export type sessionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter, which sessions to fetch.
     */
    where?: sessionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of sessions to fetch.
     */
    orderBy?: sessionsOrderByWithRelationInput | sessionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing sessions.
     */
    cursor?: sessionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` sessions.
     */
    skip?: number
    distinct?: SessionsScalarFieldEnum | SessionsScalarFieldEnum[]
  }

  /**
   * sessions create
   */
  export type sessionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The data needed to create a sessions.
     */
    data: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
  }

  /**
   * sessions createMany
   */
  export type sessionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many sessions.
     */
    data: sessionsCreateManyInput | sessionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * sessions update
   */
  export type sessionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The data needed to update a sessions.
     */
    data: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
    /**
     * Choose, which sessions to update.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions updateMany
   */
  export type sessionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update sessions.
     */
    data: XOR<sessionsUpdateManyMutationInput, sessionsUncheckedUpdateManyInput>
    /**
     * Filter which sessions to update
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to update.
     */
    limit?: number
  }

  /**
   * sessions upsert
   */
  export type sessionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * The filter to search for the sessions to update in case it exists.
     */
    where: sessionsWhereUniqueInput
    /**
     * In case the sessions found by the `where` argument doesn't exist, create a new sessions with this data.
     */
    create: XOR<sessionsCreateInput, sessionsUncheckedCreateInput>
    /**
     * In case the sessions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<sessionsUpdateInput, sessionsUncheckedUpdateInput>
  }

  /**
   * sessions delete
   */
  export type sessionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
    /**
     * Filter which sessions to delete.
     */
    where: sessionsWhereUniqueInput
  }

  /**
   * sessions deleteMany
   */
  export type sessionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which sessions to delete
     */
    where?: sessionsWhereInput
    /**
     * Limit how many sessions to delete.
     */
    limit?: number
  }

  /**
   * sessions without action
   */
  export type sessionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the sessions
     */
    select?: sessionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the sessions
     */
    omit?: sessionsOmit<ExtArgs> | null
  }


  /**
   * Model categories
   */

  export type AggregateCategories = {
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  export type CategoriesAvgAggregateOutputType = {
    id: number | null
    parent_id: number | null
    company_id: number | null
  }

  export type CategoriesSumAggregateOutputType = {
    id: bigint | null
    parent_id: bigint | null
    company_id: bigint | null
  }

  export type CategoriesMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    parent_id: bigint | null
    company_id: bigint | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CategoriesMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    parent_id: bigint | null
    company_id: bigint | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CategoriesCountAggregateOutputType = {
    id: number
    name: number
    parent_id: number
    company_id: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CategoriesAvgAggregateInputType = {
    id?: true
    parent_id?: true
    company_id?: true
  }

  export type CategoriesSumAggregateInputType = {
    id?: true
    parent_id?: true
    company_id?: true
  }

  export type CategoriesMinAggregateInputType = {
    id?: true
    name?: true
    parent_id?: true
    company_id?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type CategoriesMaxAggregateInputType = {
    id?: true
    name?: true
    parent_id?: true
    company_id?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type CategoriesCountAggregateInputType = {
    id?: true
    name?: true
    parent_id?: true
    company_id?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CategoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to aggregate.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned categories
    **/
    _count?: true | CategoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CategoriesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CategoriesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CategoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CategoriesMaxAggregateInputType
  }

  export type GetCategoriesAggregateType<T extends CategoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateCategories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCategories[P]>
      : GetScalarType<T[P], AggregateCategories[P]>
  }




  export type categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: categoriesWhereInput
    orderBy?: categoriesOrderByWithAggregationInput | categoriesOrderByWithAggregationInput[]
    by: CategoriesScalarFieldEnum[] | CategoriesScalarFieldEnum
    having?: categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CategoriesCountAggregateInputType | true
    _avg?: CategoriesAvgAggregateInputType
    _sum?: CategoriesSumAggregateInputType
    _min?: CategoriesMinAggregateInputType
    _max?: CategoriesMaxAggregateInputType
  }

  export type CategoriesGroupByOutputType = {
    id: bigint
    name: string
    parent_id: bigint | null
    company_id: bigint
    status: boolean
    created_at: Date | null
    updated_at: Date | null
    _count: CategoriesCountAggregateOutputType | null
    _avg: CategoriesAvgAggregateOutputType | null
    _sum: CategoriesSumAggregateOutputType | null
    _min: CategoriesMinAggregateOutputType | null
    _max: CategoriesMaxAggregateOutputType | null
  }

  type GetCategoriesGroupByPayload<T extends categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CategoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CategoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
            : GetScalarType<T[P], CategoriesGroupByOutputType[P]>
        }
      >
    >


  export type categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    parent_id?: boolean
    company_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    categories?: boolean | categories$categoriesArgs<ExtArgs>
    other_categories?: boolean | categories$other_categoriesArgs<ExtArgs>
    integration_category_mappings?: boolean | categories$integration_category_mappingsArgs<ExtArgs>
    offer_category?: boolean | categories$offer_categoryArgs<ExtArgs>
    offers?: boolean | categories$offersArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["categories"]>



  export type categoriesSelectScalar = {
    id?: boolean
    name?: boolean
    parent_id?: boolean
    company_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "parent_id" | "company_id" | "status" | "created_at" | "updated_at", ExtArgs["result"]["categories"]>
  export type categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    categories?: boolean | categories$categoriesArgs<ExtArgs>
    other_categories?: boolean | categories$other_categoriesArgs<ExtArgs>
    integration_category_mappings?: boolean | categories$integration_category_mappingsArgs<ExtArgs>
    offer_category?: boolean | categories$offer_categoryArgs<ExtArgs>
    offers?: boolean | categories$offersArgs<ExtArgs>
    _count?: boolean | CategoriesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "categories"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs>
      categories: Prisma.$categoriesPayload<ExtArgs> | null
      other_categories: Prisma.$categoriesPayload<ExtArgs>[]
      integration_category_mappings: Prisma.$integration_category_mappingsPayload<ExtArgs>[]
      offer_category: Prisma.$offer_categoryPayload<ExtArgs>[]
      offers: Prisma.$offersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      parent_id: bigint | null
      company_id: bigint
      status: boolean
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["categories"]>
    composites: {}
  }

  type categoriesGetPayload<S extends boolean | null | undefined | categoriesDefaultArgs> = $Result.GetResult<Prisma.$categoriesPayload, S>

  type categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CategoriesCountAggregateInputType | true
    }

  export interface categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['categories'], meta: { name: 'categories' } }
    /**
     * Find zero or one Categories that matches the filter.
     * @param {categoriesFindUniqueArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends categoriesFindUniqueArgs>(args: SelectSubset<T, categoriesFindUniqueArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {categoriesFindUniqueOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends categoriesFindFirstArgs>(args?: SelectSubset<T, categoriesFindFirstArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindFirstOrThrowArgs} args - Arguments to find a Categories
     * @example
     * // Get one Categories
     * const categories = await prisma.categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Categories
     * const categories = await prisma.categories.findMany()
     * 
     * // Get first 10 Categories
     * const categories = await prisma.categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const categoriesWithIdOnly = await prisma.categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends categoriesFindManyArgs>(args?: SelectSubset<T, categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Categories.
     * @param {categoriesCreateArgs} args - Arguments to create a Categories.
     * @example
     * // Create one Categories
     * const Categories = await prisma.categories.create({
     *   data: {
     *     // ... data to create a Categories
     *   }
     * })
     * 
     */
    create<T extends categoriesCreateArgs>(args: SelectSubset<T, categoriesCreateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Categories.
     * @param {categoriesCreateManyArgs} args - Arguments to create many Categories.
     * @example
     * // Create many Categories
     * const categories = await prisma.categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends categoriesCreateManyArgs>(args?: SelectSubset<T, categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Categories.
     * @param {categoriesDeleteArgs} args - Arguments to delete one Categories.
     * @example
     * // Delete one Categories
     * const Categories = await prisma.categories.delete({
     *   where: {
     *     // ... filter to delete one Categories
     *   }
     * })
     * 
     */
    delete<T extends categoriesDeleteArgs>(args: SelectSubset<T, categoriesDeleteArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Categories.
     * @param {categoriesUpdateArgs} args - Arguments to update one Categories.
     * @example
     * // Update one Categories
     * const categories = await prisma.categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends categoriesUpdateArgs>(args: SelectSubset<T, categoriesUpdateArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Categories.
     * @param {categoriesDeleteManyArgs} args - Arguments to filter Categories to delete.
     * @example
     * // Delete a few Categories
     * const { count } = await prisma.categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends categoriesDeleteManyArgs>(args?: SelectSubset<T, categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Categories
     * const categories = await prisma.categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends categoriesUpdateManyArgs>(args: SelectSubset<T, categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Categories.
     * @param {categoriesUpsertArgs} args - Arguments to update or create a Categories.
     * @example
     * // Update or create a Categories
     * const categories = await prisma.categories.upsert({
     *   create: {
     *     // ... data to create a Categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Categories we want to update
     *   }
     * })
     */
    upsert<T extends categoriesUpsertArgs>(args: SelectSubset<T, categoriesUpsertArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesCountArgs} args - Arguments to filter Categories to count.
     * @example
     * // Count the number of Categories
     * const count = await prisma.categories.count({
     *   where: {
     *     // ... the filter for the Categories we want to count
     *   }
     * })
    **/
    count<T extends categoriesCountArgs>(
      args?: Subset<T, categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CategoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CategoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CategoriesAggregateArgs>(args: Subset<T, CategoriesAggregateArgs>): Prisma.PrismaPromise<GetCategoriesAggregateType<T>>

    /**
     * Group by Categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: categoriesGroupByArgs['orderBy'] }
        : { orderBy?: categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCategoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the categories model
   */
  readonly fields: categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    categories<T extends categories$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, categories$categoriesArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_categories<T extends categories$other_categoriesArgs<ExtArgs> = {}>(args?: Subset<T, categories$other_categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    integration_category_mappings<T extends categories$integration_category_mappingsArgs<ExtArgs> = {}>(args?: Subset<T, categories$integration_category_mappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$integration_category_mappingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    offer_category<T extends categories$offer_categoryArgs<ExtArgs> = {}>(args?: Subset<T, categories$offer_categoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$offer_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    offers<T extends categories$offersArgs<ExtArgs> = {}>(args?: Subset<T, categories$offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$offersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the categories model
   */
  interface categoriesFieldRefs {
    readonly id: FieldRef<"categories", 'BigInt'>
    readonly name: FieldRef<"categories", 'String'>
    readonly parent_id: FieldRef<"categories", 'BigInt'>
    readonly company_id: FieldRef<"categories", 'BigInt'>
    readonly status: FieldRef<"categories", 'Boolean'>
    readonly created_at: FieldRef<"categories", 'DateTime'>
    readonly updated_at: FieldRef<"categories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * categories findUnique
   */
  export type categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories findUniqueOrThrow
   */
  export type categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories findFirst
   */
  export type categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories findFirstOrThrow
   */
  export type categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of categories.
     */
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories findMany
   */
  export type categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter, which categories to fetch.
     */
    where?: categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of categories to fetch.
     */
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing categories.
     */
    cursor?: categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` categories.
     */
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories create
   */
  export type categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a categories.
     */
    data: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
  }

  /**
   * categories createMany
   */
  export type categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many categories.
     */
    data: categoriesCreateManyInput | categoriesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * categories update
   */
  export type categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a categories.
     */
    data: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
    /**
     * Choose, which categories to update.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories updateMany
   */
  export type categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update categories.
     */
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyInput>
    /**
     * Filter which categories to update
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to update.
     */
    limit?: number
  }

  /**
   * categories upsert
   */
  export type categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the categories to update in case it exists.
     */
    where: categoriesWhereUniqueInput
    /**
     * In case the categories found by the `where` argument doesn't exist, create a new categories with this data.
     */
    create: XOR<categoriesCreateInput, categoriesUncheckedCreateInput>
    /**
     * In case the categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<categoriesUpdateInput, categoriesUncheckedUpdateInput>
  }

  /**
   * categories delete
   */
  export type categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    /**
     * Filter which categories to delete.
     */
    where: categoriesWhereUniqueInput
  }

  /**
   * categories deleteMany
   */
  export type categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which categories to delete
     */
    where?: categoriesWhereInput
    /**
     * Limit how many categories to delete.
     */
    limit?: number
  }

  /**
   * categories.categories
   */
  export type categories$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
  }

  /**
   * categories.other_categories
   */
  export type categories$other_categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    cursor?: categoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * categories.integration_category_mappings
   */
  export type categories$integration_category_mappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration_category_mappings
     */
    select?: integration_category_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration_category_mappings
     */
    omit?: integration_category_mappingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integration_category_mappingsInclude<ExtArgs> | null
    where?: integration_category_mappingsWhereInput
    orderBy?: integration_category_mappingsOrderByWithRelationInput | integration_category_mappingsOrderByWithRelationInput[]
    cursor?: integration_category_mappingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Integration_category_mappingsScalarFieldEnum | Integration_category_mappingsScalarFieldEnum[]
  }

  /**
   * categories.offer_category
   */
  export type categories$offer_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offer_category
     */
    select?: offer_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the offer_category
     */
    omit?: offer_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offer_categoryInclude<ExtArgs> | null
    where?: offer_categoryWhereInput
    orderBy?: offer_categoryOrderByWithRelationInput | offer_categoryOrderByWithRelationInput[]
    cursor?: offer_categoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Offer_categoryScalarFieldEnum | Offer_categoryScalarFieldEnum[]
  }

  /**
   * categories.offers
   */
  export type categories$offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offers
     */
    select?: offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the offers
     */
    omit?: offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offersInclude<ExtArgs> | null
    where?: offersWhereInput
    orderBy?: offersOrderByWithRelationInput | offersOrderByWithRelationInput[]
    cursor?: offersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OffersScalarFieldEnum | OffersScalarFieldEnum[]
  }

  /**
   * categories without action
   */
  export type categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
  }


  /**
   * Model companies
   */

  export type AggregateCompanies = {
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  export type CompaniesAvgAggregateOutputType = {
    id: number | null
  }

  export type CompaniesSumAggregateOutputType = {
    id: bigint | null
  }

  export type CompaniesMinAggregateOutputType = {
    id: bigint | null
    registration_no: string | null
    vat: string | null
    name: string | null
    email: string | null
    domain: string | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CompaniesMaxAggregateOutputType = {
    id: bigint | null
    registration_no: string | null
    vat: string | null
    name: string | null
    email: string | null
    domain: string | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type CompaniesCountAggregateOutputType = {
    id: number
    registration_no: number
    vat: number
    name: number
    email: number
    domain: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type CompaniesAvgAggregateInputType = {
    id?: true
  }

  export type CompaniesSumAggregateInputType = {
    id?: true
  }

  export type CompaniesMinAggregateInputType = {
    id?: true
    registration_no?: true
    vat?: true
    name?: true
    email?: true
    domain?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type CompaniesMaxAggregateInputType = {
    id?: true
    registration_no?: true
    vat?: true
    name?: true
    email?: true
    domain?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type CompaniesCountAggregateInputType = {
    id?: true
    registration_no?: true
    vat?: true
    name?: true
    email?: true
    domain?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type CompaniesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to aggregate.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned companies
    **/
    _count?: true | CompaniesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CompaniesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CompaniesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CompaniesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CompaniesMaxAggregateInputType
  }

  export type GetCompaniesAggregateType<T extends CompaniesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompanies]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompanies[P]>
      : GetScalarType<T[P], AggregateCompanies[P]>
  }




  export type companiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: companiesWhereInput
    orderBy?: companiesOrderByWithAggregationInput | companiesOrderByWithAggregationInput[]
    by: CompaniesScalarFieldEnum[] | CompaniesScalarFieldEnum
    having?: companiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CompaniesCountAggregateInputType | true
    _avg?: CompaniesAvgAggregateInputType
    _sum?: CompaniesSumAggregateInputType
    _min?: CompaniesMinAggregateInputType
    _max?: CompaniesMaxAggregateInputType
  }

  export type CompaniesGroupByOutputType = {
    id: bigint
    registration_no: string | null
    vat: string | null
    name: string
    email: string
    domain: string
    status: boolean
    created_at: Date | null
    updated_at: Date | null
    _count: CompaniesCountAggregateOutputType | null
    _avg: CompaniesAvgAggregateOutputType | null
    _sum: CompaniesSumAggregateOutputType | null
    _min: CompaniesMinAggregateOutputType | null
    _max: CompaniesMaxAggregateOutputType | null
  }

  type GetCompaniesGroupByPayload<T extends companiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CompaniesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CompaniesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
            : GetScalarType<T[P], CompaniesGroupByOutputType[P]>
        }
      >
    >


  export type companiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registration_no?: boolean
    vat?: boolean
    name?: boolean
    email?: boolean
    domain?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    categories?: boolean | companies$categoriesArgs<ExtArgs>
    company_frontend_settings?: boolean | companies$company_frontend_settingsArgs<ExtArgs>
    company_integrations?: boolean | companies$company_integrationsArgs<ExtArgs>
    company_profiles?: boolean | companies$company_profilesArgs<ExtArgs>
    company_subscriptions?: boolean | companies$company_subscriptionsArgs<ExtArgs>
    integration_category_mappings?: boolean | companies$integration_category_mappingsArgs<ExtArgs>
    offers?: boolean | companies$offersArgs<ExtArgs>
    stores?: boolean | companies$storesArgs<ExtArgs>
    users?: boolean | companies$usersArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["companies"]>



  export type companiesSelectScalar = {
    id?: boolean
    registration_no?: boolean
    vat?: boolean
    name?: boolean
    email?: boolean
    domain?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type companiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "registration_no" | "vat" | "name" | "email" | "domain" | "status" | "created_at" | "updated_at", ExtArgs["result"]["companies"]>
  export type companiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | companies$categoriesArgs<ExtArgs>
    company_frontend_settings?: boolean | companies$company_frontend_settingsArgs<ExtArgs>
    company_integrations?: boolean | companies$company_integrationsArgs<ExtArgs>
    company_profiles?: boolean | companies$company_profilesArgs<ExtArgs>
    company_subscriptions?: boolean | companies$company_subscriptionsArgs<ExtArgs>
    integration_category_mappings?: boolean | companies$integration_category_mappingsArgs<ExtArgs>
    offers?: boolean | companies$offersArgs<ExtArgs>
    stores?: boolean | companies$storesArgs<ExtArgs>
    users?: boolean | companies$usersArgs<ExtArgs>
    _count?: boolean | CompaniesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $companiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "companies"
    objects: {
      categories: Prisma.$categoriesPayload<ExtArgs>[]
      company_frontend_settings: Prisma.$company_frontend_settingsPayload<ExtArgs>[]
      company_integrations: Prisma.$company_integrationsPayload<ExtArgs>[]
      company_profiles: Prisma.$company_profilesPayload<ExtArgs>[]
      company_subscriptions: Prisma.$company_subscriptionsPayload<ExtArgs>[]
      integration_category_mappings: Prisma.$integration_category_mappingsPayload<ExtArgs>[]
      offers: Prisma.$offersPayload<ExtArgs>[]
      stores: Prisma.$storesPayload<ExtArgs>[]
      users: Prisma.$usersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      registration_no: string | null
      vat: string | null
      name: string
      email: string
      domain: string
      status: boolean
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["companies"]>
    composites: {}
  }

  type companiesGetPayload<S extends boolean | null | undefined | companiesDefaultArgs> = $Result.GetResult<Prisma.$companiesPayload, S>

  type companiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<companiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CompaniesCountAggregateInputType | true
    }

  export interface companiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['companies'], meta: { name: 'companies' } }
    /**
     * Find zero or one Companies that matches the filter.
     * @param {companiesFindUniqueArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends companiesFindUniqueArgs>(args: SelectSubset<T, companiesFindUniqueArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Companies that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {companiesFindUniqueOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends companiesFindUniqueOrThrowArgs>(args: SelectSubset<T, companiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends companiesFindFirstArgs>(args?: SelectSubset<T, companiesFindFirstArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Companies that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindFirstOrThrowArgs} args - Arguments to find a Companies
     * @example
     * // Get one Companies
     * const companies = await prisma.companies.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends companiesFindFirstOrThrowArgs>(args?: SelectSubset<T, companiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Companies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Companies
     * const companies = await prisma.companies.findMany()
     * 
     * // Get first 10 Companies
     * const companies = await prisma.companies.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const companiesWithIdOnly = await prisma.companies.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends companiesFindManyArgs>(args?: SelectSubset<T, companiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Companies.
     * @param {companiesCreateArgs} args - Arguments to create a Companies.
     * @example
     * // Create one Companies
     * const Companies = await prisma.companies.create({
     *   data: {
     *     // ... data to create a Companies
     *   }
     * })
     * 
     */
    create<T extends companiesCreateArgs>(args: SelectSubset<T, companiesCreateArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Companies.
     * @param {companiesCreateManyArgs} args - Arguments to create many Companies.
     * @example
     * // Create many Companies
     * const companies = await prisma.companies.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends companiesCreateManyArgs>(args?: SelectSubset<T, companiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Companies.
     * @param {companiesDeleteArgs} args - Arguments to delete one Companies.
     * @example
     * // Delete one Companies
     * const Companies = await prisma.companies.delete({
     *   where: {
     *     // ... filter to delete one Companies
     *   }
     * })
     * 
     */
    delete<T extends companiesDeleteArgs>(args: SelectSubset<T, companiesDeleteArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Companies.
     * @param {companiesUpdateArgs} args - Arguments to update one Companies.
     * @example
     * // Update one Companies
     * const companies = await prisma.companies.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends companiesUpdateArgs>(args: SelectSubset<T, companiesUpdateArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Companies.
     * @param {companiesDeleteManyArgs} args - Arguments to filter Companies to delete.
     * @example
     * // Delete a few Companies
     * const { count } = await prisma.companies.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends companiesDeleteManyArgs>(args?: SelectSubset<T, companiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Companies
     * const companies = await prisma.companies.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends companiesUpdateManyArgs>(args: SelectSubset<T, companiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Companies.
     * @param {companiesUpsertArgs} args - Arguments to update or create a Companies.
     * @example
     * // Update or create a Companies
     * const companies = await prisma.companies.upsert({
     *   create: {
     *     // ... data to create a Companies
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Companies we want to update
     *   }
     * })
     */
    upsert<T extends companiesUpsertArgs>(args: SelectSubset<T, companiesUpsertArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesCountArgs} args - Arguments to filter Companies to count.
     * @example
     * // Count the number of Companies
     * const count = await prisma.companies.count({
     *   where: {
     *     // ... the filter for the Companies we want to count
     *   }
     * })
    **/
    count<T extends companiesCountArgs>(
      args?: Subset<T, companiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CompaniesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CompaniesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CompaniesAggregateArgs>(args: Subset<T, CompaniesAggregateArgs>): Prisma.PrismaPromise<GetCompaniesAggregateType<T>>

    /**
     * Group by Companies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {companiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends companiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: companiesGroupByArgs['orderBy'] }
        : { orderBy?: companiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, companiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompaniesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the companies model
   */
  readonly fields: companiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for companies.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__companiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends companies$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, companies$categoriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company_frontend_settings<T extends companies$company_frontend_settingsArgs<ExtArgs> = {}>(args?: Subset<T, companies$company_frontend_settingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_frontend_settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company_integrations<T extends companies$company_integrationsArgs<ExtArgs> = {}>(args?: Subset<T, companies$company_integrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_integrationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company_profiles<T extends companies$company_profilesArgs<ExtArgs> = {}>(args?: Subset<T, companies$company_profilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_profilesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    company_subscriptions<T extends companies$company_subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, companies$company_subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_subscriptionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    integration_category_mappings<T extends companies$integration_category_mappingsArgs<ExtArgs> = {}>(args?: Subset<T, companies$integration_category_mappingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$integration_category_mappingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    offers<T extends companies$offersArgs<ExtArgs> = {}>(args?: Subset<T, companies$offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$offersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    stores<T extends companies$storesArgs<ExtArgs> = {}>(args?: Subset<T, companies$storesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    users<T extends companies$usersArgs<ExtArgs> = {}>(args?: Subset<T, companies$usersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the companies model
   */
  interface companiesFieldRefs {
    readonly id: FieldRef<"companies", 'BigInt'>
    readonly registration_no: FieldRef<"companies", 'String'>
    readonly vat: FieldRef<"companies", 'String'>
    readonly name: FieldRef<"companies", 'String'>
    readonly email: FieldRef<"companies", 'String'>
    readonly domain: FieldRef<"companies", 'String'>
    readonly status: FieldRef<"companies", 'Boolean'>
    readonly created_at: FieldRef<"companies", 'DateTime'>
    readonly updated_at: FieldRef<"companies", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * companies findUnique
   */
  export type companiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies findUniqueOrThrow
   */
  export type companiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies findFirst
   */
  export type companiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies findFirstOrThrow
   */
  export type companiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of companies.
     */
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies findMany
   */
  export type companiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter, which companies to fetch.
     */
    where?: companiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of companies to fetch.
     */
    orderBy?: companiesOrderByWithRelationInput | companiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing companies.
     */
    cursor?: companiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` companies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` companies.
     */
    skip?: number
    distinct?: CompaniesScalarFieldEnum | CompaniesScalarFieldEnum[]
  }

  /**
   * companies create
   */
  export type companiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The data needed to create a companies.
     */
    data: XOR<companiesCreateInput, companiesUncheckedCreateInput>
  }

  /**
   * companies createMany
   */
  export type companiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many companies.
     */
    data: companiesCreateManyInput | companiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * companies update
   */
  export type companiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The data needed to update a companies.
     */
    data: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
    /**
     * Choose, which companies to update.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies updateMany
   */
  export type companiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update companies.
     */
    data: XOR<companiesUpdateManyMutationInput, companiesUncheckedUpdateManyInput>
    /**
     * Filter which companies to update
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to update.
     */
    limit?: number
  }

  /**
   * companies upsert
   */
  export type companiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * The filter to search for the companies to update in case it exists.
     */
    where: companiesWhereUniqueInput
    /**
     * In case the companies found by the `where` argument doesn't exist, create a new companies with this data.
     */
    create: XOR<companiesCreateInput, companiesUncheckedCreateInput>
    /**
     * In case the companies was found with the provided `where` argument, update it with this data.
     */
    update: XOR<companiesUpdateInput, companiesUncheckedUpdateInput>
  }

  /**
   * companies delete
   */
  export type companiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    /**
     * Filter which companies to delete.
     */
    where: companiesWhereUniqueInput
  }

  /**
   * companies deleteMany
   */
  export type companiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which companies to delete
     */
    where?: companiesWhereInput
    /**
     * Limit how many companies to delete.
     */
    limit?: number
  }

  /**
   * companies.categories
   */
  export type companies$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
    orderBy?: categoriesOrderByWithRelationInput | categoriesOrderByWithRelationInput[]
    cursor?: categoriesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CategoriesScalarFieldEnum | CategoriesScalarFieldEnum[]
  }

  /**
   * companies.company_frontend_settings
   */
  export type companies$company_frontend_settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_frontend_settings
     */
    select?: company_frontend_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_frontend_settings
     */
    omit?: company_frontend_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_frontend_settingsInclude<ExtArgs> | null
    where?: company_frontend_settingsWhereInput
    orderBy?: company_frontend_settingsOrderByWithRelationInput | company_frontend_settingsOrderByWithRelationInput[]
    cursor?: company_frontend_settingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Company_frontend_settingsScalarFieldEnum | Company_frontend_settingsScalarFieldEnum[]
  }

  /**
   * companies.company_integrations
   */
  export type companies$company_integrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_integrations
     */
    select?: company_integrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_integrations
     */
    omit?: company_integrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_integrationsInclude<ExtArgs> | null
    where?: company_integrationsWhereInput
    orderBy?: company_integrationsOrderByWithRelationInput | company_integrationsOrderByWithRelationInput[]
    cursor?: company_integrationsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Company_integrationsScalarFieldEnum | Company_integrationsScalarFieldEnum[]
  }

  /**
   * companies.company_profiles
   */
  export type companies$company_profilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_profiles
     */
    select?: company_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_profiles
     */
    omit?: company_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_profilesInclude<ExtArgs> | null
    where?: company_profilesWhereInput
    orderBy?: company_profilesOrderByWithRelationInput | company_profilesOrderByWithRelationInput[]
    cursor?: company_profilesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Company_profilesScalarFieldEnum | Company_profilesScalarFieldEnum[]
  }

  /**
   * companies.company_subscriptions
   */
  export type companies$company_subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_subscriptions
     */
    select?: company_subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_subscriptions
     */
    omit?: company_subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_subscriptionsInclude<ExtArgs> | null
    where?: company_subscriptionsWhereInput
    orderBy?: company_subscriptionsOrderByWithRelationInput | company_subscriptionsOrderByWithRelationInput[]
    cursor?: company_subscriptionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Company_subscriptionsScalarFieldEnum | Company_subscriptionsScalarFieldEnum[]
  }

  /**
   * companies.integration_category_mappings
   */
  export type companies$integration_category_mappingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration_category_mappings
     */
    select?: integration_category_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration_category_mappings
     */
    omit?: integration_category_mappingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integration_category_mappingsInclude<ExtArgs> | null
    where?: integration_category_mappingsWhereInput
    orderBy?: integration_category_mappingsOrderByWithRelationInput | integration_category_mappingsOrderByWithRelationInput[]
    cursor?: integration_category_mappingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Integration_category_mappingsScalarFieldEnum | Integration_category_mappingsScalarFieldEnum[]
  }

  /**
   * companies.offers
   */
  export type companies$offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offers
     */
    select?: offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the offers
     */
    omit?: offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offersInclude<ExtArgs> | null
    where?: offersWhereInput
    orderBy?: offersOrderByWithRelationInput | offersOrderByWithRelationInput[]
    cursor?: offersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OffersScalarFieldEnum | OffersScalarFieldEnum[]
  }

  /**
   * companies.stores
   */
  export type companies$storesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    where?: storesWhereInput
    orderBy?: storesOrderByWithRelationInput | storesOrderByWithRelationInput[]
    cursor?: storesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * companies.users
   */
  export type companies$usersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: usersInclude<ExtArgs> | null
    where?: usersWhereInput
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    cursor?: usersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * companies without action
   */
  export type companiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
  }


  /**
   * Model company_frontend_settings
   */

  export type AggregateCompany_frontend_settings = {
    _count: Company_frontend_settingsCountAggregateOutputType | null
    _avg: Company_frontend_settingsAvgAggregateOutputType | null
    _sum: Company_frontend_settingsSumAggregateOutputType | null
    _min: Company_frontend_settingsMinAggregateOutputType | null
    _max: Company_frontend_settingsMaxAggregateOutputType | null
  }

  export type Company_frontend_settingsAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type Company_frontend_settingsSumAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
  }

  export type Company_frontend_settingsMinAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_frontend_settingsMaxAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_frontend_settingsCountAggregateOutputType = {
    id: number
    company_id: number
    settings: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Company_frontend_settingsAvgAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type Company_frontend_settingsSumAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type Company_frontend_settingsMinAggregateInputType = {
    id?: true
    company_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_frontend_settingsMaxAggregateInputType = {
    id?: true
    company_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_frontend_settingsCountAggregateInputType = {
    id?: true
    company_id?: true
    settings?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Company_frontend_settingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_frontend_settings to aggregate.
     */
    where?: company_frontend_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_frontend_settings to fetch.
     */
    orderBy?: company_frontend_settingsOrderByWithRelationInput | company_frontend_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: company_frontend_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_frontend_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_frontend_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_frontend_settings
    **/
    _count?: true | Company_frontend_settingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Company_frontend_settingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Company_frontend_settingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Company_frontend_settingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Company_frontend_settingsMaxAggregateInputType
  }

  export type GetCompany_frontend_settingsAggregateType<T extends Company_frontend_settingsAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany_frontend_settings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_frontend_settings[P]>
      : GetScalarType<T[P], AggregateCompany_frontend_settings[P]>
  }




  export type company_frontend_settingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_frontend_settingsWhereInput
    orderBy?: company_frontend_settingsOrderByWithAggregationInput | company_frontend_settingsOrderByWithAggregationInput[]
    by: Company_frontend_settingsScalarFieldEnum[] | Company_frontend_settingsScalarFieldEnum
    having?: company_frontend_settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Company_frontend_settingsCountAggregateInputType | true
    _avg?: Company_frontend_settingsAvgAggregateInputType
    _sum?: Company_frontend_settingsSumAggregateInputType
    _min?: Company_frontend_settingsMinAggregateInputType
    _max?: Company_frontend_settingsMaxAggregateInputType
  }

  export type Company_frontend_settingsGroupByOutputType = {
    id: bigint
    company_id: bigint
    settings: JsonValue | null
    created_at: Date | null
    updated_at: Date | null
    _count: Company_frontend_settingsCountAggregateOutputType | null
    _avg: Company_frontend_settingsAvgAggregateOutputType | null
    _sum: Company_frontend_settingsSumAggregateOutputType | null
    _min: Company_frontend_settingsMinAggregateOutputType | null
    _max: Company_frontend_settingsMaxAggregateOutputType | null
  }

  type GetCompany_frontend_settingsGroupByPayload<T extends company_frontend_settingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Company_frontend_settingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Company_frontend_settingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Company_frontend_settingsGroupByOutputType[P]>
            : GetScalarType<T[P], Company_frontend_settingsGroupByOutputType[P]>
        }
      >
    >


  export type company_frontend_settingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    settings?: boolean
    created_at?: boolean
    updated_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_frontend_settings"]>



  export type company_frontend_settingsSelectScalar = {
    id?: boolean
    company_id?: boolean
    settings?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type company_frontend_settingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "settings" | "created_at" | "updated_at", ExtArgs["result"]["company_frontend_settings"]>
  export type company_frontend_settingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $company_frontend_settingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company_frontend_settings"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      company_id: bigint
      settings: Prisma.JsonValue | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["company_frontend_settings"]>
    composites: {}
  }

  type company_frontend_settingsGetPayload<S extends boolean | null | undefined | company_frontend_settingsDefaultArgs> = $Result.GetResult<Prisma.$company_frontend_settingsPayload, S>

  type company_frontend_settingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<company_frontend_settingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Company_frontend_settingsCountAggregateInputType | true
    }

  export interface company_frontend_settingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company_frontend_settings'], meta: { name: 'company_frontend_settings' } }
    /**
     * Find zero or one Company_frontend_settings that matches the filter.
     * @param {company_frontend_settingsFindUniqueArgs} args - Arguments to find a Company_frontend_settings
     * @example
     * // Get one Company_frontend_settings
     * const company_frontend_settings = await prisma.company_frontend_settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends company_frontend_settingsFindUniqueArgs>(args: SelectSubset<T, company_frontend_settingsFindUniqueArgs<ExtArgs>>): Prisma__company_frontend_settingsClient<$Result.GetResult<Prisma.$company_frontend_settingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company_frontend_settings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {company_frontend_settingsFindUniqueOrThrowArgs} args - Arguments to find a Company_frontend_settings
     * @example
     * // Get one Company_frontend_settings
     * const company_frontend_settings = await prisma.company_frontend_settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends company_frontend_settingsFindUniqueOrThrowArgs>(args: SelectSubset<T, company_frontend_settingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__company_frontend_settingsClient<$Result.GetResult<Prisma.$company_frontend_settingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_frontend_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_frontend_settingsFindFirstArgs} args - Arguments to find a Company_frontend_settings
     * @example
     * // Get one Company_frontend_settings
     * const company_frontend_settings = await prisma.company_frontend_settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends company_frontend_settingsFindFirstArgs>(args?: SelectSubset<T, company_frontend_settingsFindFirstArgs<ExtArgs>>): Prisma__company_frontend_settingsClient<$Result.GetResult<Prisma.$company_frontend_settingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_frontend_settings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_frontend_settingsFindFirstOrThrowArgs} args - Arguments to find a Company_frontend_settings
     * @example
     * // Get one Company_frontend_settings
     * const company_frontend_settings = await prisma.company_frontend_settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends company_frontend_settingsFindFirstOrThrowArgs>(args?: SelectSubset<T, company_frontend_settingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__company_frontend_settingsClient<$Result.GetResult<Prisma.$company_frontend_settingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Company_frontend_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_frontend_settingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_frontend_settings
     * const company_frontend_settings = await prisma.company_frontend_settings.findMany()
     * 
     * // Get first 10 Company_frontend_settings
     * const company_frontend_settings = await prisma.company_frontend_settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const company_frontend_settingsWithIdOnly = await prisma.company_frontend_settings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends company_frontend_settingsFindManyArgs>(args?: SelectSubset<T, company_frontend_settingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_frontend_settingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company_frontend_settings.
     * @param {company_frontend_settingsCreateArgs} args - Arguments to create a Company_frontend_settings.
     * @example
     * // Create one Company_frontend_settings
     * const Company_frontend_settings = await prisma.company_frontend_settings.create({
     *   data: {
     *     // ... data to create a Company_frontend_settings
     *   }
     * })
     * 
     */
    create<T extends company_frontend_settingsCreateArgs>(args: SelectSubset<T, company_frontend_settingsCreateArgs<ExtArgs>>): Prisma__company_frontend_settingsClient<$Result.GetResult<Prisma.$company_frontend_settingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Company_frontend_settings.
     * @param {company_frontend_settingsCreateManyArgs} args - Arguments to create many Company_frontend_settings.
     * @example
     * // Create many Company_frontend_settings
     * const company_frontend_settings = await prisma.company_frontend_settings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends company_frontend_settingsCreateManyArgs>(args?: SelectSubset<T, company_frontend_settingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company_frontend_settings.
     * @param {company_frontend_settingsDeleteArgs} args - Arguments to delete one Company_frontend_settings.
     * @example
     * // Delete one Company_frontend_settings
     * const Company_frontend_settings = await prisma.company_frontend_settings.delete({
     *   where: {
     *     // ... filter to delete one Company_frontend_settings
     *   }
     * })
     * 
     */
    delete<T extends company_frontend_settingsDeleteArgs>(args: SelectSubset<T, company_frontend_settingsDeleteArgs<ExtArgs>>): Prisma__company_frontend_settingsClient<$Result.GetResult<Prisma.$company_frontend_settingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company_frontend_settings.
     * @param {company_frontend_settingsUpdateArgs} args - Arguments to update one Company_frontend_settings.
     * @example
     * // Update one Company_frontend_settings
     * const company_frontend_settings = await prisma.company_frontend_settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends company_frontend_settingsUpdateArgs>(args: SelectSubset<T, company_frontend_settingsUpdateArgs<ExtArgs>>): Prisma__company_frontend_settingsClient<$Result.GetResult<Prisma.$company_frontend_settingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Company_frontend_settings.
     * @param {company_frontend_settingsDeleteManyArgs} args - Arguments to filter Company_frontend_settings to delete.
     * @example
     * // Delete a few Company_frontend_settings
     * const { count } = await prisma.company_frontend_settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends company_frontend_settingsDeleteManyArgs>(args?: SelectSubset<T, company_frontend_settingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_frontend_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_frontend_settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_frontend_settings
     * const company_frontend_settings = await prisma.company_frontend_settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends company_frontend_settingsUpdateManyArgs>(args: SelectSubset<T, company_frontend_settingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company_frontend_settings.
     * @param {company_frontend_settingsUpsertArgs} args - Arguments to update or create a Company_frontend_settings.
     * @example
     * // Update or create a Company_frontend_settings
     * const company_frontend_settings = await prisma.company_frontend_settings.upsert({
     *   create: {
     *     // ... data to create a Company_frontend_settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_frontend_settings we want to update
     *   }
     * })
     */
    upsert<T extends company_frontend_settingsUpsertArgs>(args: SelectSubset<T, company_frontend_settingsUpsertArgs<ExtArgs>>): Prisma__company_frontend_settingsClient<$Result.GetResult<Prisma.$company_frontend_settingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Company_frontend_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_frontend_settingsCountArgs} args - Arguments to filter Company_frontend_settings to count.
     * @example
     * // Count the number of Company_frontend_settings
     * const count = await prisma.company_frontend_settings.count({
     *   where: {
     *     // ... the filter for the Company_frontend_settings we want to count
     *   }
     * })
    **/
    count<T extends company_frontend_settingsCountArgs>(
      args?: Subset<T, company_frontend_settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_frontend_settingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_frontend_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Company_frontend_settingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_frontend_settingsAggregateArgs>(args: Subset<T, Company_frontend_settingsAggregateArgs>): Prisma.PrismaPromise<GetCompany_frontend_settingsAggregateType<T>>

    /**
     * Group by Company_frontend_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_frontend_settingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends company_frontend_settingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: company_frontend_settingsGroupByArgs['orderBy'] }
        : { orderBy?: company_frontend_settingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, company_frontend_settingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompany_frontend_settingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company_frontend_settings model
   */
  readonly fields: company_frontend_settingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company_frontend_settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__company_frontend_settingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the company_frontend_settings model
   */
  interface company_frontend_settingsFieldRefs {
    readonly id: FieldRef<"company_frontend_settings", 'BigInt'>
    readonly company_id: FieldRef<"company_frontend_settings", 'BigInt'>
    readonly settings: FieldRef<"company_frontend_settings", 'Json'>
    readonly created_at: FieldRef<"company_frontend_settings", 'DateTime'>
    readonly updated_at: FieldRef<"company_frontend_settings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * company_frontend_settings findUnique
   */
  export type company_frontend_settingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_frontend_settings
     */
    select?: company_frontend_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_frontend_settings
     */
    omit?: company_frontend_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_frontend_settingsInclude<ExtArgs> | null
    /**
     * Filter, which company_frontend_settings to fetch.
     */
    where: company_frontend_settingsWhereUniqueInput
  }

  /**
   * company_frontend_settings findUniqueOrThrow
   */
  export type company_frontend_settingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_frontend_settings
     */
    select?: company_frontend_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_frontend_settings
     */
    omit?: company_frontend_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_frontend_settingsInclude<ExtArgs> | null
    /**
     * Filter, which company_frontend_settings to fetch.
     */
    where: company_frontend_settingsWhereUniqueInput
  }

  /**
   * company_frontend_settings findFirst
   */
  export type company_frontend_settingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_frontend_settings
     */
    select?: company_frontend_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_frontend_settings
     */
    omit?: company_frontend_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_frontend_settingsInclude<ExtArgs> | null
    /**
     * Filter, which company_frontend_settings to fetch.
     */
    where?: company_frontend_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_frontend_settings to fetch.
     */
    orderBy?: company_frontend_settingsOrderByWithRelationInput | company_frontend_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_frontend_settings.
     */
    cursor?: company_frontend_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_frontend_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_frontend_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_frontend_settings.
     */
    distinct?: Company_frontend_settingsScalarFieldEnum | Company_frontend_settingsScalarFieldEnum[]
  }

  /**
   * company_frontend_settings findFirstOrThrow
   */
  export type company_frontend_settingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_frontend_settings
     */
    select?: company_frontend_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_frontend_settings
     */
    omit?: company_frontend_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_frontend_settingsInclude<ExtArgs> | null
    /**
     * Filter, which company_frontend_settings to fetch.
     */
    where?: company_frontend_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_frontend_settings to fetch.
     */
    orderBy?: company_frontend_settingsOrderByWithRelationInput | company_frontend_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_frontend_settings.
     */
    cursor?: company_frontend_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_frontend_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_frontend_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_frontend_settings.
     */
    distinct?: Company_frontend_settingsScalarFieldEnum | Company_frontend_settingsScalarFieldEnum[]
  }

  /**
   * company_frontend_settings findMany
   */
  export type company_frontend_settingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_frontend_settings
     */
    select?: company_frontend_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_frontend_settings
     */
    omit?: company_frontend_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_frontend_settingsInclude<ExtArgs> | null
    /**
     * Filter, which company_frontend_settings to fetch.
     */
    where?: company_frontend_settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_frontend_settings to fetch.
     */
    orderBy?: company_frontend_settingsOrderByWithRelationInput | company_frontend_settingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_frontend_settings.
     */
    cursor?: company_frontend_settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_frontend_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_frontend_settings.
     */
    skip?: number
    distinct?: Company_frontend_settingsScalarFieldEnum | Company_frontend_settingsScalarFieldEnum[]
  }

  /**
   * company_frontend_settings create
   */
  export type company_frontend_settingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_frontend_settings
     */
    select?: company_frontend_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_frontend_settings
     */
    omit?: company_frontend_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_frontend_settingsInclude<ExtArgs> | null
    /**
     * The data needed to create a company_frontend_settings.
     */
    data: XOR<company_frontend_settingsCreateInput, company_frontend_settingsUncheckedCreateInput>
  }

  /**
   * company_frontend_settings createMany
   */
  export type company_frontend_settingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many company_frontend_settings.
     */
    data: company_frontend_settingsCreateManyInput | company_frontend_settingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_frontend_settings update
   */
  export type company_frontend_settingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_frontend_settings
     */
    select?: company_frontend_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_frontend_settings
     */
    omit?: company_frontend_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_frontend_settingsInclude<ExtArgs> | null
    /**
     * The data needed to update a company_frontend_settings.
     */
    data: XOR<company_frontend_settingsUpdateInput, company_frontend_settingsUncheckedUpdateInput>
    /**
     * Choose, which company_frontend_settings to update.
     */
    where: company_frontend_settingsWhereUniqueInput
  }

  /**
   * company_frontend_settings updateMany
   */
  export type company_frontend_settingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update company_frontend_settings.
     */
    data: XOR<company_frontend_settingsUpdateManyMutationInput, company_frontend_settingsUncheckedUpdateManyInput>
    /**
     * Filter which company_frontend_settings to update
     */
    where?: company_frontend_settingsWhereInput
    /**
     * Limit how many company_frontend_settings to update.
     */
    limit?: number
  }

  /**
   * company_frontend_settings upsert
   */
  export type company_frontend_settingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_frontend_settings
     */
    select?: company_frontend_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_frontend_settings
     */
    omit?: company_frontend_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_frontend_settingsInclude<ExtArgs> | null
    /**
     * The filter to search for the company_frontend_settings to update in case it exists.
     */
    where: company_frontend_settingsWhereUniqueInput
    /**
     * In case the company_frontend_settings found by the `where` argument doesn't exist, create a new company_frontend_settings with this data.
     */
    create: XOR<company_frontend_settingsCreateInput, company_frontend_settingsUncheckedCreateInput>
    /**
     * In case the company_frontend_settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<company_frontend_settingsUpdateInput, company_frontend_settingsUncheckedUpdateInput>
  }

  /**
   * company_frontend_settings delete
   */
  export type company_frontend_settingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_frontend_settings
     */
    select?: company_frontend_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_frontend_settings
     */
    omit?: company_frontend_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_frontend_settingsInclude<ExtArgs> | null
    /**
     * Filter which company_frontend_settings to delete.
     */
    where: company_frontend_settingsWhereUniqueInput
  }

  /**
   * company_frontend_settings deleteMany
   */
  export type company_frontend_settingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_frontend_settings to delete
     */
    where?: company_frontend_settingsWhereInput
    /**
     * Limit how many company_frontend_settings to delete.
     */
    limit?: number
  }

  /**
   * company_frontend_settings without action
   */
  export type company_frontend_settingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_frontend_settings
     */
    select?: company_frontend_settingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_frontend_settings
     */
    omit?: company_frontend_settingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_frontend_settingsInclude<ExtArgs> | null
  }


  /**
   * Model company_integrations
   */

  export type AggregateCompany_integrations = {
    _count: Company_integrationsCountAggregateOutputType | null
    _avg: Company_integrationsAvgAggregateOutputType | null
    _sum: Company_integrationsSumAggregateOutputType | null
    _min: Company_integrationsMinAggregateOutputType | null
    _max: Company_integrationsMaxAggregateOutputType | null
  }

  export type Company_integrationsAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type Company_integrationsSumAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
  }

  export type Company_integrationsMinAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
    provider: string | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_integrationsMaxAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
    provider: string | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_integrationsCountAggregateOutputType = {
    id: number
    company_id: number
    provider: number
    credentials: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Company_integrationsAvgAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type Company_integrationsSumAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type Company_integrationsMinAggregateInputType = {
    id?: true
    company_id?: true
    provider?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_integrationsMaxAggregateInputType = {
    id?: true
    company_id?: true
    provider?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_integrationsCountAggregateInputType = {
    id?: true
    company_id?: true
    provider?: true
    credentials?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Company_integrationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_integrations to aggregate.
     */
    where?: company_integrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_integrations to fetch.
     */
    orderBy?: company_integrationsOrderByWithRelationInput | company_integrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: company_integrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_integrations
    **/
    _count?: true | Company_integrationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Company_integrationsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Company_integrationsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Company_integrationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Company_integrationsMaxAggregateInputType
  }

  export type GetCompany_integrationsAggregateType<T extends Company_integrationsAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany_integrations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_integrations[P]>
      : GetScalarType<T[P], AggregateCompany_integrations[P]>
  }




  export type company_integrationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_integrationsWhereInput
    orderBy?: company_integrationsOrderByWithAggregationInput | company_integrationsOrderByWithAggregationInput[]
    by: Company_integrationsScalarFieldEnum[] | Company_integrationsScalarFieldEnum
    having?: company_integrationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Company_integrationsCountAggregateInputType | true
    _avg?: Company_integrationsAvgAggregateInputType
    _sum?: Company_integrationsSumAggregateInputType
    _min?: Company_integrationsMinAggregateInputType
    _max?: Company_integrationsMaxAggregateInputType
  }

  export type Company_integrationsGroupByOutputType = {
    id: bigint
    company_id: bigint
    provider: string
    credentials: JsonValue
    status: boolean
    created_at: Date | null
    updated_at: Date | null
    _count: Company_integrationsCountAggregateOutputType | null
    _avg: Company_integrationsAvgAggregateOutputType | null
    _sum: Company_integrationsSumAggregateOutputType | null
    _min: Company_integrationsMinAggregateOutputType | null
    _max: Company_integrationsMaxAggregateOutputType | null
  }

  type GetCompany_integrationsGroupByPayload<T extends company_integrationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Company_integrationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Company_integrationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Company_integrationsGroupByOutputType[P]>
            : GetScalarType<T[P], Company_integrationsGroupByOutputType[P]>
        }
      >
    >


  export type company_integrationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    provider?: boolean
    credentials?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_integrations"]>



  export type company_integrationsSelectScalar = {
    id?: boolean
    company_id?: boolean
    provider?: boolean
    credentials?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type company_integrationsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "provider" | "credentials" | "status" | "created_at" | "updated_at", ExtArgs["result"]["company_integrations"]>
  export type company_integrationsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $company_integrationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company_integrations"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      company_id: bigint
      provider: string
      credentials: Prisma.JsonValue
      status: boolean
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["company_integrations"]>
    composites: {}
  }

  type company_integrationsGetPayload<S extends boolean | null | undefined | company_integrationsDefaultArgs> = $Result.GetResult<Prisma.$company_integrationsPayload, S>

  type company_integrationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<company_integrationsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Company_integrationsCountAggregateInputType | true
    }

  export interface company_integrationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company_integrations'], meta: { name: 'company_integrations' } }
    /**
     * Find zero or one Company_integrations that matches the filter.
     * @param {company_integrationsFindUniqueArgs} args - Arguments to find a Company_integrations
     * @example
     * // Get one Company_integrations
     * const company_integrations = await prisma.company_integrations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends company_integrationsFindUniqueArgs>(args: SelectSubset<T, company_integrationsFindUniqueArgs<ExtArgs>>): Prisma__company_integrationsClient<$Result.GetResult<Prisma.$company_integrationsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company_integrations that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {company_integrationsFindUniqueOrThrowArgs} args - Arguments to find a Company_integrations
     * @example
     * // Get one Company_integrations
     * const company_integrations = await prisma.company_integrations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends company_integrationsFindUniqueOrThrowArgs>(args: SelectSubset<T, company_integrationsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__company_integrationsClient<$Result.GetResult<Prisma.$company_integrationsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_integrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_integrationsFindFirstArgs} args - Arguments to find a Company_integrations
     * @example
     * // Get one Company_integrations
     * const company_integrations = await prisma.company_integrations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends company_integrationsFindFirstArgs>(args?: SelectSubset<T, company_integrationsFindFirstArgs<ExtArgs>>): Prisma__company_integrationsClient<$Result.GetResult<Prisma.$company_integrationsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_integrations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_integrationsFindFirstOrThrowArgs} args - Arguments to find a Company_integrations
     * @example
     * // Get one Company_integrations
     * const company_integrations = await prisma.company_integrations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends company_integrationsFindFirstOrThrowArgs>(args?: SelectSubset<T, company_integrationsFindFirstOrThrowArgs<ExtArgs>>): Prisma__company_integrationsClient<$Result.GetResult<Prisma.$company_integrationsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Company_integrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_integrationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_integrations
     * const company_integrations = await prisma.company_integrations.findMany()
     * 
     * // Get first 10 Company_integrations
     * const company_integrations = await prisma.company_integrations.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const company_integrationsWithIdOnly = await prisma.company_integrations.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends company_integrationsFindManyArgs>(args?: SelectSubset<T, company_integrationsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_integrationsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company_integrations.
     * @param {company_integrationsCreateArgs} args - Arguments to create a Company_integrations.
     * @example
     * // Create one Company_integrations
     * const Company_integrations = await prisma.company_integrations.create({
     *   data: {
     *     // ... data to create a Company_integrations
     *   }
     * })
     * 
     */
    create<T extends company_integrationsCreateArgs>(args: SelectSubset<T, company_integrationsCreateArgs<ExtArgs>>): Prisma__company_integrationsClient<$Result.GetResult<Prisma.$company_integrationsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Company_integrations.
     * @param {company_integrationsCreateManyArgs} args - Arguments to create many Company_integrations.
     * @example
     * // Create many Company_integrations
     * const company_integrations = await prisma.company_integrations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends company_integrationsCreateManyArgs>(args?: SelectSubset<T, company_integrationsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company_integrations.
     * @param {company_integrationsDeleteArgs} args - Arguments to delete one Company_integrations.
     * @example
     * // Delete one Company_integrations
     * const Company_integrations = await prisma.company_integrations.delete({
     *   where: {
     *     // ... filter to delete one Company_integrations
     *   }
     * })
     * 
     */
    delete<T extends company_integrationsDeleteArgs>(args: SelectSubset<T, company_integrationsDeleteArgs<ExtArgs>>): Prisma__company_integrationsClient<$Result.GetResult<Prisma.$company_integrationsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company_integrations.
     * @param {company_integrationsUpdateArgs} args - Arguments to update one Company_integrations.
     * @example
     * // Update one Company_integrations
     * const company_integrations = await prisma.company_integrations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends company_integrationsUpdateArgs>(args: SelectSubset<T, company_integrationsUpdateArgs<ExtArgs>>): Prisma__company_integrationsClient<$Result.GetResult<Prisma.$company_integrationsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Company_integrations.
     * @param {company_integrationsDeleteManyArgs} args - Arguments to filter Company_integrations to delete.
     * @example
     * // Delete a few Company_integrations
     * const { count } = await prisma.company_integrations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends company_integrationsDeleteManyArgs>(args?: SelectSubset<T, company_integrationsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_integrationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_integrations
     * const company_integrations = await prisma.company_integrations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends company_integrationsUpdateManyArgs>(args: SelectSubset<T, company_integrationsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company_integrations.
     * @param {company_integrationsUpsertArgs} args - Arguments to update or create a Company_integrations.
     * @example
     * // Update or create a Company_integrations
     * const company_integrations = await prisma.company_integrations.upsert({
     *   create: {
     *     // ... data to create a Company_integrations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_integrations we want to update
     *   }
     * })
     */
    upsert<T extends company_integrationsUpsertArgs>(args: SelectSubset<T, company_integrationsUpsertArgs<ExtArgs>>): Prisma__company_integrationsClient<$Result.GetResult<Prisma.$company_integrationsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Company_integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_integrationsCountArgs} args - Arguments to filter Company_integrations to count.
     * @example
     * // Count the number of Company_integrations
     * const count = await prisma.company_integrations.count({
     *   where: {
     *     // ... the filter for the Company_integrations we want to count
     *   }
     * })
    **/
    count<T extends company_integrationsCountArgs>(
      args?: Subset<T, company_integrationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_integrationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Company_integrationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_integrationsAggregateArgs>(args: Subset<T, Company_integrationsAggregateArgs>): Prisma.PrismaPromise<GetCompany_integrationsAggregateType<T>>

    /**
     * Group by Company_integrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_integrationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends company_integrationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: company_integrationsGroupByArgs['orderBy'] }
        : { orderBy?: company_integrationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, company_integrationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompany_integrationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company_integrations model
   */
  readonly fields: company_integrationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company_integrations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__company_integrationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the company_integrations model
   */
  interface company_integrationsFieldRefs {
    readonly id: FieldRef<"company_integrations", 'BigInt'>
    readonly company_id: FieldRef<"company_integrations", 'BigInt'>
    readonly provider: FieldRef<"company_integrations", 'String'>
    readonly credentials: FieldRef<"company_integrations", 'Json'>
    readonly status: FieldRef<"company_integrations", 'Boolean'>
    readonly created_at: FieldRef<"company_integrations", 'DateTime'>
    readonly updated_at: FieldRef<"company_integrations", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * company_integrations findUnique
   */
  export type company_integrationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_integrations
     */
    select?: company_integrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_integrations
     */
    omit?: company_integrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_integrationsInclude<ExtArgs> | null
    /**
     * Filter, which company_integrations to fetch.
     */
    where: company_integrationsWhereUniqueInput
  }

  /**
   * company_integrations findUniqueOrThrow
   */
  export type company_integrationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_integrations
     */
    select?: company_integrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_integrations
     */
    omit?: company_integrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_integrationsInclude<ExtArgs> | null
    /**
     * Filter, which company_integrations to fetch.
     */
    where: company_integrationsWhereUniqueInput
  }

  /**
   * company_integrations findFirst
   */
  export type company_integrationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_integrations
     */
    select?: company_integrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_integrations
     */
    omit?: company_integrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_integrationsInclude<ExtArgs> | null
    /**
     * Filter, which company_integrations to fetch.
     */
    where?: company_integrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_integrations to fetch.
     */
    orderBy?: company_integrationsOrderByWithRelationInput | company_integrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_integrations.
     */
    cursor?: company_integrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_integrations.
     */
    distinct?: Company_integrationsScalarFieldEnum | Company_integrationsScalarFieldEnum[]
  }

  /**
   * company_integrations findFirstOrThrow
   */
  export type company_integrationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_integrations
     */
    select?: company_integrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_integrations
     */
    omit?: company_integrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_integrationsInclude<ExtArgs> | null
    /**
     * Filter, which company_integrations to fetch.
     */
    where?: company_integrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_integrations to fetch.
     */
    orderBy?: company_integrationsOrderByWithRelationInput | company_integrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_integrations.
     */
    cursor?: company_integrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_integrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_integrations.
     */
    distinct?: Company_integrationsScalarFieldEnum | Company_integrationsScalarFieldEnum[]
  }

  /**
   * company_integrations findMany
   */
  export type company_integrationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_integrations
     */
    select?: company_integrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_integrations
     */
    omit?: company_integrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_integrationsInclude<ExtArgs> | null
    /**
     * Filter, which company_integrations to fetch.
     */
    where?: company_integrationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_integrations to fetch.
     */
    orderBy?: company_integrationsOrderByWithRelationInput | company_integrationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_integrations.
     */
    cursor?: company_integrationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_integrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_integrations.
     */
    skip?: number
    distinct?: Company_integrationsScalarFieldEnum | Company_integrationsScalarFieldEnum[]
  }

  /**
   * company_integrations create
   */
  export type company_integrationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_integrations
     */
    select?: company_integrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_integrations
     */
    omit?: company_integrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_integrationsInclude<ExtArgs> | null
    /**
     * The data needed to create a company_integrations.
     */
    data: XOR<company_integrationsCreateInput, company_integrationsUncheckedCreateInput>
  }

  /**
   * company_integrations createMany
   */
  export type company_integrationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many company_integrations.
     */
    data: company_integrationsCreateManyInput | company_integrationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_integrations update
   */
  export type company_integrationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_integrations
     */
    select?: company_integrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_integrations
     */
    omit?: company_integrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_integrationsInclude<ExtArgs> | null
    /**
     * The data needed to update a company_integrations.
     */
    data: XOR<company_integrationsUpdateInput, company_integrationsUncheckedUpdateInput>
    /**
     * Choose, which company_integrations to update.
     */
    where: company_integrationsWhereUniqueInput
  }

  /**
   * company_integrations updateMany
   */
  export type company_integrationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update company_integrations.
     */
    data: XOR<company_integrationsUpdateManyMutationInput, company_integrationsUncheckedUpdateManyInput>
    /**
     * Filter which company_integrations to update
     */
    where?: company_integrationsWhereInput
    /**
     * Limit how many company_integrations to update.
     */
    limit?: number
  }

  /**
   * company_integrations upsert
   */
  export type company_integrationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_integrations
     */
    select?: company_integrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_integrations
     */
    omit?: company_integrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_integrationsInclude<ExtArgs> | null
    /**
     * The filter to search for the company_integrations to update in case it exists.
     */
    where: company_integrationsWhereUniqueInput
    /**
     * In case the company_integrations found by the `where` argument doesn't exist, create a new company_integrations with this data.
     */
    create: XOR<company_integrationsCreateInput, company_integrationsUncheckedCreateInput>
    /**
     * In case the company_integrations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<company_integrationsUpdateInput, company_integrationsUncheckedUpdateInput>
  }

  /**
   * company_integrations delete
   */
  export type company_integrationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_integrations
     */
    select?: company_integrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_integrations
     */
    omit?: company_integrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_integrationsInclude<ExtArgs> | null
    /**
     * Filter which company_integrations to delete.
     */
    where: company_integrationsWhereUniqueInput
  }

  /**
   * company_integrations deleteMany
   */
  export type company_integrationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_integrations to delete
     */
    where?: company_integrationsWhereInput
    /**
     * Limit how many company_integrations to delete.
     */
    limit?: number
  }

  /**
   * company_integrations without action
   */
  export type company_integrationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_integrations
     */
    select?: company_integrationsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_integrations
     */
    omit?: company_integrationsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_integrationsInclude<ExtArgs> | null
  }


  /**
   * Model company_profiles
   */

  export type AggregateCompany_profiles = {
    _count: Company_profilesCountAggregateOutputType | null
    _avg: Company_profilesAvgAggregateOutputType | null
    _sum: Company_profilesSumAggregateOutputType | null
    _min: Company_profilesMinAggregateOutputType | null
    _max: Company_profilesMaxAggregateOutputType | null
  }

  export type Company_profilesAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
  }

  export type Company_profilesSumAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
  }

  export type Company_profilesMinAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
    phone: string | null
    address: string | null
    country: string | null
    zipcode: string | null
    city: string | null
    state: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_profilesMaxAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
    phone: string | null
    address: string | null
    country: string | null
    zipcode: string | null
    city: string | null
    state: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_profilesCountAggregateOutputType = {
    id: number
    company_id: number
    phone: number
    address: number
    country: number
    zipcode: number
    city: number
    state: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Company_profilesAvgAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type Company_profilesSumAggregateInputType = {
    id?: true
    company_id?: true
  }

  export type Company_profilesMinAggregateInputType = {
    id?: true
    company_id?: true
    phone?: true
    address?: true
    country?: true
    zipcode?: true
    city?: true
    state?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_profilesMaxAggregateInputType = {
    id?: true
    company_id?: true
    phone?: true
    address?: true
    country?: true
    zipcode?: true
    city?: true
    state?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_profilesCountAggregateInputType = {
    id?: true
    company_id?: true
    phone?: true
    address?: true
    country?: true
    zipcode?: true
    city?: true
    state?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Company_profilesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_profiles to aggregate.
     */
    where?: company_profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_profiles to fetch.
     */
    orderBy?: company_profilesOrderByWithRelationInput | company_profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: company_profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_profiles
    **/
    _count?: true | Company_profilesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Company_profilesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Company_profilesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Company_profilesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Company_profilesMaxAggregateInputType
  }

  export type GetCompany_profilesAggregateType<T extends Company_profilesAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany_profiles]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_profiles[P]>
      : GetScalarType<T[P], AggregateCompany_profiles[P]>
  }




  export type company_profilesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_profilesWhereInput
    orderBy?: company_profilesOrderByWithAggregationInput | company_profilesOrderByWithAggregationInput[]
    by: Company_profilesScalarFieldEnum[] | Company_profilesScalarFieldEnum
    having?: company_profilesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Company_profilesCountAggregateInputType | true
    _avg?: Company_profilesAvgAggregateInputType
    _sum?: Company_profilesSumAggregateInputType
    _min?: Company_profilesMinAggregateInputType
    _max?: Company_profilesMaxAggregateInputType
  }

  export type Company_profilesGroupByOutputType = {
    id: bigint
    company_id: bigint
    phone: string | null
    address: string | null
    country: string | null
    zipcode: string | null
    city: string | null
    state: string | null
    created_at: Date | null
    updated_at: Date | null
    _count: Company_profilesCountAggregateOutputType | null
    _avg: Company_profilesAvgAggregateOutputType | null
    _sum: Company_profilesSumAggregateOutputType | null
    _min: Company_profilesMinAggregateOutputType | null
    _max: Company_profilesMaxAggregateOutputType | null
  }

  type GetCompany_profilesGroupByPayload<T extends company_profilesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Company_profilesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Company_profilesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Company_profilesGroupByOutputType[P]>
            : GetScalarType<T[P], Company_profilesGroupByOutputType[P]>
        }
      >
    >


  export type company_profilesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    phone?: boolean
    address?: boolean
    country?: boolean
    zipcode?: boolean
    city?: boolean
    state?: boolean
    created_at?: boolean
    updated_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_profiles"]>



  export type company_profilesSelectScalar = {
    id?: boolean
    company_id?: boolean
    phone?: boolean
    address?: boolean
    country?: boolean
    zipcode?: boolean
    city?: boolean
    state?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type company_profilesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "phone" | "address" | "country" | "zipcode" | "city" | "state" | "created_at" | "updated_at", ExtArgs["result"]["company_profiles"]>
  export type company_profilesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
  }

  export type $company_profilesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company_profiles"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      company_id: bigint
      phone: string | null
      address: string | null
      country: string | null
      zipcode: string | null
      city: string | null
      state: string | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["company_profiles"]>
    composites: {}
  }

  type company_profilesGetPayload<S extends boolean | null | undefined | company_profilesDefaultArgs> = $Result.GetResult<Prisma.$company_profilesPayload, S>

  type company_profilesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<company_profilesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Company_profilesCountAggregateInputType | true
    }

  export interface company_profilesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company_profiles'], meta: { name: 'company_profiles' } }
    /**
     * Find zero or one Company_profiles that matches the filter.
     * @param {company_profilesFindUniqueArgs} args - Arguments to find a Company_profiles
     * @example
     * // Get one Company_profiles
     * const company_profiles = await prisma.company_profiles.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends company_profilesFindUniqueArgs>(args: SelectSubset<T, company_profilesFindUniqueArgs<ExtArgs>>): Prisma__company_profilesClient<$Result.GetResult<Prisma.$company_profilesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company_profiles that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {company_profilesFindUniqueOrThrowArgs} args - Arguments to find a Company_profiles
     * @example
     * // Get one Company_profiles
     * const company_profiles = await prisma.company_profiles.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends company_profilesFindUniqueOrThrowArgs>(args: SelectSubset<T, company_profilesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__company_profilesClient<$Result.GetResult<Prisma.$company_profilesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_profilesFindFirstArgs} args - Arguments to find a Company_profiles
     * @example
     * // Get one Company_profiles
     * const company_profiles = await prisma.company_profiles.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends company_profilesFindFirstArgs>(args?: SelectSubset<T, company_profilesFindFirstArgs<ExtArgs>>): Prisma__company_profilesClient<$Result.GetResult<Prisma.$company_profilesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_profiles that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_profilesFindFirstOrThrowArgs} args - Arguments to find a Company_profiles
     * @example
     * // Get one Company_profiles
     * const company_profiles = await prisma.company_profiles.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends company_profilesFindFirstOrThrowArgs>(args?: SelectSubset<T, company_profilesFindFirstOrThrowArgs<ExtArgs>>): Prisma__company_profilesClient<$Result.GetResult<Prisma.$company_profilesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Company_profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_profilesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_profiles
     * const company_profiles = await prisma.company_profiles.findMany()
     * 
     * // Get first 10 Company_profiles
     * const company_profiles = await prisma.company_profiles.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const company_profilesWithIdOnly = await prisma.company_profiles.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends company_profilesFindManyArgs>(args?: SelectSubset<T, company_profilesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_profilesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company_profiles.
     * @param {company_profilesCreateArgs} args - Arguments to create a Company_profiles.
     * @example
     * // Create one Company_profiles
     * const Company_profiles = await prisma.company_profiles.create({
     *   data: {
     *     // ... data to create a Company_profiles
     *   }
     * })
     * 
     */
    create<T extends company_profilesCreateArgs>(args: SelectSubset<T, company_profilesCreateArgs<ExtArgs>>): Prisma__company_profilesClient<$Result.GetResult<Prisma.$company_profilesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Company_profiles.
     * @param {company_profilesCreateManyArgs} args - Arguments to create many Company_profiles.
     * @example
     * // Create many Company_profiles
     * const company_profiles = await prisma.company_profiles.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends company_profilesCreateManyArgs>(args?: SelectSubset<T, company_profilesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company_profiles.
     * @param {company_profilesDeleteArgs} args - Arguments to delete one Company_profiles.
     * @example
     * // Delete one Company_profiles
     * const Company_profiles = await prisma.company_profiles.delete({
     *   where: {
     *     // ... filter to delete one Company_profiles
     *   }
     * })
     * 
     */
    delete<T extends company_profilesDeleteArgs>(args: SelectSubset<T, company_profilesDeleteArgs<ExtArgs>>): Prisma__company_profilesClient<$Result.GetResult<Prisma.$company_profilesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company_profiles.
     * @param {company_profilesUpdateArgs} args - Arguments to update one Company_profiles.
     * @example
     * // Update one Company_profiles
     * const company_profiles = await prisma.company_profiles.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends company_profilesUpdateArgs>(args: SelectSubset<T, company_profilesUpdateArgs<ExtArgs>>): Prisma__company_profilesClient<$Result.GetResult<Prisma.$company_profilesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Company_profiles.
     * @param {company_profilesDeleteManyArgs} args - Arguments to filter Company_profiles to delete.
     * @example
     * // Delete a few Company_profiles
     * const { count } = await prisma.company_profiles.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends company_profilesDeleteManyArgs>(args?: SelectSubset<T, company_profilesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_profilesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_profiles
     * const company_profiles = await prisma.company_profiles.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends company_profilesUpdateManyArgs>(args: SelectSubset<T, company_profilesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company_profiles.
     * @param {company_profilesUpsertArgs} args - Arguments to update or create a Company_profiles.
     * @example
     * // Update or create a Company_profiles
     * const company_profiles = await prisma.company_profiles.upsert({
     *   create: {
     *     // ... data to create a Company_profiles
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_profiles we want to update
     *   }
     * })
     */
    upsert<T extends company_profilesUpsertArgs>(args: SelectSubset<T, company_profilesUpsertArgs<ExtArgs>>): Prisma__company_profilesClient<$Result.GetResult<Prisma.$company_profilesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Company_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_profilesCountArgs} args - Arguments to filter Company_profiles to count.
     * @example
     * // Count the number of Company_profiles
     * const count = await prisma.company_profiles.count({
     *   where: {
     *     // ... the filter for the Company_profiles we want to count
     *   }
     * })
    **/
    count<T extends company_profilesCountArgs>(
      args?: Subset<T, company_profilesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_profilesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Company_profilesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_profilesAggregateArgs>(args: Subset<T, Company_profilesAggregateArgs>): Prisma.PrismaPromise<GetCompany_profilesAggregateType<T>>

    /**
     * Group by Company_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_profilesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends company_profilesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: company_profilesGroupByArgs['orderBy'] }
        : { orderBy?: company_profilesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, company_profilesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompany_profilesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company_profiles model
   */
  readonly fields: company_profilesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company_profiles.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__company_profilesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the company_profiles model
   */
  interface company_profilesFieldRefs {
    readonly id: FieldRef<"company_profiles", 'BigInt'>
    readonly company_id: FieldRef<"company_profiles", 'BigInt'>
    readonly phone: FieldRef<"company_profiles", 'String'>
    readonly address: FieldRef<"company_profiles", 'String'>
    readonly country: FieldRef<"company_profiles", 'String'>
    readonly zipcode: FieldRef<"company_profiles", 'String'>
    readonly city: FieldRef<"company_profiles", 'String'>
    readonly state: FieldRef<"company_profiles", 'String'>
    readonly created_at: FieldRef<"company_profiles", 'DateTime'>
    readonly updated_at: FieldRef<"company_profiles", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * company_profiles findUnique
   */
  export type company_profilesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_profiles
     */
    select?: company_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_profiles
     */
    omit?: company_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_profilesInclude<ExtArgs> | null
    /**
     * Filter, which company_profiles to fetch.
     */
    where: company_profilesWhereUniqueInput
  }

  /**
   * company_profiles findUniqueOrThrow
   */
  export type company_profilesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_profiles
     */
    select?: company_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_profiles
     */
    omit?: company_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_profilesInclude<ExtArgs> | null
    /**
     * Filter, which company_profiles to fetch.
     */
    where: company_profilesWhereUniqueInput
  }

  /**
   * company_profiles findFirst
   */
  export type company_profilesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_profiles
     */
    select?: company_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_profiles
     */
    omit?: company_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_profilesInclude<ExtArgs> | null
    /**
     * Filter, which company_profiles to fetch.
     */
    where?: company_profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_profiles to fetch.
     */
    orderBy?: company_profilesOrderByWithRelationInput | company_profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_profiles.
     */
    cursor?: company_profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_profiles.
     */
    distinct?: Company_profilesScalarFieldEnum | Company_profilesScalarFieldEnum[]
  }

  /**
   * company_profiles findFirstOrThrow
   */
  export type company_profilesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_profiles
     */
    select?: company_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_profiles
     */
    omit?: company_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_profilesInclude<ExtArgs> | null
    /**
     * Filter, which company_profiles to fetch.
     */
    where?: company_profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_profiles to fetch.
     */
    orderBy?: company_profilesOrderByWithRelationInput | company_profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_profiles.
     */
    cursor?: company_profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_profiles.
     */
    distinct?: Company_profilesScalarFieldEnum | Company_profilesScalarFieldEnum[]
  }

  /**
   * company_profiles findMany
   */
  export type company_profilesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_profiles
     */
    select?: company_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_profiles
     */
    omit?: company_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_profilesInclude<ExtArgs> | null
    /**
     * Filter, which company_profiles to fetch.
     */
    where?: company_profilesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_profiles to fetch.
     */
    orderBy?: company_profilesOrderByWithRelationInput | company_profilesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_profiles.
     */
    cursor?: company_profilesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_profiles.
     */
    skip?: number
    distinct?: Company_profilesScalarFieldEnum | Company_profilesScalarFieldEnum[]
  }

  /**
   * company_profiles create
   */
  export type company_profilesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_profiles
     */
    select?: company_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_profiles
     */
    omit?: company_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_profilesInclude<ExtArgs> | null
    /**
     * The data needed to create a company_profiles.
     */
    data: XOR<company_profilesCreateInput, company_profilesUncheckedCreateInput>
  }

  /**
   * company_profiles createMany
   */
  export type company_profilesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many company_profiles.
     */
    data: company_profilesCreateManyInput | company_profilesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_profiles update
   */
  export type company_profilesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_profiles
     */
    select?: company_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_profiles
     */
    omit?: company_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_profilesInclude<ExtArgs> | null
    /**
     * The data needed to update a company_profiles.
     */
    data: XOR<company_profilesUpdateInput, company_profilesUncheckedUpdateInput>
    /**
     * Choose, which company_profiles to update.
     */
    where: company_profilesWhereUniqueInput
  }

  /**
   * company_profiles updateMany
   */
  export type company_profilesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update company_profiles.
     */
    data: XOR<company_profilesUpdateManyMutationInput, company_profilesUncheckedUpdateManyInput>
    /**
     * Filter which company_profiles to update
     */
    where?: company_profilesWhereInput
    /**
     * Limit how many company_profiles to update.
     */
    limit?: number
  }

  /**
   * company_profiles upsert
   */
  export type company_profilesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_profiles
     */
    select?: company_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_profiles
     */
    omit?: company_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_profilesInclude<ExtArgs> | null
    /**
     * The filter to search for the company_profiles to update in case it exists.
     */
    where: company_profilesWhereUniqueInput
    /**
     * In case the company_profiles found by the `where` argument doesn't exist, create a new company_profiles with this data.
     */
    create: XOR<company_profilesCreateInput, company_profilesUncheckedCreateInput>
    /**
     * In case the company_profiles was found with the provided `where` argument, update it with this data.
     */
    update: XOR<company_profilesUpdateInput, company_profilesUncheckedUpdateInput>
  }

  /**
   * company_profiles delete
   */
  export type company_profilesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_profiles
     */
    select?: company_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_profiles
     */
    omit?: company_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_profilesInclude<ExtArgs> | null
    /**
     * Filter which company_profiles to delete.
     */
    where: company_profilesWhereUniqueInput
  }

  /**
   * company_profiles deleteMany
   */
  export type company_profilesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_profiles to delete
     */
    where?: company_profilesWhereInput
    /**
     * Limit how many company_profiles to delete.
     */
    limit?: number
  }

  /**
   * company_profiles without action
   */
  export type company_profilesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_profiles
     */
    select?: company_profilesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_profiles
     */
    omit?: company_profilesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_profilesInclude<ExtArgs> | null
  }


  /**
   * Model company_subscriptions
   */

  export type AggregateCompany_subscriptions = {
    _count: Company_subscriptionsCountAggregateOutputType | null
    _avg: Company_subscriptionsAvgAggregateOutputType | null
    _sum: Company_subscriptionsSumAggregateOutputType | null
    _min: Company_subscriptionsMinAggregateOutputType | null
    _max: Company_subscriptionsMaxAggregateOutputType | null
  }

  export type Company_subscriptionsAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
    subscription_id: number | null
  }

  export type Company_subscriptionsSumAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
    subscription_id: bigint | null
  }

  export type Company_subscriptionsMinAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
    subscription_id: bigint | null
    start_date: Date | null
    end_date: Date | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_subscriptionsMaxAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
    subscription_id: bigint | null
    start_date: Date | null
    end_date: Date | null
    status: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Company_subscriptionsCountAggregateOutputType = {
    id: number
    company_id: number
    subscription_id: number
    start_date: number
    end_date: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Company_subscriptionsAvgAggregateInputType = {
    id?: true
    company_id?: true
    subscription_id?: true
  }

  export type Company_subscriptionsSumAggregateInputType = {
    id?: true
    company_id?: true
    subscription_id?: true
  }

  export type Company_subscriptionsMinAggregateInputType = {
    id?: true
    company_id?: true
    subscription_id?: true
    start_date?: true
    end_date?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_subscriptionsMaxAggregateInputType = {
    id?: true
    company_id?: true
    subscription_id?: true
    start_date?: true
    end_date?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type Company_subscriptionsCountAggregateInputType = {
    id?: true
    company_id?: true
    subscription_id?: true
    start_date?: true
    end_date?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Company_subscriptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_subscriptions to aggregate.
     */
    where?: company_subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_subscriptions to fetch.
     */
    orderBy?: company_subscriptionsOrderByWithRelationInput | company_subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: company_subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned company_subscriptions
    **/
    _count?: true | Company_subscriptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Company_subscriptionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Company_subscriptionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Company_subscriptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Company_subscriptionsMaxAggregateInputType
  }

  export type GetCompany_subscriptionsAggregateType<T extends Company_subscriptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateCompany_subscriptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCompany_subscriptions[P]>
      : GetScalarType<T[P], AggregateCompany_subscriptions[P]>
  }




  export type company_subscriptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: company_subscriptionsWhereInput
    orderBy?: company_subscriptionsOrderByWithAggregationInput | company_subscriptionsOrderByWithAggregationInput[]
    by: Company_subscriptionsScalarFieldEnum[] | Company_subscriptionsScalarFieldEnum
    having?: company_subscriptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Company_subscriptionsCountAggregateInputType | true
    _avg?: Company_subscriptionsAvgAggregateInputType
    _sum?: Company_subscriptionsSumAggregateInputType
    _min?: Company_subscriptionsMinAggregateInputType
    _max?: Company_subscriptionsMaxAggregateInputType
  }

  export type Company_subscriptionsGroupByOutputType = {
    id: bigint
    company_id: bigint
    subscription_id: bigint
    start_date: Date
    end_date: Date
    status: string
    created_at: Date | null
    updated_at: Date | null
    _count: Company_subscriptionsCountAggregateOutputType | null
    _avg: Company_subscriptionsAvgAggregateOutputType | null
    _sum: Company_subscriptionsSumAggregateOutputType | null
    _min: Company_subscriptionsMinAggregateOutputType | null
    _max: Company_subscriptionsMaxAggregateOutputType | null
  }

  type GetCompany_subscriptionsGroupByPayload<T extends company_subscriptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Company_subscriptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Company_subscriptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Company_subscriptionsGroupByOutputType[P]>
            : GetScalarType<T[P], Company_subscriptionsGroupByOutputType[P]>
        }
      >
    >


  export type company_subscriptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    subscription_id?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    subscriptions?: boolean | subscriptionsDefaultArgs<ExtArgs>
    payments?: boolean | company_subscriptions$paymentsArgs<ExtArgs>
    _count?: boolean | Company_subscriptionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["company_subscriptions"]>



  export type company_subscriptionsSelectScalar = {
    id?: boolean
    company_id?: boolean
    subscription_id?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type company_subscriptionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "subscription_id" | "start_date" | "end_date" | "status" | "created_at" | "updated_at", ExtArgs["result"]["company_subscriptions"]>
  export type company_subscriptionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    subscriptions?: boolean | subscriptionsDefaultArgs<ExtArgs>
    payments?: boolean | company_subscriptions$paymentsArgs<ExtArgs>
    _count?: boolean | Company_subscriptionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $company_subscriptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "company_subscriptions"
    objects: {
      companies: Prisma.$companiesPayload<ExtArgs>
      subscriptions: Prisma.$subscriptionsPayload<ExtArgs>
      payments: Prisma.$paymentsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      company_id: bigint
      subscription_id: bigint
      start_date: Date
      end_date: Date
      status: string
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["company_subscriptions"]>
    composites: {}
  }

  type company_subscriptionsGetPayload<S extends boolean | null | undefined | company_subscriptionsDefaultArgs> = $Result.GetResult<Prisma.$company_subscriptionsPayload, S>

  type company_subscriptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<company_subscriptionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Company_subscriptionsCountAggregateInputType | true
    }

  export interface company_subscriptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['company_subscriptions'], meta: { name: 'company_subscriptions' } }
    /**
     * Find zero or one Company_subscriptions that matches the filter.
     * @param {company_subscriptionsFindUniqueArgs} args - Arguments to find a Company_subscriptions
     * @example
     * // Get one Company_subscriptions
     * const company_subscriptions = await prisma.company_subscriptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends company_subscriptionsFindUniqueArgs>(args: SelectSubset<T, company_subscriptionsFindUniqueArgs<ExtArgs>>): Prisma__company_subscriptionsClient<$Result.GetResult<Prisma.$company_subscriptionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Company_subscriptions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {company_subscriptionsFindUniqueOrThrowArgs} args - Arguments to find a Company_subscriptions
     * @example
     * // Get one Company_subscriptions
     * const company_subscriptions = await prisma.company_subscriptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends company_subscriptionsFindUniqueOrThrowArgs>(args: SelectSubset<T, company_subscriptionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__company_subscriptionsClient<$Result.GetResult<Prisma.$company_subscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_subscriptionsFindFirstArgs} args - Arguments to find a Company_subscriptions
     * @example
     * // Get one Company_subscriptions
     * const company_subscriptions = await prisma.company_subscriptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends company_subscriptionsFindFirstArgs>(args?: SelectSubset<T, company_subscriptionsFindFirstArgs<ExtArgs>>): Prisma__company_subscriptionsClient<$Result.GetResult<Prisma.$company_subscriptionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Company_subscriptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_subscriptionsFindFirstOrThrowArgs} args - Arguments to find a Company_subscriptions
     * @example
     * // Get one Company_subscriptions
     * const company_subscriptions = await prisma.company_subscriptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends company_subscriptionsFindFirstOrThrowArgs>(args?: SelectSubset<T, company_subscriptionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__company_subscriptionsClient<$Result.GetResult<Prisma.$company_subscriptionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Company_subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_subscriptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Company_subscriptions
     * const company_subscriptions = await prisma.company_subscriptions.findMany()
     * 
     * // Get first 10 Company_subscriptions
     * const company_subscriptions = await prisma.company_subscriptions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const company_subscriptionsWithIdOnly = await prisma.company_subscriptions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends company_subscriptionsFindManyArgs>(args?: SelectSubset<T, company_subscriptionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_subscriptionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Company_subscriptions.
     * @param {company_subscriptionsCreateArgs} args - Arguments to create a Company_subscriptions.
     * @example
     * // Create one Company_subscriptions
     * const Company_subscriptions = await prisma.company_subscriptions.create({
     *   data: {
     *     // ... data to create a Company_subscriptions
     *   }
     * })
     * 
     */
    create<T extends company_subscriptionsCreateArgs>(args: SelectSubset<T, company_subscriptionsCreateArgs<ExtArgs>>): Prisma__company_subscriptionsClient<$Result.GetResult<Prisma.$company_subscriptionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Company_subscriptions.
     * @param {company_subscriptionsCreateManyArgs} args - Arguments to create many Company_subscriptions.
     * @example
     * // Create many Company_subscriptions
     * const company_subscriptions = await prisma.company_subscriptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends company_subscriptionsCreateManyArgs>(args?: SelectSubset<T, company_subscriptionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Company_subscriptions.
     * @param {company_subscriptionsDeleteArgs} args - Arguments to delete one Company_subscriptions.
     * @example
     * // Delete one Company_subscriptions
     * const Company_subscriptions = await prisma.company_subscriptions.delete({
     *   where: {
     *     // ... filter to delete one Company_subscriptions
     *   }
     * })
     * 
     */
    delete<T extends company_subscriptionsDeleteArgs>(args: SelectSubset<T, company_subscriptionsDeleteArgs<ExtArgs>>): Prisma__company_subscriptionsClient<$Result.GetResult<Prisma.$company_subscriptionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Company_subscriptions.
     * @param {company_subscriptionsUpdateArgs} args - Arguments to update one Company_subscriptions.
     * @example
     * // Update one Company_subscriptions
     * const company_subscriptions = await prisma.company_subscriptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends company_subscriptionsUpdateArgs>(args: SelectSubset<T, company_subscriptionsUpdateArgs<ExtArgs>>): Prisma__company_subscriptionsClient<$Result.GetResult<Prisma.$company_subscriptionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Company_subscriptions.
     * @param {company_subscriptionsDeleteManyArgs} args - Arguments to filter Company_subscriptions to delete.
     * @example
     * // Delete a few Company_subscriptions
     * const { count } = await prisma.company_subscriptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends company_subscriptionsDeleteManyArgs>(args?: SelectSubset<T, company_subscriptionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Company_subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_subscriptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Company_subscriptions
     * const company_subscriptions = await prisma.company_subscriptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends company_subscriptionsUpdateManyArgs>(args: SelectSubset<T, company_subscriptionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Company_subscriptions.
     * @param {company_subscriptionsUpsertArgs} args - Arguments to update or create a Company_subscriptions.
     * @example
     * // Update or create a Company_subscriptions
     * const company_subscriptions = await prisma.company_subscriptions.upsert({
     *   create: {
     *     // ... data to create a Company_subscriptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Company_subscriptions we want to update
     *   }
     * })
     */
    upsert<T extends company_subscriptionsUpsertArgs>(args: SelectSubset<T, company_subscriptionsUpsertArgs<ExtArgs>>): Prisma__company_subscriptionsClient<$Result.GetResult<Prisma.$company_subscriptionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Company_subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_subscriptionsCountArgs} args - Arguments to filter Company_subscriptions to count.
     * @example
     * // Count the number of Company_subscriptions
     * const count = await prisma.company_subscriptions.count({
     *   where: {
     *     // ... the filter for the Company_subscriptions we want to count
     *   }
     * })
    **/
    count<T extends company_subscriptionsCountArgs>(
      args?: Subset<T, company_subscriptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Company_subscriptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Company_subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Company_subscriptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Company_subscriptionsAggregateArgs>(args: Subset<T, Company_subscriptionsAggregateArgs>): Prisma.PrismaPromise<GetCompany_subscriptionsAggregateType<T>>

    /**
     * Group by Company_subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {company_subscriptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends company_subscriptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: company_subscriptionsGroupByArgs['orderBy'] }
        : { orderBy?: company_subscriptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, company_subscriptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCompany_subscriptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the company_subscriptions model
   */
  readonly fields: company_subscriptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for company_subscriptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__company_subscriptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    subscriptions<T extends subscriptionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, subscriptionsDefaultArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends company_subscriptions$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, company_subscriptions$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the company_subscriptions model
   */
  interface company_subscriptionsFieldRefs {
    readonly id: FieldRef<"company_subscriptions", 'BigInt'>
    readonly company_id: FieldRef<"company_subscriptions", 'BigInt'>
    readonly subscription_id: FieldRef<"company_subscriptions", 'BigInt'>
    readonly start_date: FieldRef<"company_subscriptions", 'DateTime'>
    readonly end_date: FieldRef<"company_subscriptions", 'DateTime'>
    readonly status: FieldRef<"company_subscriptions", 'String'>
    readonly created_at: FieldRef<"company_subscriptions", 'DateTime'>
    readonly updated_at: FieldRef<"company_subscriptions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * company_subscriptions findUnique
   */
  export type company_subscriptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_subscriptions
     */
    select?: company_subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_subscriptions
     */
    omit?: company_subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which company_subscriptions to fetch.
     */
    where: company_subscriptionsWhereUniqueInput
  }

  /**
   * company_subscriptions findUniqueOrThrow
   */
  export type company_subscriptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_subscriptions
     */
    select?: company_subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_subscriptions
     */
    omit?: company_subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which company_subscriptions to fetch.
     */
    where: company_subscriptionsWhereUniqueInput
  }

  /**
   * company_subscriptions findFirst
   */
  export type company_subscriptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_subscriptions
     */
    select?: company_subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_subscriptions
     */
    omit?: company_subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which company_subscriptions to fetch.
     */
    where?: company_subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_subscriptions to fetch.
     */
    orderBy?: company_subscriptionsOrderByWithRelationInput | company_subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_subscriptions.
     */
    cursor?: company_subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_subscriptions.
     */
    distinct?: Company_subscriptionsScalarFieldEnum | Company_subscriptionsScalarFieldEnum[]
  }

  /**
   * company_subscriptions findFirstOrThrow
   */
  export type company_subscriptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_subscriptions
     */
    select?: company_subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_subscriptions
     */
    omit?: company_subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which company_subscriptions to fetch.
     */
    where?: company_subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_subscriptions to fetch.
     */
    orderBy?: company_subscriptionsOrderByWithRelationInput | company_subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for company_subscriptions.
     */
    cursor?: company_subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of company_subscriptions.
     */
    distinct?: Company_subscriptionsScalarFieldEnum | Company_subscriptionsScalarFieldEnum[]
  }

  /**
   * company_subscriptions findMany
   */
  export type company_subscriptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_subscriptions
     */
    select?: company_subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_subscriptions
     */
    omit?: company_subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which company_subscriptions to fetch.
     */
    where?: company_subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of company_subscriptions to fetch.
     */
    orderBy?: company_subscriptionsOrderByWithRelationInput | company_subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing company_subscriptions.
     */
    cursor?: company_subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` company_subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` company_subscriptions.
     */
    skip?: number
    distinct?: Company_subscriptionsScalarFieldEnum | Company_subscriptionsScalarFieldEnum[]
  }

  /**
   * company_subscriptions create
   */
  export type company_subscriptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_subscriptions
     */
    select?: company_subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_subscriptions
     */
    omit?: company_subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_subscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to create a company_subscriptions.
     */
    data: XOR<company_subscriptionsCreateInput, company_subscriptionsUncheckedCreateInput>
  }

  /**
   * company_subscriptions createMany
   */
  export type company_subscriptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many company_subscriptions.
     */
    data: company_subscriptionsCreateManyInput | company_subscriptionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * company_subscriptions update
   */
  export type company_subscriptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_subscriptions
     */
    select?: company_subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_subscriptions
     */
    omit?: company_subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_subscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to update a company_subscriptions.
     */
    data: XOR<company_subscriptionsUpdateInput, company_subscriptionsUncheckedUpdateInput>
    /**
     * Choose, which company_subscriptions to update.
     */
    where: company_subscriptionsWhereUniqueInput
  }

  /**
   * company_subscriptions updateMany
   */
  export type company_subscriptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update company_subscriptions.
     */
    data: XOR<company_subscriptionsUpdateManyMutationInput, company_subscriptionsUncheckedUpdateManyInput>
    /**
     * Filter which company_subscriptions to update
     */
    where?: company_subscriptionsWhereInput
    /**
     * Limit how many company_subscriptions to update.
     */
    limit?: number
  }

  /**
   * company_subscriptions upsert
   */
  export type company_subscriptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_subscriptions
     */
    select?: company_subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_subscriptions
     */
    omit?: company_subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_subscriptionsInclude<ExtArgs> | null
    /**
     * The filter to search for the company_subscriptions to update in case it exists.
     */
    where: company_subscriptionsWhereUniqueInput
    /**
     * In case the company_subscriptions found by the `where` argument doesn't exist, create a new company_subscriptions with this data.
     */
    create: XOR<company_subscriptionsCreateInput, company_subscriptionsUncheckedCreateInput>
    /**
     * In case the company_subscriptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<company_subscriptionsUpdateInput, company_subscriptionsUncheckedUpdateInput>
  }

  /**
   * company_subscriptions delete
   */
  export type company_subscriptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_subscriptions
     */
    select?: company_subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_subscriptions
     */
    omit?: company_subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_subscriptionsInclude<ExtArgs> | null
    /**
     * Filter which company_subscriptions to delete.
     */
    where: company_subscriptionsWhereUniqueInput
  }

  /**
   * company_subscriptions deleteMany
   */
  export type company_subscriptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which company_subscriptions to delete
     */
    where?: company_subscriptionsWhereInput
    /**
     * Limit how many company_subscriptions to delete.
     */
    limit?: number
  }

  /**
   * company_subscriptions.payments
   */
  export type company_subscriptions$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    cursor?: paymentsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * company_subscriptions without action
   */
  export type company_subscriptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_subscriptions
     */
    select?: company_subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_subscriptions
     */
    omit?: company_subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_subscriptionsInclude<ExtArgs> | null
  }


  /**
   * Model integration_category_mappings
   */

  export type AggregateIntegration_category_mappings = {
    _count: Integration_category_mappingsCountAggregateOutputType | null
    _avg: Integration_category_mappingsAvgAggregateOutputType | null
    _sum: Integration_category_mappingsSumAggregateOutputType | null
    _min: Integration_category_mappingsMinAggregateOutputType | null
    _max: Integration_category_mappingsMaxAggregateOutputType | null
  }

  export type Integration_category_mappingsAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
    category_id: number | null
  }

  export type Integration_category_mappingsSumAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
    category_id: bigint | null
  }

  export type Integration_category_mappingsMinAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
    provider: string | null
    external_category: string | null
    category_id: bigint | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Integration_category_mappingsMaxAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
    provider: string | null
    external_category: string | null
    category_id: bigint | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Integration_category_mappingsCountAggregateOutputType = {
    id: number
    company_id: number
    provider: number
    external_category: number
    category_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Integration_category_mappingsAvgAggregateInputType = {
    id?: true
    company_id?: true
    category_id?: true
  }

  export type Integration_category_mappingsSumAggregateInputType = {
    id?: true
    company_id?: true
    category_id?: true
  }

  export type Integration_category_mappingsMinAggregateInputType = {
    id?: true
    company_id?: true
    provider?: true
    external_category?: true
    category_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Integration_category_mappingsMaxAggregateInputType = {
    id?: true
    company_id?: true
    provider?: true
    external_category?: true
    category_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Integration_category_mappingsCountAggregateInputType = {
    id?: true
    company_id?: true
    provider?: true
    external_category?: true
    category_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Integration_category_mappingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which integration_category_mappings to aggregate.
     */
    where?: integration_category_mappingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of integration_category_mappings to fetch.
     */
    orderBy?: integration_category_mappingsOrderByWithRelationInput | integration_category_mappingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: integration_category_mappingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` integration_category_mappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` integration_category_mappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned integration_category_mappings
    **/
    _count?: true | Integration_category_mappingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Integration_category_mappingsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Integration_category_mappingsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Integration_category_mappingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Integration_category_mappingsMaxAggregateInputType
  }

  export type GetIntegration_category_mappingsAggregateType<T extends Integration_category_mappingsAggregateArgs> = {
        [P in keyof T & keyof AggregateIntegration_category_mappings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIntegration_category_mappings[P]>
      : GetScalarType<T[P], AggregateIntegration_category_mappings[P]>
  }




  export type integration_category_mappingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: integration_category_mappingsWhereInput
    orderBy?: integration_category_mappingsOrderByWithAggregationInput | integration_category_mappingsOrderByWithAggregationInput[]
    by: Integration_category_mappingsScalarFieldEnum[] | Integration_category_mappingsScalarFieldEnum
    having?: integration_category_mappingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Integration_category_mappingsCountAggregateInputType | true
    _avg?: Integration_category_mappingsAvgAggregateInputType
    _sum?: Integration_category_mappingsSumAggregateInputType
    _min?: Integration_category_mappingsMinAggregateInputType
    _max?: Integration_category_mappingsMaxAggregateInputType
  }

  export type Integration_category_mappingsGroupByOutputType = {
    id: bigint
    company_id: bigint | null
    provider: string
    external_category: string
    category_id: bigint | null
    created_at: Date | null
    updated_at: Date | null
    _count: Integration_category_mappingsCountAggregateOutputType | null
    _avg: Integration_category_mappingsAvgAggregateOutputType | null
    _sum: Integration_category_mappingsSumAggregateOutputType | null
    _min: Integration_category_mappingsMinAggregateOutputType | null
    _max: Integration_category_mappingsMaxAggregateOutputType | null
  }

  type GetIntegration_category_mappingsGroupByPayload<T extends integration_category_mappingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Integration_category_mappingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Integration_category_mappingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Integration_category_mappingsGroupByOutputType[P]>
            : GetScalarType<T[P], Integration_category_mappingsGroupByOutputType[P]>
        }
      >
    >


  export type integration_category_mappingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    provider?: boolean
    external_category?: boolean
    category_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    categories?: boolean | integration_category_mappings$categoriesArgs<ExtArgs>
    companies?: boolean | integration_category_mappings$companiesArgs<ExtArgs>
  }, ExtArgs["result"]["integration_category_mappings"]>



  export type integration_category_mappingsSelectScalar = {
    id?: boolean
    company_id?: boolean
    provider?: boolean
    external_category?: boolean
    category_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type integration_category_mappingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "provider" | "external_category" | "category_id" | "created_at" | "updated_at", ExtArgs["result"]["integration_category_mappings"]>
  export type integration_category_mappingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | integration_category_mappings$categoriesArgs<ExtArgs>
    companies?: boolean | integration_category_mappings$companiesArgs<ExtArgs>
  }

  export type $integration_category_mappingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "integration_category_mappings"
    objects: {
      categories: Prisma.$categoriesPayload<ExtArgs> | null
      companies: Prisma.$companiesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      company_id: bigint | null
      provider: string
      external_category: string
      category_id: bigint | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["integration_category_mappings"]>
    composites: {}
  }

  type integration_category_mappingsGetPayload<S extends boolean | null | undefined | integration_category_mappingsDefaultArgs> = $Result.GetResult<Prisma.$integration_category_mappingsPayload, S>

  type integration_category_mappingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<integration_category_mappingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Integration_category_mappingsCountAggregateInputType | true
    }

  export interface integration_category_mappingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['integration_category_mappings'], meta: { name: 'integration_category_mappings' } }
    /**
     * Find zero or one Integration_category_mappings that matches the filter.
     * @param {integration_category_mappingsFindUniqueArgs} args - Arguments to find a Integration_category_mappings
     * @example
     * // Get one Integration_category_mappings
     * const integration_category_mappings = await prisma.integration_category_mappings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends integration_category_mappingsFindUniqueArgs>(args: SelectSubset<T, integration_category_mappingsFindUniqueArgs<ExtArgs>>): Prisma__integration_category_mappingsClient<$Result.GetResult<Prisma.$integration_category_mappingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Integration_category_mappings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {integration_category_mappingsFindUniqueOrThrowArgs} args - Arguments to find a Integration_category_mappings
     * @example
     * // Get one Integration_category_mappings
     * const integration_category_mappings = await prisma.integration_category_mappings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends integration_category_mappingsFindUniqueOrThrowArgs>(args: SelectSubset<T, integration_category_mappingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__integration_category_mappingsClient<$Result.GetResult<Prisma.$integration_category_mappingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integration_category_mappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {integration_category_mappingsFindFirstArgs} args - Arguments to find a Integration_category_mappings
     * @example
     * // Get one Integration_category_mappings
     * const integration_category_mappings = await prisma.integration_category_mappings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends integration_category_mappingsFindFirstArgs>(args?: SelectSubset<T, integration_category_mappingsFindFirstArgs<ExtArgs>>): Prisma__integration_category_mappingsClient<$Result.GetResult<Prisma.$integration_category_mappingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Integration_category_mappings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {integration_category_mappingsFindFirstOrThrowArgs} args - Arguments to find a Integration_category_mappings
     * @example
     * // Get one Integration_category_mappings
     * const integration_category_mappings = await prisma.integration_category_mappings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends integration_category_mappingsFindFirstOrThrowArgs>(args?: SelectSubset<T, integration_category_mappingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__integration_category_mappingsClient<$Result.GetResult<Prisma.$integration_category_mappingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Integration_category_mappings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {integration_category_mappingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Integration_category_mappings
     * const integration_category_mappings = await prisma.integration_category_mappings.findMany()
     * 
     * // Get first 10 Integration_category_mappings
     * const integration_category_mappings = await prisma.integration_category_mappings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const integration_category_mappingsWithIdOnly = await prisma.integration_category_mappings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends integration_category_mappingsFindManyArgs>(args?: SelectSubset<T, integration_category_mappingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$integration_category_mappingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Integration_category_mappings.
     * @param {integration_category_mappingsCreateArgs} args - Arguments to create a Integration_category_mappings.
     * @example
     * // Create one Integration_category_mappings
     * const Integration_category_mappings = await prisma.integration_category_mappings.create({
     *   data: {
     *     // ... data to create a Integration_category_mappings
     *   }
     * })
     * 
     */
    create<T extends integration_category_mappingsCreateArgs>(args: SelectSubset<T, integration_category_mappingsCreateArgs<ExtArgs>>): Prisma__integration_category_mappingsClient<$Result.GetResult<Prisma.$integration_category_mappingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Integration_category_mappings.
     * @param {integration_category_mappingsCreateManyArgs} args - Arguments to create many Integration_category_mappings.
     * @example
     * // Create many Integration_category_mappings
     * const integration_category_mappings = await prisma.integration_category_mappings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends integration_category_mappingsCreateManyArgs>(args?: SelectSubset<T, integration_category_mappingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Integration_category_mappings.
     * @param {integration_category_mappingsDeleteArgs} args - Arguments to delete one Integration_category_mappings.
     * @example
     * // Delete one Integration_category_mappings
     * const Integration_category_mappings = await prisma.integration_category_mappings.delete({
     *   where: {
     *     // ... filter to delete one Integration_category_mappings
     *   }
     * })
     * 
     */
    delete<T extends integration_category_mappingsDeleteArgs>(args: SelectSubset<T, integration_category_mappingsDeleteArgs<ExtArgs>>): Prisma__integration_category_mappingsClient<$Result.GetResult<Prisma.$integration_category_mappingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Integration_category_mappings.
     * @param {integration_category_mappingsUpdateArgs} args - Arguments to update one Integration_category_mappings.
     * @example
     * // Update one Integration_category_mappings
     * const integration_category_mappings = await prisma.integration_category_mappings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends integration_category_mappingsUpdateArgs>(args: SelectSubset<T, integration_category_mappingsUpdateArgs<ExtArgs>>): Prisma__integration_category_mappingsClient<$Result.GetResult<Prisma.$integration_category_mappingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Integration_category_mappings.
     * @param {integration_category_mappingsDeleteManyArgs} args - Arguments to filter Integration_category_mappings to delete.
     * @example
     * // Delete a few Integration_category_mappings
     * const { count } = await prisma.integration_category_mappings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends integration_category_mappingsDeleteManyArgs>(args?: SelectSubset<T, integration_category_mappingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Integration_category_mappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {integration_category_mappingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Integration_category_mappings
     * const integration_category_mappings = await prisma.integration_category_mappings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends integration_category_mappingsUpdateManyArgs>(args: SelectSubset<T, integration_category_mappingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Integration_category_mappings.
     * @param {integration_category_mappingsUpsertArgs} args - Arguments to update or create a Integration_category_mappings.
     * @example
     * // Update or create a Integration_category_mappings
     * const integration_category_mappings = await prisma.integration_category_mappings.upsert({
     *   create: {
     *     // ... data to create a Integration_category_mappings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Integration_category_mappings we want to update
     *   }
     * })
     */
    upsert<T extends integration_category_mappingsUpsertArgs>(args: SelectSubset<T, integration_category_mappingsUpsertArgs<ExtArgs>>): Prisma__integration_category_mappingsClient<$Result.GetResult<Prisma.$integration_category_mappingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Integration_category_mappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {integration_category_mappingsCountArgs} args - Arguments to filter Integration_category_mappings to count.
     * @example
     * // Count the number of Integration_category_mappings
     * const count = await prisma.integration_category_mappings.count({
     *   where: {
     *     // ... the filter for the Integration_category_mappings we want to count
     *   }
     * })
    **/
    count<T extends integration_category_mappingsCountArgs>(
      args?: Subset<T, integration_category_mappingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Integration_category_mappingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Integration_category_mappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Integration_category_mappingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Integration_category_mappingsAggregateArgs>(args: Subset<T, Integration_category_mappingsAggregateArgs>): Prisma.PrismaPromise<GetIntegration_category_mappingsAggregateType<T>>

    /**
     * Group by Integration_category_mappings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {integration_category_mappingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends integration_category_mappingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: integration_category_mappingsGroupByArgs['orderBy'] }
        : { orderBy?: integration_category_mappingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, integration_category_mappingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIntegration_category_mappingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the integration_category_mappings model
   */
  readonly fields: integration_category_mappingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for integration_category_mappings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__integration_category_mappingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends integration_category_mappings$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, integration_category_mappings$categoriesArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    companies<T extends integration_category_mappings$companiesArgs<ExtArgs> = {}>(args?: Subset<T, integration_category_mappings$companiesArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the integration_category_mappings model
   */
  interface integration_category_mappingsFieldRefs {
    readonly id: FieldRef<"integration_category_mappings", 'BigInt'>
    readonly company_id: FieldRef<"integration_category_mappings", 'BigInt'>
    readonly provider: FieldRef<"integration_category_mappings", 'String'>
    readonly external_category: FieldRef<"integration_category_mappings", 'String'>
    readonly category_id: FieldRef<"integration_category_mappings", 'BigInt'>
    readonly created_at: FieldRef<"integration_category_mappings", 'DateTime'>
    readonly updated_at: FieldRef<"integration_category_mappings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * integration_category_mappings findUnique
   */
  export type integration_category_mappingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration_category_mappings
     */
    select?: integration_category_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration_category_mappings
     */
    omit?: integration_category_mappingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integration_category_mappingsInclude<ExtArgs> | null
    /**
     * Filter, which integration_category_mappings to fetch.
     */
    where: integration_category_mappingsWhereUniqueInput
  }

  /**
   * integration_category_mappings findUniqueOrThrow
   */
  export type integration_category_mappingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration_category_mappings
     */
    select?: integration_category_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration_category_mappings
     */
    omit?: integration_category_mappingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integration_category_mappingsInclude<ExtArgs> | null
    /**
     * Filter, which integration_category_mappings to fetch.
     */
    where: integration_category_mappingsWhereUniqueInput
  }

  /**
   * integration_category_mappings findFirst
   */
  export type integration_category_mappingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration_category_mappings
     */
    select?: integration_category_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration_category_mappings
     */
    omit?: integration_category_mappingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integration_category_mappingsInclude<ExtArgs> | null
    /**
     * Filter, which integration_category_mappings to fetch.
     */
    where?: integration_category_mappingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of integration_category_mappings to fetch.
     */
    orderBy?: integration_category_mappingsOrderByWithRelationInput | integration_category_mappingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for integration_category_mappings.
     */
    cursor?: integration_category_mappingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` integration_category_mappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` integration_category_mappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of integration_category_mappings.
     */
    distinct?: Integration_category_mappingsScalarFieldEnum | Integration_category_mappingsScalarFieldEnum[]
  }

  /**
   * integration_category_mappings findFirstOrThrow
   */
  export type integration_category_mappingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration_category_mappings
     */
    select?: integration_category_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration_category_mappings
     */
    omit?: integration_category_mappingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integration_category_mappingsInclude<ExtArgs> | null
    /**
     * Filter, which integration_category_mappings to fetch.
     */
    where?: integration_category_mappingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of integration_category_mappings to fetch.
     */
    orderBy?: integration_category_mappingsOrderByWithRelationInput | integration_category_mappingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for integration_category_mappings.
     */
    cursor?: integration_category_mappingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` integration_category_mappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` integration_category_mappings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of integration_category_mappings.
     */
    distinct?: Integration_category_mappingsScalarFieldEnum | Integration_category_mappingsScalarFieldEnum[]
  }

  /**
   * integration_category_mappings findMany
   */
  export type integration_category_mappingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration_category_mappings
     */
    select?: integration_category_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration_category_mappings
     */
    omit?: integration_category_mappingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integration_category_mappingsInclude<ExtArgs> | null
    /**
     * Filter, which integration_category_mappings to fetch.
     */
    where?: integration_category_mappingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of integration_category_mappings to fetch.
     */
    orderBy?: integration_category_mappingsOrderByWithRelationInput | integration_category_mappingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing integration_category_mappings.
     */
    cursor?: integration_category_mappingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` integration_category_mappings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` integration_category_mappings.
     */
    skip?: number
    distinct?: Integration_category_mappingsScalarFieldEnum | Integration_category_mappingsScalarFieldEnum[]
  }

  /**
   * integration_category_mappings create
   */
  export type integration_category_mappingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration_category_mappings
     */
    select?: integration_category_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration_category_mappings
     */
    omit?: integration_category_mappingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integration_category_mappingsInclude<ExtArgs> | null
    /**
     * The data needed to create a integration_category_mappings.
     */
    data: XOR<integration_category_mappingsCreateInput, integration_category_mappingsUncheckedCreateInput>
  }

  /**
   * integration_category_mappings createMany
   */
  export type integration_category_mappingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many integration_category_mappings.
     */
    data: integration_category_mappingsCreateManyInput | integration_category_mappingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * integration_category_mappings update
   */
  export type integration_category_mappingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration_category_mappings
     */
    select?: integration_category_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration_category_mappings
     */
    omit?: integration_category_mappingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integration_category_mappingsInclude<ExtArgs> | null
    /**
     * The data needed to update a integration_category_mappings.
     */
    data: XOR<integration_category_mappingsUpdateInput, integration_category_mappingsUncheckedUpdateInput>
    /**
     * Choose, which integration_category_mappings to update.
     */
    where: integration_category_mappingsWhereUniqueInput
  }

  /**
   * integration_category_mappings updateMany
   */
  export type integration_category_mappingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update integration_category_mappings.
     */
    data: XOR<integration_category_mappingsUpdateManyMutationInput, integration_category_mappingsUncheckedUpdateManyInput>
    /**
     * Filter which integration_category_mappings to update
     */
    where?: integration_category_mappingsWhereInput
    /**
     * Limit how many integration_category_mappings to update.
     */
    limit?: number
  }

  /**
   * integration_category_mappings upsert
   */
  export type integration_category_mappingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration_category_mappings
     */
    select?: integration_category_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration_category_mappings
     */
    omit?: integration_category_mappingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integration_category_mappingsInclude<ExtArgs> | null
    /**
     * The filter to search for the integration_category_mappings to update in case it exists.
     */
    where: integration_category_mappingsWhereUniqueInput
    /**
     * In case the integration_category_mappings found by the `where` argument doesn't exist, create a new integration_category_mappings with this data.
     */
    create: XOR<integration_category_mappingsCreateInput, integration_category_mappingsUncheckedCreateInput>
    /**
     * In case the integration_category_mappings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<integration_category_mappingsUpdateInput, integration_category_mappingsUncheckedUpdateInput>
  }

  /**
   * integration_category_mappings delete
   */
  export type integration_category_mappingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration_category_mappings
     */
    select?: integration_category_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration_category_mappings
     */
    omit?: integration_category_mappingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integration_category_mappingsInclude<ExtArgs> | null
    /**
     * Filter which integration_category_mappings to delete.
     */
    where: integration_category_mappingsWhereUniqueInput
  }

  /**
   * integration_category_mappings deleteMany
   */
  export type integration_category_mappingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which integration_category_mappings to delete
     */
    where?: integration_category_mappingsWhereInput
    /**
     * Limit how many integration_category_mappings to delete.
     */
    limit?: number
  }

  /**
   * integration_category_mappings.categories
   */
  export type integration_category_mappings$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
  }

  /**
   * integration_category_mappings.companies
   */
  export type integration_category_mappings$companiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the companies
     */
    select?: companiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the companies
     */
    omit?: companiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: companiesInclude<ExtArgs> | null
    where?: companiesWhereInput
  }

  /**
   * integration_category_mappings without action
   */
  export type integration_category_mappingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the integration_category_mappings
     */
    select?: integration_category_mappingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the integration_category_mappings
     */
    omit?: integration_category_mappingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: integration_category_mappingsInclude<ExtArgs> | null
  }


  /**
   * Model menus
   */

  export type AggregateMenus = {
    _count: MenusCountAggregateOutputType | null
    _avg: MenusAvgAggregateOutputType | null
    _sum: MenusSumAggregateOutputType | null
    _min: MenusMinAggregateOutputType | null
    _max: MenusMaxAggregateOutputType | null
  }

  export type MenusAvgAggregateOutputType = {
    id: number | null
    parent_id: number | null
    order: number | null
  }

  export type MenusSumAggregateOutputType = {
    id: bigint | null
    parent_id: bigint | null
    order: number | null
  }

  export type MenusMinAggregateOutputType = {
    id: bigint | null
    title: string | null
    href: string | null
    icon: string | null
    role: string | null
    permission: string | null
    parent_id: bigint | null
    order: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MenusMaxAggregateOutputType = {
    id: bigint | null
    title: string | null
    href: string | null
    icon: string | null
    role: string | null
    permission: string | null
    parent_id: bigint | null
    order: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MenusCountAggregateOutputType = {
    id: number
    title: number
    href: number
    icon: number
    role: number
    permission: number
    parent_id: number
    order: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type MenusAvgAggregateInputType = {
    id?: true
    parent_id?: true
    order?: true
  }

  export type MenusSumAggregateInputType = {
    id?: true
    parent_id?: true
    order?: true
  }

  export type MenusMinAggregateInputType = {
    id?: true
    title?: true
    href?: true
    icon?: true
    role?: true
    permission?: true
    parent_id?: true
    order?: true
    created_at?: true
    updated_at?: true
  }

  export type MenusMaxAggregateInputType = {
    id?: true
    title?: true
    href?: true
    icon?: true
    role?: true
    permission?: true
    parent_id?: true
    order?: true
    created_at?: true
    updated_at?: true
  }

  export type MenusCountAggregateInputType = {
    id?: true
    title?: true
    href?: true
    icon?: true
    role?: true
    permission?: true
    parent_id?: true
    order?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type MenusAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which menus to aggregate.
     */
    where?: menusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menus to fetch.
     */
    orderBy?: menusOrderByWithRelationInput | menusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: menusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned menus
    **/
    _count?: true | MenusCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MenusAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MenusSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MenusMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MenusMaxAggregateInputType
  }

  export type GetMenusAggregateType<T extends MenusAggregateArgs> = {
        [P in keyof T & keyof AggregateMenus]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMenus[P]>
      : GetScalarType<T[P], AggregateMenus[P]>
  }




  export type menusGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: menusWhereInput
    orderBy?: menusOrderByWithAggregationInput | menusOrderByWithAggregationInput[]
    by: MenusScalarFieldEnum[] | MenusScalarFieldEnum
    having?: menusScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MenusCountAggregateInputType | true
    _avg?: MenusAvgAggregateInputType
    _sum?: MenusSumAggregateInputType
    _min?: MenusMinAggregateInputType
    _max?: MenusMaxAggregateInputType
  }

  export type MenusGroupByOutputType = {
    id: bigint
    title: string
    href: string | null
    icon: string | null
    role: string | null
    permission: string | null
    parent_id: bigint | null
    order: number
    created_at: Date | null
    updated_at: Date | null
    _count: MenusCountAggregateOutputType | null
    _avg: MenusAvgAggregateOutputType | null
    _sum: MenusSumAggregateOutputType | null
    _min: MenusMinAggregateOutputType | null
    _max: MenusMaxAggregateOutputType | null
  }

  type GetMenusGroupByPayload<T extends menusGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MenusGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MenusGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MenusGroupByOutputType[P]>
            : GetScalarType<T[P], MenusGroupByOutputType[P]>
        }
      >
    >


  export type menusSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    href?: boolean
    icon?: boolean
    role?: boolean
    permission?: boolean
    parent_id?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
    menus?: boolean | menus$menusArgs<ExtArgs>
    other_menus?: boolean | menus$other_menusArgs<ExtArgs>
    _count?: boolean | MenusCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["menus"]>



  export type menusSelectScalar = {
    id?: boolean
    title?: boolean
    href?: boolean
    icon?: boolean
    role?: boolean
    permission?: boolean
    parent_id?: boolean
    order?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type menusOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "href" | "icon" | "role" | "permission" | "parent_id" | "order" | "created_at" | "updated_at", ExtArgs["result"]["menus"]>
  export type menusInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    menus?: boolean | menus$menusArgs<ExtArgs>
    other_menus?: boolean | menus$other_menusArgs<ExtArgs>
    _count?: boolean | MenusCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $menusPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "menus"
    objects: {
      menus: Prisma.$menusPayload<ExtArgs> | null
      other_menus: Prisma.$menusPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      title: string
      href: string | null
      icon: string | null
      role: string | null
      permission: string | null
      parent_id: bigint | null
      order: number
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["menus"]>
    composites: {}
  }

  type menusGetPayload<S extends boolean | null | undefined | menusDefaultArgs> = $Result.GetResult<Prisma.$menusPayload, S>

  type menusCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<menusFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MenusCountAggregateInputType | true
    }

  export interface menusDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['menus'], meta: { name: 'menus' } }
    /**
     * Find zero or one Menus that matches the filter.
     * @param {menusFindUniqueArgs} args - Arguments to find a Menus
     * @example
     * // Get one Menus
     * const menus = await prisma.menus.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends menusFindUniqueArgs>(args: SelectSubset<T, menusFindUniqueArgs<ExtArgs>>): Prisma__menusClient<$Result.GetResult<Prisma.$menusPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Menus that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {menusFindUniqueOrThrowArgs} args - Arguments to find a Menus
     * @example
     * // Get one Menus
     * const menus = await prisma.menus.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends menusFindUniqueOrThrowArgs>(args: SelectSubset<T, menusFindUniqueOrThrowArgs<ExtArgs>>): Prisma__menusClient<$Result.GetResult<Prisma.$menusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menusFindFirstArgs} args - Arguments to find a Menus
     * @example
     * // Get one Menus
     * const menus = await prisma.menus.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends menusFindFirstArgs>(args?: SelectSubset<T, menusFindFirstArgs<ExtArgs>>): Prisma__menusClient<$Result.GetResult<Prisma.$menusPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Menus that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menusFindFirstOrThrowArgs} args - Arguments to find a Menus
     * @example
     * // Get one Menus
     * const menus = await prisma.menus.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends menusFindFirstOrThrowArgs>(args?: SelectSubset<T, menusFindFirstOrThrowArgs<ExtArgs>>): Prisma__menusClient<$Result.GetResult<Prisma.$menusPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Menus that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menusFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Menus
     * const menus = await prisma.menus.findMany()
     * 
     * // Get first 10 Menus
     * const menus = await prisma.menus.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const menusWithIdOnly = await prisma.menus.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends menusFindManyArgs>(args?: SelectSubset<T, menusFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$menusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Menus.
     * @param {menusCreateArgs} args - Arguments to create a Menus.
     * @example
     * // Create one Menus
     * const Menus = await prisma.menus.create({
     *   data: {
     *     // ... data to create a Menus
     *   }
     * })
     * 
     */
    create<T extends menusCreateArgs>(args: SelectSubset<T, menusCreateArgs<ExtArgs>>): Prisma__menusClient<$Result.GetResult<Prisma.$menusPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Menus.
     * @param {menusCreateManyArgs} args - Arguments to create many Menus.
     * @example
     * // Create many Menus
     * const menus = await prisma.menus.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends menusCreateManyArgs>(args?: SelectSubset<T, menusCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Menus.
     * @param {menusDeleteArgs} args - Arguments to delete one Menus.
     * @example
     * // Delete one Menus
     * const Menus = await prisma.menus.delete({
     *   where: {
     *     // ... filter to delete one Menus
     *   }
     * })
     * 
     */
    delete<T extends menusDeleteArgs>(args: SelectSubset<T, menusDeleteArgs<ExtArgs>>): Prisma__menusClient<$Result.GetResult<Prisma.$menusPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Menus.
     * @param {menusUpdateArgs} args - Arguments to update one Menus.
     * @example
     * // Update one Menus
     * const menus = await prisma.menus.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends menusUpdateArgs>(args: SelectSubset<T, menusUpdateArgs<ExtArgs>>): Prisma__menusClient<$Result.GetResult<Prisma.$menusPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Menus.
     * @param {menusDeleteManyArgs} args - Arguments to filter Menus to delete.
     * @example
     * // Delete a few Menus
     * const { count } = await prisma.menus.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends menusDeleteManyArgs>(args?: SelectSubset<T, menusDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menusUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Menus
     * const menus = await prisma.menus.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends menusUpdateManyArgs>(args: SelectSubset<T, menusUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Menus.
     * @param {menusUpsertArgs} args - Arguments to update or create a Menus.
     * @example
     * // Update or create a Menus
     * const menus = await prisma.menus.upsert({
     *   create: {
     *     // ... data to create a Menus
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Menus we want to update
     *   }
     * })
     */
    upsert<T extends menusUpsertArgs>(args: SelectSubset<T, menusUpsertArgs<ExtArgs>>): Prisma__menusClient<$Result.GetResult<Prisma.$menusPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menusCountArgs} args - Arguments to filter Menus to count.
     * @example
     * // Count the number of Menus
     * const count = await prisma.menus.count({
     *   where: {
     *     // ... the filter for the Menus we want to count
     *   }
     * })
    **/
    count<T extends menusCountArgs>(
      args?: Subset<T, menusCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MenusCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MenusAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MenusAggregateArgs>(args: Subset<T, MenusAggregateArgs>): Prisma.PrismaPromise<GetMenusAggregateType<T>>

    /**
     * Group by Menus.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {menusGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends menusGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: menusGroupByArgs['orderBy'] }
        : { orderBy?: menusGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, menusGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMenusGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the menus model
   */
  readonly fields: menusFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for menus.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__menusClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    menus<T extends menus$menusArgs<ExtArgs> = {}>(args?: Subset<T, menus$menusArgs<ExtArgs>>): Prisma__menusClient<$Result.GetResult<Prisma.$menusPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    other_menus<T extends menus$other_menusArgs<ExtArgs> = {}>(args?: Subset<T, menus$other_menusArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$menusPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the menus model
   */
  interface menusFieldRefs {
    readonly id: FieldRef<"menus", 'BigInt'>
    readonly title: FieldRef<"menus", 'String'>
    readonly href: FieldRef<"menus", 'String'>
    readonly icon: FieldRef<"menus", 'String'>
    readonly role: FieldRef<"menus", 'String'>
    readonly permission: FieldRef<"menus", 'String'>
    readonly parent_id: FieldRef<"menus", 'BigInt'>
    readonly order: FieldRef<"menus", 'Int'>
    readonly created_at: FieldRef<"menus", 'DateTime'>
    readonly updated_at: FieldRef<"menus", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * menus findUnique
   */
  export type menusFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menus
     */
    select?: menusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menus
     */
    omit?: menusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menusInclude<ExtArgs> | null
    /**
     * Filter, which menus to fetch.
     */
    where: menusWhereUniqueInput
  }

  /**
   * menus findUniqueOrThrow
   */
  export type menusFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menus
     */
    select?: menusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menus
     */
    omit?: menusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menusInclude<ExtArgs> | null
    /**
     * Filter, which menus to fetch.
     */
    where: menusWhereUniqueInput
  }

  /**
   * menus findFirst
   */
  export type menusFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menus
     */
    select?: menusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menus
     */
    omit?: menusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menusInclude<ExtArgs> | null
    /**
     * Filter, which menus to fetch.
     */
    where?: menusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menus to fetch.
     */
    orderBy?: menusOrderByWithRelationInput | menusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for menus.
     */
    cursor?: menusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of menus.
     */
    distinct?: MenusScalarFieldEnum | MenusScalarFieldEnum[]
  }

  /**
   * menus findFirstOrThrow
   */
  export type menusFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menus
     */
    select?: menusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menus
     */
    omit?: menusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menusInclude<ExtArgs> | null
    /**
     * Filter, which menus to fetch.
     */
    where?: menusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menus to fetch.
     */
    orderBy?: menusOrderByWithRelationInput | menusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for menus.
     */
    cursor?: menusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menus.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of menus.
     */
    distinct?: MenusScalarFieldEnum | MenusScalarFieldEnum[]
  }

  /**
   * menus findMany
   */
  export type menusFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menus
     */
    select?: menusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menus
     */
    omit?: menusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menusInclude<ExtArgs> | null
    /**
     * Filter, which menus to fetch.
     */
    where?: menusWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of menus to fetch.
     */
    orderBy?: menusOrderByWithRelationInput | menusOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing menus.
     */
    cursor?: menusWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` menus from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` menus.
     */
    skip?: number
    distinct?: MenusScalarFieldEnum | MenusScalarFieldEnum[]
  }

  /**
   * menus create
   */
  export type menusCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menus
     */
    select?: menusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menus
     */
    omit?: menusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menusInclude<ExtArgs> | null
    /**
     * The data needed to create a menus.
     */
    data: XOR<menusCreateInput, menusUncheckedCreateInput>
  }

  /**
   * menus createMany
   */
  export type menusCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many menus.
     */
    data: menusCreateManyInput | menusCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * menus update
   */
  export type menusUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menus
     */
    select?: menusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menus
     */
    omit?: menusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menusInclude<ExtArgs> | null
    /**
     * The data needed to update a menus.
     */
    data: XOR<menusUpdateInput, menusUncheckedUpdateInput>
    /**
     * Choose, which menus to update.
     */
    where: menusWhereUniqueInput
  }

  /**
   * menus updateMany
   */
  export type menusUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update menus.
     */
    data: XOR<menusUpdateManyMutationInput, menusUncheckedUpdateManyInput>
    /**
     * Filter which menus to update
     */
    where?: menusWhereInput
    /**
     * Limit how many menus to update.
     */
    limit?: number
  }

  /**
   * menus upsert
   */
  export type menusUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menus
     */
    select?: menusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menus
     */
    omit?: menusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menusInclude<ExtArgs> | null
    /**
     * The filter to search for the menus to update in case it exists.
     */
    where: menusWhereUniqueInput
    /**
     * In case the menus found by the `where` argument doesn't exist, create a new menus with this data.
     */
    create: XOR<menusCreateInput, menusUncheckedCreateInput>
    /**
     * In case the menus was found with the provided `where` argument, update it with this data.
     */
    update: XOR<menusUpdateInput, menusUncheckedUpdateInput>
  }

  /**
   * menus delete
   */
  export type menusDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menus
     */
    select?: menusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menus
     */
    omit?: menusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menusInclude<ExtArgs> | null
    /**
     * Filter which menus to delete.
     */
    where: menusWhereUniqueInput
  }

  /**
   * menus deleteMany
   */
  export type menusDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which menus to delete
     */
    where?: menusWhereInput
    /**
     * Limit how many menus to delete.
     */
    limit?: number
  }

  /**
   * menus.menus
   */
  export type menus$menusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menus
     */
    select?: menusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menus
     */
    omit?: menusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menusInclude<ExtArgs> | null
    where?: menusWhereInput
  }

  /**
   * menus.other_menus
   */
  export type menus$other_menusArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menus
     */
    select?: menusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menus
     */
    omit?: menusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menusInclude<ExtArgs> | null
    where?: menusWhereInput
    orderBy?: menusOrderByWithRelationInput | menusOrderByWithRelationInput[]
    cursor?: menusWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MenusScalarFieldEnum | MenusScalarFieldEnum[]
  }

  /**
   * menus without action
   */
  export type menusDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the menus
     */
    select?: menusSelect<ExtArgs> | null
    /**
     * Omit specific fields from the menus
     */
    omit?: menusOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: menusInclude<ExtArgs> | null
  }


  /**
   * Model offer_category
   */

  export type AggregateOffer_category = {
    _count: Offer_categoryCountAggregateOutputType | null
    _avg: Offer_categoryAvgAggregateOutputType | null
    _sum: Offer_categorySumAggregateOutputType | null
    _min: Offer_categoryMinAggregateOutputType | null
    _max: Offer_categoryMaxAggregateOutputType | null
  }

  export type Offer_categoryAvgAggregateOutputType = {
    id: number | null
    offer_id: number | null
    category_id: number | null
  }

  export type Offer_categorySumAggregateOutputType = {
    id: bigint | null
    offer_id: bigint | null
    category_id: bigint | null
  }

  export type Offer_categoryMinAggregateOutputType = {
    id: bigint | null
    offer_id: bigint | null
    category_id: bigint | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Offer_categoryMaxAggregateOutputType = {
    id: bigint | null
    offer_id: bigint | null
    category_id: bigint | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type Offer_categoryCountAggregateOutputType = {
    id: number
    offer_id: number
    category_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type Offer_categoryAvgAggregateInputType = {
    id?: true
    offer_id?: true
    category_id?: true
  }

  export type Offer_categorySumAggregateInputType = {
    id?: true
    offer_id?: true
    category_id?: true
  }

  export type Offer_categoryMinAggregateInputType = {
    id?: true
    offer_id?: true
    category_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Offer_categoryMaxAggregateInputType = {
    id?: true
    offer_id?: true
    category_id?: true
    created_at?: true
    updated_at?: true
  }

  export type Offer_categoryCountAggregateInputType = {
    id?: true
    offer_id?: true
    category_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type Offer_categoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which offer_category to aggregate.
     */
    where?: offer_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offer_categories to fetch.
     */
    orderBy?: offer_categoryOrderByWithRelationInput | offer_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: offer_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offer_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offer_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned offer_categories
    **/
    _count?: true | Offer_categoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Offer_categoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Offer_categorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Offer_categoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Offer_categoryMaxAggregateInputType
  }

  export type GetOffer_categoryAggregateType<T extends Offer_categoryAggregateArgs> = {
        [P in keyof T & keyof AggregateOffer_category]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffer_category[P]>
      : GetScalarType<T[P], AggregateOffer_category[P]>
  }




  export type offer_categoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: offer_categoryWhereInput
    orderBy?: offer_categoryOrderByWithAggregationInput | offer_categoryOrderByWithAggregationInput[]
    by: Offer_categoryScalarFieldEnum[] | Offer_categoryScalarFieldEnum
    having?: offer_categoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Offer_categoryCountAggregateInputType | true
    _avg?: Offer_categoryAvgAggregateInputType
    _sum?: Offer_categorySumAggregateInputType
    _min?: Offer_categoryMinAggregateInputType
    _max?: Offer_categoryMaxAggregateInputType
  }

  export type Offer_categoryGroupByOutputType = {
    id: bigint
    offer_id: bigint
    category_id: bigint
    created_at: Date | null
    updated_at: Date | null
    _count: Offer_categoryCountAggregateOutputType | null
    _avg: Offer_categoryAvgAggregateOutputType | null
    _sum: Offer_categorySumAggregateOutputType | null
    _min: Offer_categoryMinAggregateOutputType | null
    _max: Offer_categoryMaxAggregateOutputType | null
  }

  type GetOffer_categoryGroupByPayload<T extends offer_categoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Offer_categoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Offer_categoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Offer_categoryGroupByOutputType[P]>
            : GetScalarType<T[P], Offer_categoryGroupByOutputType[P]>
        }
      >
    >


  export type offer_categorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    offer_id?: boolean
    category_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    categories?: boolean | categoriesDefaultArgs<ExtArgs>
    offers?: boolean | offersDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offer_category"]>



  export type offer_categorySelectScalar = {
    id?: boolean
    offer_id?: boolean
    category_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type offer_categoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "offer_id" | "category_id" | "created_at" | "updated_at", ExtArgs["result"]["offer_category"]>
  export type offer_categoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    categories?: boolean | categoriesDefaultArgs<ExtArgs>
    offers?: boolean | offersDefaultArgs<ExtArgs>
  }

  export type $offer_categoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "offer_category"
    objects: {
      categories: Prisma.$categoriesPayload<ExtArgs>
      offers: Prisma.$offersPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      offer_id: bigint
      category_id: bigint
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["offer_category"]>
    composites: {}
  }

  type offer_categoryGetPayload<S extends boolean | null | undefined | offer_categoryDefaultArgs> = $Result.GetResult<Prisma.$offer_categoryPayload, S>

  type offer_categoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<offer_categoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Offer_categoryCountAggregateInputType | true
    }

  export interface offer_categoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['offer_category'], meta: { name: 'offer_category' } }
    /**
     * Find zero or one Offer_category that matches the filter.
     * @param {offer_categoryFindUniqueArgs} args - Arguments to find a Offer_category
     * @example
     * // Get one Offer_category
     * const offer_category = await prisma.offer_category.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends offer_categoryFindUniqueArgs>(args: SelectSubset<T, offer_categoryFindUniqueArgs<ExtArgs>>): Prisma__offer_categoryClient<$Result.GetResult<Prisma.$offer_categoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Offer_category that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {offer_categoryFindUniqueOrThrowArgs} args - Arguments to find a Offer_category
     * @example
     * // Get one Offer_category
     * const offer_category = await prisma.offer_category.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends offer_categoryFindUniqueOrThrowArgs>(args: SelectSubset<T, offer_categoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__offer_categoryClient<$Result.GetResult<Prisma.$offer_categoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Offer_category that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offer_categoryFindFirstArgs} args - Arguments to find a Offer_category
     * @example
     * // Get one Offer_category
     * const offer_category = await prisma.offer_category.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends offer_categoryFindFirstArgs>(args?: SelectSubset<T, offer_categoryFindFirstArgs<ExtArgs>>): Prisma__offer_categoryClient<$Result.GetResult<Prisma.$offer_categoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Offer_category that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offer_categoryFindFirstOrThrowArgs} args - Arguments to find a Offer_category
     * @example
     * // Get one Offer_category
     * const offer_category = await prisma.offer_category.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends offer_categoryFindFirstOrThrowArgs>(args?: SelectSubset<T, offer_categoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__offer_categoryClient<$Result.GetResult<Prisma.$offer_categoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Offer_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offer_categoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offer_categories
     * const offer_categories = await prisma.offer_category.findMany()
     * 
     * // Get first 10 Offer_categories
     * const offer_categories = await prisma.offer_category.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offer_categoryWithIdOnly = await prisma.offer_category.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends offer_categoryFindManyArgs>(args?: SelectSubset<T, offer_categoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$offer_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Offer_category.
     * @param {offer_categoryCreateArgs} args - Arguments to create a Offer_category.
     * @example
     * // Create one Offer_category
     * const Offer_category = await prisma.offer_category.create({
     *   data: {
     *     // ... data to create a Offer_category
     *   }
     * })
     * 
     */
    create<T extends offer_categoryCreateArgs>(args: SelectSubset<T, offer_categoryCreateArgs<ExtArgs>>): Prisma__offer_categoryClient<$Result.GetResult<Prisma.$offer_categoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Offer_categories.
     * @param {offer_categoryCreateManyArgs} args - Arguments to create many Offer_categories.
     * @example
     * // Create many Offer_categories
     * const offer_category = await prisma.offer_category.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends offer_categoryCreateManyArgs>(args?: SelectSubset<T, offer_categoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Offer_category.
     * @param {offer_categoryDeleteArgs} args - Arguments to delete one Offer_category.
     * @example
     * // Delete one Offer_category
     * const Offer_category = await prisma.offer_category.delete({
     *   where: {
     *     // ... filter to delete one Offer_category
     *   }
     * })
     * 
     */
    delete<T extends offer_categoryDeleteArgs>(args: SelectSubset<T, offer_categoryDeleteArgs<ExtArgs>>): Prisma__offer_categoryClient<$Result.GetResult<Prisma.$offer_categoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Offer_category.
     * @param {offer_categoryUpdateArgs} args - Arguments to update one Offer_category.
     * @example
     * // Update one Offer_category
     * const offer_category = await prisma.offer_category.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends offer_categoryUpdateArgs>(args: SelectSubset<T, offer_categoryUpdateArgs<ExtArgs>>): Prisma__offer_categoryClient<$Result.GetResult<Prisma.$offer_categoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Offer_categories.
     * @param {offer_categoryDeleteManyArgs} args - Arguments to filter Offer_categories to delete.
     * @example
     * // Delete a few Offer_categories
     * const { count } = await prisma.offer_category.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends offer_categoryDeleteManyArgs>(args?: SelectSubset<T, offer_categoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offer_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offer_categoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offer_categories
     * const offer_category = await prisma.offer_category.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends offer_categoryUpdateManyArgs>(args: SelectSubset<T, offer_categoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Offer_category.
     * @param {offer_categoryUpsertArgs} args - Arguments to update or create a Offer_category.
     * @example
     * // Update or create a Offer_category
     * const offer_category = await prisma.offer_category.upsert({
     *   create: {
     *     // ... data to create a Offer_category
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offer_category we want to update
     *   }
     * })
     */
    upsert<T extends offer_categoryUpsertArgs>(args: SelectSubset<T, offer_categoryUpsertArgs<ExtArgs>>): Prisma__offer_categoryClient<$Result.GetResult<Prisma.$offer_categoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Offer_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offer_categoryCountArgs} args - Arguments to filter Offer_categories to count.
     * @example
     * // Count the number of Offer_categories
     * const count = await prisma.offer_category.count({
     *   where: {
     *     // ... the filter for the Offer_categories we want to count
     *   }
     * })
    **/
    count<T extends offer_categoryCountArgs>(
      args?: Subset<T, offer_categoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Offer_categoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offer_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Offer_categoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Offer_categoryAggregateArgs>(args: Subset<T, Offer_categoryAggregateArgs>): Prisma.PrismaPromise<GetOffer_categoryAggregateType<T>>

    /**
     * Group by Offer_category.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offer_categoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends offer_categoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: offer_categoryGroupByArgs['orderBy'] }
        : { orderBy?: offer_categoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, offer_categoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffer_categoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the offer_category model
   */
  readonly fields: offer_categoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for offer_category.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__offer_categoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    categories<T extends categoriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, categoriesDefaultArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    offers<T extends offersDefaultArgs<ExtArgs> = {}>(args?: Subset<T, offersDefaultArgs<ExtArgs>>): Prisma__offersClient<$Result.GetResult<Prisma.$offersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the offer_category model
   */
  interface offer_categoryFieldRefs {
    readonly id: FieldRef<"offer_category", 'BigInt'>
    readonly offer_id: FieldRef<"offer_category", 'BigInt'>
    readonly category_id: FieldRef<"offer_category", 'BigInt'>
    readonly created_at: FieldRef<"offer_category", 'DateTime'>
    readonly updated_at: FieldRef<"offer_category", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * offer_category findUnique
   */
  export type offer_categoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offer_category
     */
    select?: offer_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the offer_category
     */
    omit?: offer_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offer_categoryInclude<ExtArgs> | null
    /**
     * Filter, which offer_category to fetch.
     */
    where: offer_categoryWhereUniqueInput
  }

  /**
   * offer_category findUniqueOrThrow
   */
  export type offer_categoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offer_category
     */
    select?: offer_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the offer_category
     */
    omit?: offer_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offer_categoryInclude<ExtArgs> | null
    /**
     * Filter, which offer_category to fetch.
     */
    where: offer_categoryWhereUniqueInput
  }

  /**
   * offer_category findFirst
   */
  export type offer_categoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offer_category
     */
    select?: offer_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the offer_category
     */
    omit?: offer_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offer_categoryInclude<ExtArgs> | null
    /**
     * Filter, which offer_category to fetch.
     */
    where?: offer_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offer_categories to fetch.
     */
    orderBy?: offer_categoryOrderByWithRelationInput | offer_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for offer_categories.
     */
    cursor?: offer_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offer_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offer_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of offer_categories.
     */
    distinct?: Offer_categoryScalarFieldEnum | Offer_categoryScalarFieldEnum[]
  }

  /**
   * offer_category findFirstOrThrow
   */
  export type offer_categoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offer_category
     */
    select?: offer_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the offer_category
     */
    omit?: offer_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offer_categoryInclude<ExtArgs> | null
    /**
     * Filter, which offer_category to fetch.
     */
    where?: offer_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offer_categories to fetch.
     */
    orderBy?: offer_categoryOrderByWithRelationInput | offer_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for offer_categories.
     */
    cursor?: offer_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offer_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offer_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of offer_categories.
     */
    distinct?: Offer_categoryScalarFieldEnum | Offer_categoryScalarFieldEnum[]
  }

  /**
   * offer_category findMany
   */
  export type offer_categoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offer_category
     */
    select?: offer_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the offer_category
     */
    omit?: offer_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offer_categoryInclude<ExtArgs> | null
    /**
     * Filter, which offer_categories to fetch.
     */
    where?: offer_categoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offer_categories to fetch.
     */
    orderBy?: offer_categoryOrderByWithRelationInput | offer_categoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing offer_categories.
     */
    cursor?: offer_categoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offer_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offer_categories.
     */
    skip?: number
    distinct?: Offer_categoryScalarFieldEnum | Offer_categoryScalarFieldEnum[]
  }

  /**
   * offer_category create
   */
  export type offer_categoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offer_category
     */
    select?: offer_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the offer_category
     */
    omit?: offer_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offer_categoryInclude<ExtArgs> | null
    /**
     * The data needed to create a offer_category.
     */
    data: XOR<offer_categoryCreateInput, offer_categoryUncheckedCreateInput>
  }

  /**
   * offer_category createMany
   */
  export type offer_categoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many offer_categories.
     */
    data: offer_categoryCreateManyInput | offer_categoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * offer_category update
   */
  export type offer_categoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offer_category
     */
    select?: offer_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the offer_category
     */
    omit?: offer_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offer_categoryInclude<ExtArgs> | null
    /**
     * The data needed to update a offer_category.
     */
    data: XOR<offer_categoryUpdateInput, offer_categoryUncheckedUpdateInput>
    /**
     * Choose, which offer_category to update.
     */
    where: offer_categoryWhereUniqueInput
  }

  /**
   * offer_category updateMany
   */
  export type offer_categoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update offer_categories.
     */
    data: XOR<offer_categoryUpdateManyMutationInput, offer_categoryUncheckedUpdateManyInput>
    /**
     * Filter which offer_categories to update
     */
    where?: offer_categoryWhereInput
    /**
     * Limit how many offer_categories to update.
     */
    limit?: number
  }

  /**
   * offer_category upsert
   */
  export type offer_categoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offer_category
     */
    select?: offer_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the offer_category
     */
    omit?: offer_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offer_categoryInclude<ExtArgs> | null
    /**
     * The filter to search for the offer_category to update in case it exists.
     */
    where: offer_categoryWhereUniqueInput
    /**
     * In case the offer_category found by the `where` argument doesn't exist, create a new offer_category with this data.
     */
    create: XOR<offer_categoryCreateInput, offer_categoryUncheckedCreateInput>
    /**
     * In case the offer_category was found with the provided `where` argument, update it with this data.
     */
    update: XOR<offer_categoryUpdateInput, offer_categoryUncheckedUpdateInput>
  }

  /**
   * offer_category delete
   */
  export type offer_categoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offer_category
     */
    select?: offer_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the offer_category
     */
    omit?: offer_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offer_categoryInclude<ExtArgs> | null
    /**
     * Filter which offer_category to delete.
     */
    where: offer_categoryWhereUniqueInput
  }

  /**
   * offer_category deleteMany
   */
  export type offer_categoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which offer_categories to delete
     */
    where?: offer_categoryWhereInput
    /**
     * Limit how many offer_categories to delete.
     */
    limit?: number
  }

  /**
   * offer_category without action
   */
  export type offer_categoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offer_category
     */
    select?: offer_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the offer_category
     */
    omit?: offer_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offer_categoryInclude<ExtArgs> | null
  }


  /**
   * Model offers
   */

  export type AggregateOffers = {
    _count: OffersCountAggregateOutputType | null
    _avg: OffersAvgAggregateOutputType | null
    _sum: OffersSumAggregateOutputType | null
    _min: OffersMinAggregateOutputType | null
    _max: OffersMaxAggregateOutputType | null
  }

  export type OffersAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
    store_id: number | null
    category_id: number | null
    price: Decimal | null
    product_price: Decimal | null
    old_price: Decimal | null
  }

  export type OffersSumAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
    store_id: bigint | null
    category_id: bigint | null
    price: Decimal | null
    product_price: Decimal | null
    old_price: Decimal | null
  }

  export type OffersMinAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
    store_id: bigint | null
    category_id: bigint | null
    title: string | null
    description: string | null
    product_url: string | null
    image_url: string | null
    price: Decimal | null
    code: string | null
    start_date: Date | null
    end_date: Date | null
    link: string | null
    is_featured: boolean | null
    is_exclusive: boolean | null
    is_deal: boolean | null
    path: string | null
    thumbnail: string | null
    sku: string | null
    product_name: string | null
    product_price: Decimal | null
    old_price: Decimal | null
    source: string | null
    type: $Enums.offers_type | null
    external_id: string | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OffersMaxAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
    store_id: bigint | null
    category_id: bigint | null
    title: string | null
    description: string | null
    product_url: string | null
    image_url: string | null
    price: Decimal | null
    code: string | null
    start_date: Date | null
    end_date: Date | null
    link: string | null
    is_featured: boolean | null
    is_exclusive: boolean | null
    is_deal: boolean | null
    path: string | null
    thumbnail: string | null
    sku: string | null
    product_name: string | null
    product_price: Decimal | null
    old_price: Decimal | null
    source: string | null
    type: $Enums.offers_type | null
    external_id: string | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type OffersCountAggregateOutputType = {
    id: number
    company_id: number
    store_id: number
    category_id: number
    title: number
    description: number
    product_url: number
    image_url: number
    price: number
    code: number
    start_date: number
    end_date: number
    link: number
    is_featured: number
    is_exclusive: number
    is_deal: number
    path: number
    thumbnail: number
    sku: number
    product_name: number
    product_price: number
    old_price: number
    source: number
    type: number
    external_id: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type OffersAvgAggregateInputType = {
    id?: true
    company_id?: true
    store_id?: true
    category_id?: true
    price?: true
    product_price?: true
    old_price?: true
  }

  export type OffersSumAggregateInputType = {
    id?: true
    company_id?: true
    store_id?: true
    category_id?: true
    price?: true
    product_price?: true
    old_price?: true
  }

  export type OffersMinAggregateInputType = {
    id?: true
    company_id?: true
    store_id?: true
    category_id?: true
    title?: true
    description?: true
    product_url?: true
    image_url?: true
    price?: true
    code?: true
    start_date?: true
    end_date?: true
    link?: true
    is_featured?: true
    is_exclusive?: true
    is_deal?: true
    path?: true
    thumbnail?: true
    sku?: true
    product_name?: true
    product_price?: true
    old_price?: true
    source?: true
    type?: true
    external_id?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type OffersMaxAggregateInputType = {
    id?: true
    company_id?: true
    store_id?: true
    category_id?: true
    title?: true
    description?: true
    product_url?: true
    image_url?: true
    price?: true
    code?: true
    start_date?: true
    end_date?: true
    link?: true
    is_featured?: true
    is_exclusive?: true
    is_deal?: true
    path?: true
    thumbnail?: true
    sku?: true
    product_name?: true
    product_price?: true
    old_price?: true
    source?: true
    type?: true
    external_id?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type OffersCountAggregateInputType = {
    id?: true
    company_id?: true
    store_id?: true
    category_id?: true
    title?: true
    description?: true
    product_url?: true
    image_url?: true
    price?: true
    code?: true
    start_date?: true
    end_date?: true
    link?: true
    is_featured?: true
    is_exclusive?: true
    is_deal?: true
    path?: true
    thumbnail?: true
    sku?: true
    product_name?: true
    product_price?: true
    old_price?: true
    source?: true
    type?: true
    external_id?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type OffersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which offers to aggregate.
     */
    where?: offersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offers to fetch.
     */
    orderBy?: offersOrderByWithRelationInput | offersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: offersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned offers
    **/
    _count?: true | OffersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OffersAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OffersSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OffersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OffersMaxAggregateInputType
  }

  export type GetOffersAggregateType<T extends OffersAggregateArgs> = {
        [P in keyof T & keyof AggregateOffers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOffers[P]>
      : GetScalarType<T[P], AggregateOffers[P]>
  }




  export type offersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: offersWhereInput
    orderBy?: offersOrderByWithAggregationInput | offersOrderByWithAggregationInput[]
    by: OffersScalarFieldEnum[] | OffersScalarFieldEnum
    having?: offersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OffersCountAggregateInputType | true
    _avg?: OffersAvgAggregateInputType
    _sum?: OffersSumAggregateInputType
    _min?: OffersMinAggregateInputType
    _max?: OffersMaxAggregateInputType
  }

  export type OffersGroupByOutputType = {
    id: bigint
    company_id: bigint
    store_id: bigint
    category_id: bigint | null
    title: string
    description: string | null
    product_url: string | null
    image_url: string | null
    price: Decimal | null
    code: string | null
    start_date: Date | null
    end_date: Date | null
    link: string | null
    is_featured: boolean
    is_exclusive: boolean
    is_deal: boolean
    path: string | null
    thumbnail: string | null
    sku: string | null
    product_name: string | null
    product_price: Decimal | null
    old_price: Decimal | null
    source: string | null
    type: $Enums.offers_type
    external_id: string | null
    status: boolean
    created_at: Date | null
    updated_at: Date | null
    _count: OffersCountAggregateOutputType | null
    _avg: OffersAvgAggregateOutputType | null
    _sum: OffersSumAggregateOutputType | null
    _min: OffersMinAggregateOutputType | null
    _max: OffersMaxAggregateOutputType | null
  }

  type GetOffersGroupByPayload<T extends offersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OffersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OffersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OffersGroupByOutputType[P]>
            : GetScalarType<T[P], OffersGroupByOutputType[P]>
        }
      >
    >


  export type offersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    store_id?: boolean
    category_id?: boolean
    title?: boolean
    description?: boolean
    product_url?: boolean
    image_url?: boolean
    price?: boolean
    code?: boolean
    start_date?: boolean
    end_date?: boolean
    link?: boolean
    is_featured?: boolean
    is_exclusive?: boolean
    is_deal?: boolean
    path?: boolean
    thumbnail?: boolean
    sku?: boolean
    product_name?: boolean
    product_price?: boolean
    old_price?: boolean
    source?: boolean
    type?: boolean
    external_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    offer_category?: boolean | offers$offer_categoryArgs<ExtArgs>
    categories?: boolean | offers$categoriesArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    stores?: boolean | storesDefaultArgs<ExtArgs>
    _count?: boolean | OffersCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["offers"]>



  export type offersSelectScalar = {
    id?: boolean
    company_id?: boolean
    store_id?: boolean
    category_id?: boolean
    title?: boolean
    description?: boolean
    product_url?: boolean
    image_url?: boolean
    price?: boolean
    code?: boolean
    start_date?: boolean
    end_date?: boolean
    link?: boolean
    is_featured?: boolean
    is_exclusive?: boolean
    is_deal?: boolean
    path?: boolean
    thumbnail?: boolean
    sku?: boolean
    product_name?: boolean
    product_price?: boolean
    old_price?: boolean
    source?: boolean
    type?: boolean
    external_id?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type offersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "store_id" | "category_id" | "title" | "description" | "product_url" | "image_url" | "price" | "code" | "start_date" | "end_date" | "link" | "is_featured" | "is_exclusive" | "is_deal" | "path" | "thumbnail" | "sku" | "product_name" | "product_price" | "old_price" | "source" | "type" | "external_id" | "status" | "created_at" | "updated_at", ExtArgs["result"]["offers"]>
  export type offersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offer_category?: boolean | offers$offer_categoryArgs<ExtArgs>
    categories?: boolean | offers$categoriesArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    stores?: boolean | storesDefaultArgs<ExtArgs>
    _count?: boolean | OffersCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $offersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "offers"
    objects: {
      offer_category: Prisma.$offer_categoryPayload<ExtArgs>[]
      categories: Prisma.$categoriesPayload<ExtArgs> | null
      companies: Prisma.$companiesPayload<ExtArgs>
      stores: Prisma.$storesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      company_id: bigint
      store_id: bigint
      category_id: bigint | null
      title: string
      description: string | null
      product_url: string | null
      image_url: string | null
      price: Prisma.Decimal | null
      code: string | null
      start_date: Date | null
      end_date: Date | null
      link: string | null
      is_featured: boolean
      is_exclusive: boolean
      is_deal: boolean
      path: string | null
      thumbnail: string | null
      sku: string | null
      product_name: string | null
      product_price: Prisma.Decimal | null
      old_price: Prisma.Decimal | null
      source: string | null
      type: $Enums.offers_type
      external_id: string | null
      status: boolean
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["offers"]>
    composites: {}
  }

  type offersGetPayload<S extends boolean | null | undefined | offersDefaultArgs> = $Result.GetResult<Prisma.$offersPayload, S>

  type offersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<offersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OffersCountAggregateInputType | true
    }

  export interface offersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['offers'], meta: { name: 'offers' } }
    /**
     * Find zero or one Offers that matches the filter.
     * @param {offersFindUniqueArgs} args - Arguments to find a Offers
     * @example
     * // Get one Offers
     * const offers = await prisma.offers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends offersFindUniqueArgs>(args: SelectSubset<T, offersFindUniqueArgs<ExtArgs>>): Prisma__offersClient<$Result.GetResult<Prisma.$offersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Offers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {offersFindUniqueOrThrowArgs} args - Arguments to find a Offers
     * @example
     * // Get one Offers
     * const offers = await prisma.offers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends offersFindUniqueOrThrowArgs>(args: SelectSubset<T, offersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__offersClient<$Result.GetResult<Prisma.$offersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offersFindFirstArgs} args - Arguments to find a Offers
     * @example
     * // Get one Offers
     * const offers = await prisma.offers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends offersFindFirstArgs>(args?: SelectSubset<T, offersFindFirstArgs<ExtArgs>>): Prisma__offersClient<$Result.GetResult<Prisma.$offersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Offers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offersFindFirstOrThrowArgs} args - Arguments to find a Offers
     * @example
     * // Get one Offers
     * const offers = await prisma.offers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends offersFindFirstOrThrowArgs>(args?: SelectSubset<T, offersFindFirstOrThrowArgs<ExtArgs>>): Prisma__offersClient<$Result.GetResult<Prisma.$offersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Offers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Offers
     * const offers = await prisma.offers.findMany()
     * 
     * // Get first 10 Offers
     * const offers = await prisma.offers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const offersWithIdOnly = await prisma.offers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends offersFindManyArgs>(args?: SelectSubset<T, offersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$offersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Offers.
     * @param {offersCreateArgs} args - Arguments to create a Offers.
     * @example
     * // Create one Offers
     * const Offers = await prisma.offers.create({
     *   data: {
     *     // ... data to create a Offers
     *   }
     * })
     * 
     */
    create<T extends offersCreateArgs>(args: SelectSubset<T, offersCreateArgs<ExtArgs>>): Prisma__offersClient<$Result.GetResult<Prisma.$offersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Offers.
     * @param {offersCreateManyArgs} args - Arguments to create many Offers.
     * @example
     * // Create many Offers
     * const offers = await prisma.offers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends offersCreateManyArgs>(args?: SelectSubset<T, offersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Offers.
     * @param {offersDeleteArgs} args - Arguments to delete one Offers.
     * @example
     * // Delete one Offers
     * const Offers = await prisma.offers.delete({
     *   where: {
     *     // ... filter to delete one Offers
     *   }
     * })
     * 
     */
    delete<T extends offersDeleteArgs>(args: SelectSubset<T, offersDeleteArgs<ExtArgs>>): Prisma__offersClient<$Result.GetResult<Prisma.$offersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Offers.
     * @param {offersUpdateArgs} args - Arguments to update one Offers.
     * @example
     * // Update one Offers
     * const offers = await prisma.offers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends offersUpdateArgs>(args: SelectSubset<T, offersUpdateArgs<ExtArgs>>): Prisma__offersClient<$Result.GetResult<Prisma.$offersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Offers.
     * @param {offersDeleteManyArgs} args - Arguments to filter Offers to delete.
     * @example
     * // Delete a few Offers
     * const { count } = await prisma.offers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends offersDeleteManyArgs>(args?: SelectSubset<T, offersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Offers
     * const offers = await prisma.offers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends offersUpdateManyArgs>(args: SelectSubset<T, offersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Offers.
     * @param {offersUpsertArgs} args - Arguments to update or create a Offers.
     * @example
     * // Update or create a Offers
     * const offers = await prisma.offers.upsert({
     *   create: {
     *     // ... data to create a Offers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Offers we want to update
     *   }
     * })
     */
    upsert<T extends offersUpsertArgs>(args: SelectSubset<T, offersUpsertArgs<ExtArgs>>): Prisma__offersClient<$Result.GetResult<Prisma.$offersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offersCountArgs} args - Arguments to filter Offers to count.
     * @example
     * // Count the number of Offers
     * const count = await prisma.offers.count({
     *   where: {
     *     // ... the filter for the Offers we want to count
     *   }
     * })
    **/
    count<T extends offersCountArgs>(
      args?: Subset<T, offersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OffersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OffersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OffersAggregateArgs>(args: Subset<T, OffersAggregateArgs>): Prisma.PrismaPromise<GetOffersAggregateType<T>>

    /**
     * Group by Offers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {offersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends offersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: offersGroupByArgs['orderBy'] }
        : { orderBy?: offersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, offersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOffersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the offers model
   */
  readonly fields: offersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for offers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__offersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    offer_category<T extends offers$offer_categoryArgs<ExtArgs> = {}>(args?: Subset<T, offers$offer_categoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$offer_categoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    categories<T extends offers$categoriesArgs<ExtArgs> = {}>(args?: Subset<T, offers$categoriesArgs<ExtArgs>>): Prisma__categoriesClient<$Result.GetResult<Prisma.$categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    stores<T extends storesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, storesDefaultArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the offers model
   */
  interface offersFieldRefs {
    readonly id: FieldRef<"offers", 'BigInt'>
    readonly company_id: FieldRef<"offers", 'BigInt'>
    readonly store_id: FieldRef<"offers", 'BigInt'>
    readonly category_id: FieldRef<"offers", 'BigInt'>
    readonly title: FieldRef<"offers", 'String'>
    readonly description: FieldRef<"offers", 'String'>
    readonly product_url: FieldRef<"offers", 'String'>
    readonly image_url: FieldRef<"offers", 'String'>
    readonly price: FieldRef<"offers", 'Decimal'>
    readonly code: FieldRef<"offers", 'String'>
    readonly start_date: FieldRef<"offers", 'DateTime'>
    readonly end_date: FieldRef<"offers", 'DateTime'>
    readonly link: FieldRef<"offers", 'String'>
    readonly is_featured: FieldRef<"offers", 'Boolean'>
    readonly is_exclusive: FieldRef<"offers", 'Boolean'>
    readonly is_deal: FieldRef<"offers", 'Boolean'>
    readonly path: FieldRef<"offers", 'String'>
    readonly thumbnail: FieldRef<"offers", 'String'>
    readonly sku: FieldRef<"offers", 'String'>
    readonly product_name: FieldRef<"offers", 'String'>
    readonly product_price: FieldRef<"offers", 'Decimal'>
    readonly old_price: FieldRef<"offers", 'Decimal'>
    readonly source: FieldRef<"offers", 'String'>
    readonly type: FieldRef<"offers", 'offers_type'>
    readonly external_id: FieldRef<"offers", 'String'>
    readonly status: FieldRef<"offers", 'Boolean'>
    readonly created_at: FieldRef<"offers", 'DateTime'>
    readonly updated_at: FieldRef<"offers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * offers findUnique
   */
  export type offersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offers
     */
    select?: offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the offers
     */
    omit?: offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offersInclude<ExtArgs> | null
    /**
     * Filter, which offers to fetch.
     */
    where: offersWhereUniqueInput
  }

  /**
   * offers findUniqueOrThrow
   */
  export type offersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offers
     */
    select?: offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the offers
     */
    omit?: offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offersInclude<ExtArgs> | null
    /**
     * Filter, which offers to fetch.
     */
    where: offersWhereUniqueInput
  }

  /**
   * offers findFirst
   */
  export type offersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offers
     */
    select?: offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the offers
     */
    omit?: offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offersInclude<ExtArgs> | null
    /**
     * Filter, which offers to fetch.
     */
    where?: offersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offers to fetch.
     */
    orderBy?: offersOrderByWithRelationInput | offersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for offers.
     */
    cursor?: offersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of offers.
     */
    distinct?: OffersScalarFieldEnum | OffersScalarFieldEnum[]
  }

  /**
   * offers findFirstOrThrow
   */
  export type offersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offers
     */
    select?: offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the offers
     */
    omit?: offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offersInclude<ExtArgs> | null
    /**
     * Filter, which offers to fetch.
     */
    where?: offersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offers to fetch.
     */
    orderBy?: offersOrderByWithRelationInput | offersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for offers.
     */
    cursor?: offersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of offers.
     */
    distinct?: OffersScalarFieldEnum | OffersScalarFieldEnum[]
  }

  /**
   * offers findMany
   */
  export type offersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offers
     */
    select?: offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the offers
     */
    omit?: offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offersInclude<ExtArgs> | null
    /**
     * Filter, which offers to fetch.
     */
    where?: offersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of offers to fetch.
     */
    orderBy?: offersOrderByWithRelationInput | offersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing offers.
     */
    cursor?: offersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` offers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` offers.
     */
    skip?: number
    distinct?: OffersScalarFieldEnum | OffersScalarFieldEnum[]
  }

  /**
   * offers create
   */
  export type offersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offers
     */
    select?: offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the offers
     */
    omit?: offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offersInclude<ExtArgs> | null
    /**
     * The data needed to create a offers.
     */
    data: XOR<offersCreateInput, offersUncheckedCreateInput>
  }

  /**
   * offers createMany
   */
  export type offersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many offers.
     */
    data: offersCreateManyInput | offersCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * offers update
   */
  export type offersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offers
     */
    select?: offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the offers
     */
    omit?: offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offersInclude<ExtArgs> | null
    /**
     * The data needed to update a offers.
     */
    data: XOR<offersUpdateInput, offersUncheckedUpdateInput>
    /**
     * Choose, which offers to update.
     */
    where: offersWhereUniqueInput
  }

  /**
   * offers updateMany
   */
  export type offersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update offers.
     */
    data: XOR<offersUpdateManyMutationInput, offersUncheckedUpdateManyInput>
    /**
     * Filter which offers to update
     */
    where?: offersWhereInput
    /**
     * Limit how many offers to update.
     */
    limit?: number
  }

  /**
   * offers upsert
   */
  export type offersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offers
     */
    select?: offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the offers
     */
    omit?: offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offersInclude<ExtArgs> | null
    /**
     * The filter to search for the offers to update in case it exists.
     */
    where: offersWhereUniqueInput
    /**
     * In case the offers found by the `where` argument doesn't exist, create a new offers with this data.
     */
    create: XOR<offersCreateInput, offersUncheckedCreateInput>
    /**
     * In case the offers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<offersUpdateInput, offersUncheckedUpdateInput>
  }

  /**
   * offers delete
   */
  export type offersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offers
     */
    select?: offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the offers
     */
    omit?: offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offersInclude<ExtArgs> | null
    /**
     * Filter which offers to delete.
     */
    where: offersWhereUniqueInput
  }

  /**
   * offers deleteMany
   */
  export type offersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which offers to delete
     */
    where?: offersWhereInput
    /**
     * Limit how many offers to delete.
     */
    limit?: number
  }

  /**
   * offers.offer_category
   */
  export type offers$offer_categoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offer_category
     */
    select?: offer_categorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the offer_category
     */
    omit?: offer_categoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offer_categoryInclude<ExtArgs> | null
    where?: offer_categoryWhereInput
    orderBy?: offer_categoryOrderByWithRelationInput | offer_categoryOrderByWithRelationInput[]
    cursor?: offer_categoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Offer_categoryScalarFieldEnum | Offer_categoryScalarFieldEnum[]
  }

  /**
   * offers.categories
   */
  export type offers$categoriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the categories
     */
    select?: categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the categories
     */
    omit?: categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: categoriesInclude<ExtArgs> | null
    where?: categoriesWhereInput
  }

  /**
   * offers without action
   */
  export type offersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offers
     */
    select?: offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the offers
     */
    omit?: offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offersInclude<ExtArgs> | null
  }


  /**
   * Model payments
   */

  export type AggregatePayments = {
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  export type PaymentsAvgAggregateOutputType = {
    id: number | null
    company_subscription_id: number | null
    amount: Decimal | null
  }

  export type PaymentsSumAggregateOutputType = {
    id: bigint | null
    company_subscription_id: bigint | null
    amount: Decimal | null
  }

  export type PaymentsMinAggregateOutputType = {
    id: bigint | null
    company_subscription_id: bigint | null
    amount: Decimal | null
    payment_method: string | null
    payment_status: string | null
    transaction_id: string | null
    paid_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentsMaxAggregateOutputType = {
    id: bigint | null
    company_subscription_id: bigint | null
    amount: Decimal | null
    payment_method: string | null
    payment_status: string | null
    transaction_id: string | null
    paid_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PaymentsCountAggregateOutputType = {
    id: number
    company_subscription_id: number
    amount: number
    payment_method: number
    payment_status: number
    transaction_id: number
    paid_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PaymentsAvgAggregateInputType = {
    id?: true
    company_subscription_id?: true
    amount?: true
  }

  export type PaymentsSumAggregateInputType = {
    id?: true
    company_subscription_id?: true
    amount?: true
  }

  export type PaymentsMinAggregateInputType = {
    id?: true
    company_subscription_id?: true
    amount?: true
    payment_method?: true
    payment_status?: true
    transaction_id?: true
    paid_at?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentsMaxAggregateInputType = {
    id?: true
    company_subscription_id?: true
    amount?: true
    payment_method?: true
    payment_status?: true
    transaction_id?: true
    paid_at?: true
    created_at?: true
    updated_at?: true
  }

  export type PaymentsCountAggregateInputType = {
    id?: true
    company_subscription_id?: true
    amount?: true
    payment_method?: true
    payment_status?: true
    transaction_id?: true
    paid_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PaymentsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to aggregate.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned payments
    **/
    _count?: true | PaymentsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentsMaxAggregateInputType
  }

  export type GetPaymentsAggregateType<T extends PaymentsAggregateArgs> = {
        [P in keyof T & keyof AggregatePayments]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayments[P]>
      : GetScalarType<T[P], AggregatePayments[P]>
  }




  export type paymentsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: paymentsWhereInput
    orderBy?: paymentsOrderByWithAggregationInput | paymentsOrderByWithAggregationInput[]
    by: PaymentsScalarFieldEnum[] | PaymentsScalarFieldEnum
    having?: paymentsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentsCountAggregateInputType | true
    _avg?: PaymentsAvgAggregateInputType
    _sum?: PaymentsSumAggregateInputType
    _min?: PaymentsMinAggregateInputType
    _max?: PaymentsMaxAggregateInputType
  }

  export type PaymentsGroupByOutputType = {
    id: bigint
    company_subscription_id: bigint
    amount: Decimal
    payment_method: string
    payment_status: string
    transaction_id: string | null
    paid_at: Date | null
    created_at: Date | null
    updated_at: Date | null
    _count: PaymentsCountAggregateOutputType | null
    _avg: PaymentsAvgAggregateOutputType | null
    _sum: PaymentsSumAggregateOutputType | null
    _min: PaymentsMinAggregateOutputType | null
    _max: PaymentsMaxAggregateOutputType | null
  }

  type GetPaymentsGroupByPayload<T extends paymentsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentsGroupByOutputType[P]>
        }
      >
    >


  export type paymentsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_subscription_id?: boolean
    amount?: boolean
    payment_method?: boolean
    payment_status?: boolean
    transaction_id?: boolean
    paid_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    company_subscriptions?: boolean | company_subscriptionsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payments"]>



  export type paymentsSelectScalar = {
    id?: boolean
    company_subscription_id?: boolean
    amount?: boolean
    payment_method?: boolean
    payment_status?: boolean
    transaction_id?: boolean
    paid_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type paymentsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_subscription_id" | "amount" | "payment_method" | "payment_status" | "transaction_id" | "paid_at" | "created_at" | "updated_at", ExtArgs["result"]["payments"]>
  export type paymentsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_subscriptions?: boolean | company_subscriptionsDefaultArgs<ExtArgs>
  }

  export type $paymentsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "payments"
    objects: {
      company_subscriptions: Prisma.$company_subscriptionsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      company_subscription_id: bigint
      amount: Prisma.Decimal
      payment_method: string
      payment_status: string
      transaction_id: string | null
      paid_at: Date | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["payments"]>
    composites: {}
  }

  type paymentsGetPayload<S extends boolean | null | undefined | paymentsDefaultArgs> = $Result.GetResult<Prisma.$paymentsPayload, S>

  type paymentsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<paymentsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentsCountAggregateInputType | true
    }

  export interface paymentsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['payments'], meta: { name: 'payments' } }
    /**
     * Find zero or one Payments that matches the filter.
     * @param {paymentsFindUniqueArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends paymentsFindUniqueArgs>(args: SelectSubset<T, paymentsFindUniqueArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payments that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {paymentsFindUniqueOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends paymentsFindUniqueOrThrowArgs>(args: SelectSubset<T, paymentsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends paymentsFindFirstArgs>(args?: SelectSubset<T, paymentsFindFirstArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payments that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindFirstOrThrowArgs} args - Arguments to find a Payments
     * @example
     * // Get one Payments
     * const payments = await prisma.payments.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends paymentsFindFirstOrThrowArgs>(args?: SelectSubset<T, paymentsFindFirstOrThrowArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payments.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payments.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentsWithIdOnly = await prisma.payments.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends paymentsFindManyArgs>(args?: SelectSubset<T, paymentsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payments.
     * @param {paymentsCreateArgs} args - Arguments to create a Payments.
     * @example
     * // Create one Payments
     * const Payments = await prisma.payments.create({
     *   data: {
     *     // ... data to create a Payments
     *   }
     * })
     * 
     */
    create<T extends paymentsCreateArgs>(args: SelectSubset<T, paymentsCreateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {paymentsCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payments = await prisma.payments.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends paymentsCreateManyArgs>(args?: SelectSubset<T, paymentsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Payments.
     * @param {paymentsDeleteArgs} args - Arguments to delete one Payments.
     * @example
     * // Delete one Payments
     * const Payments = await prisma.payments.delete({
     *   where: {
     *     // ... filter to delete one Payments
     *   }
     * })
     * 
     */
    delete<T extends paymentsDeleteArgs>(args: SelectSubset<T, paymentsDeleteArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payments.
     * @param {paymentsUpdateArgs} args - Arguments to update one Payments.
     * @example
     * // Update one Payments
     * const payments = await prisma.payments.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends paymentsUpdateArgs>(args: SelectSubset<T, paymentsUpdateArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {paymentsDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payments.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends paymentsDeleteManyArgs>(args?: SelectSubset<T, paymentsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payments = await prisma.payments.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends paymentsUpdateManyArgs>(args: SelectSubset<T, paymentsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payments.
     * @param {paymentsUpsertArgs} args - Arguments to update or create a Payments.
     * @example
     * // Update or create a Payments
     * const payments = await prisma.payments.upsert({
     *   create: {
     *     // ... data to create a Payments
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payments we want to update
     *   }
     * })
     */
    upsert<T extends paymentsUpsertArgs>(args: SelectSubset<T, paymentsUpsertArgs<ExtArgs>>): Prisma__paymentsClient<$Result.GetResult<Prisma.$paymentsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payments.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends paymentsCountArgs>(
      args?: Subset<T, paymentsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentsAggregateArgs>(args: Subset<T, PaymentsAggregateArgs>): Prisma.PrismaPromise<GetPaymentsAggregateType<T>>

    /**
     * Group by Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {paymentsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends paymentsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: paymentsGroupByArgs['orderBy'] }
        : { orderBy?: paymentsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, paymentsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the payments model
   */
  readonly fields: paymentsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for payments.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__paymentsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company_subscriptions<T extends company_subscriptionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, company_subscriptionsDefaultArgs<ExtArgs>>): Prisma__company_subscriptionsClient<$Result.GetResult<Prisma.$company_subscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the payments model
   */
  interface paymentsFieldRefs {
    readonly id: FieldRef<"payments", 'BigInt'>
    readonly company_subscription_id: FieldRef<"payments", 'BigInt'>
    readonly amount: FieldRef<"payments", 'Decimal'>
    readonly payment_method: FieldRef<"payments", 'String'>
    readonly payment_status: FieldRef<"payments", 'String'>
    readonly transaction_id: FieldRef<"payments", 'String'>
    readonly paid_at: FieldRef<"payments", 'DateTime'>
    readonly created_at: FieldRef<"payments", 'DateTime'>
    readonly updated_at: FieldRef<"payments", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * payments findUnique
   */
  export type paymentsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findUniqueOrThrow
   */
  export type paymentsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments findFirst
   */
  export type paymentsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findFirstOrThrow
   */
  export type paymentsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of payments.
     */
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments findMany
   */
  export type paymentsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter, which payments to fetch.
     */
    where?: paymentsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of payments to fetch.
     */
    orderBy?: paymentsOrderByWithRelationInput | paymentsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing payments.
     */
    cursor?: paymentsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` payments.
     */
    skip?: number
    distinct?: PaymentsScalarFieldEnum | PaymentsScalarFieldEnum[]
  }

  /**
   * payments create
   */
  export type paymentsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to create a payments.
     */
    data: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
  }

  /**
   * payments createMany
   */
  export type paymentsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many payments.
     */
    data: paymentsCreateManyInput | paymentsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * payments update
   */
  export type paymentsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The data needed to update a payments.
     */
    data: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
    /**
     * Choose, which payments to update.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments updateMany
   */
  export type paymentsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update payments.
     */
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyInput>
    /**
     * Filter which payments to update
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to update.
     */
    limit?: number
  }

  /**
   * payments upsert
   */
  export type paymentsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * The filter to search for the payments to update in case it exists.
     */
    where: paymentsWhereUniqueInput
    /**
     * In case the payments found by the `where` argument doesn't exist, create a new payments with this data.
     */
    create: XOR<paymentsCreateInput, paymentsUncheckedCreateInput>
    /**
     * In case the payments was found with the provided `where` argument, update it with this data.
     */
    update: XOR<paymentsUpdateInput, paymentsUncheckedUpdateInput>
  }

  /**
   * payments delete
   */
  export type paymentsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
    /**
     * Filter which payments to delete.
     */
    where: paymentsWhereUniqueInput
  }

  /**
   * payments deleteMany
   */
  export type paymentsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which payments to delete
     */
    where?: paymentsWhereInput
    /**
     * Limit how many payments to delete.
     */
    limit?: number
  }

  /**
   * payments without action
   */
  export type paymentsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the payments
     */
    select?: paymentsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the payments
     */
    omit?: paymentsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: paymentsInclude<ExtArgs> | null
  }


  /**
   * Model stores
   */

  export type AggregateStores = {
    _count: StoresCountAggregateOutputType | null
    _avg: StoresAvgAggregateOutputType | null
    _sum: StoresSumAggregateOutputType | null
    _min: StoresMinAggregateOutputType | null
    _max: StoresMaxAggregateOutputType | null
  }

  export type StoresAvgAggregateOutputType = {
    id: number | null
    company_id: number | null
    status: number | null
    channelId: number | null
    programId: number | null
    categoryId: number | null
    productFeedId: number | null
  }

  export type StoresSumAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
    status: number | null
    channelId: bigint | null
    programId: bigint | null
    categoryId: bigint | null
    productFeedId: bigint | null
  }

  export type StoresMinAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
    name: string | null
    image: string | null
    description: string | null
    status: number | null
    channelId: bigint | null
    channelName: string | null
    programId: bigint | null
    categoryName: string | null
    categoryId: bigint | null
    productFeedId: bigint | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StoresMaxAggregateOutputType = {
    id: bigint | null
    company_id: bigint | null
    name: string | null
    image: string | null
    description: string | null
    status: number | null
    channelId: bigint | null
    channelName: string | null
    programId: bigint | null
    categoryName: string | null
    categoryId: bigint | null
    productFeedId: bigint | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type StoresCountAggregateOutputType = {
    id: number
    company_id: number
    name: number
    image: number
    description: number
    status: number
    channelId: number
    channelName: number
    programId: number
    categoryName: number
    categoryId: number
    productFeedId: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type StoresAvgAggregateInputType = {
    id?: true
    company_id?: true
    status?: true
    channelId?: true
    programId?: true
    categoryId?: true
    productFeedId?: true
  }

  export type StoresSumAggregateInputType = {
    id?: true
    company_id?: true
    status?: true
    channelId?: true
    programId?: true
    categoryId?: true
    productFeedId?: true
  }

  export type StoresMinAggregateInputType = {
    id?: true
    company_id?: true
    name?: true
    image?: true
    description?: true
    status?: true
    channelId?: true
    channelName?: true
    programId?: true
    categoryName?: true
    categoryId?: true
    productFeedId?: true
    created_at?: true
    updated_at?: true
  }

  export type StoresMaxAggregateInputType = {
    id?: true
    company_id?: true
    name?: true
    image?: true
    description?: true
    status?: true
    channelId?: true
    channelName?: true
    programId?: true
    categoryName?: true
    categoryId?: true
    productFeedId?: true
    created_at?: true
    updated_at?: true
  }

  export type StoresCountAggregateInputType = {
    id?: true
    company_id?: true
    name?: true
    image?: true
    description?: true
    status?: true
    channelId?: true
    channelName?: true
    programId?: true
    categoryName?: true
    categoryId?: true
    productFeedId?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type StoresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stores to aggregate.
     */
    where?: storesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: storesOrderByWithRelationInput | storesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: storesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned stores
    **/
    _count?: true | StoresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StoresAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StoresSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StoresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StoresMaxAggregateInputType
  }

  export type GetStoresAggregateType<T extends StoresAggregateArgs> = {
        [P in keyof T & keyof AggregateStores]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStores[P]>
      : GetScalarType<T[P], AggregateStores[P]>
  }




  export type storesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: storesWhereInput
    orderBy?: storesOrderByWithAggregationInput | storesOrderByWithAggregationInput[]
    by: StoresScalarFieldEnum[] | StoresScalarFieldEnum
    having?: storesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StoresCountAggregateInputType | true
    _avg?: StoresAvgAggregateInputType
    _sum?: StoresSumAggregateInputType
    _min?: StoresMinAggregateInputType
    _max?: StoresMaxAggregateInputType
  }

  export type StoresGroupByOutputType = {
    id: bigint
    company_id: bigint
    name: string
    image: string | null
    description: string | null
    status: number
    channelId: bigint | null
    channelName: string | null
    programId: bigint | null
    categoryName: string | null
    categoryId: bigint | null
    productFeedId: bigint | null
    created_at: Date | null
    updated_at: Date | null
    _count: StoresCountAggregateOutputType | null
    _avg: StoresAvgAggregateOutputType | null
    _sum: StoresSumAggregateOutputType | null
    _min: StoresMinAggregateOutputType | null
    _max: StoresMaxAggregateOutputType | null
  }

  type GetStoresGroupByPayload<T extends storesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StoresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StoresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StoresGroupByOutputType[P]>
            : GetScalarType<T[P], StoresGroupByOutputType[P]>
        }
      >
    >


  export type storesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    company_id?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    status?: boolean
    channelId?: boolean
    channelName?: boolean
    programId?: boolean
    categoryName?: boolean
    categoryId?: boolean
    productFeedId?: boolean
    created_at?: boolean
    updated_at?: boolean
    offers?: boolean | stores$offersArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    _count?: boolean | StoresCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stores"]>



  export type storesSelectScalar = {
    id?: boolean
    company_id?: boolean
    name?: boolean
    image?: boolean
    description?: boolean
    status?: boolean
    channelId?: boolean
    channelName?: boolean
    programId?: boolean
    categoryName?: boolean
    categoryId?: boolean
    productFeedId?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type storesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "company_id" | "name" | "image" | "description" | "status" | "channelId" | "channelName" | "programId" | "categoryName" | "categoryId" | "productFeedId" | "created_at" | "updated_at", ExtArgs["result"]["stores"]>
  export type storesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    offers?: boolean | stores$offersArgs<ExtArgs>
    companies?: boolean | companiesDefaultArgs<ExtArgs>
    _count?: boolean | StoresCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $storesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "stores"
    objects: {
      offers: Prisma.$offersPayload<ExtArgs>[]
      companies: Prisma.$companiesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      company_id: bigint
      name: string
      image: string | null
      description: string | null
      status: number
      channelId: bigint | null
      channelName: string | null
      programId: bigint | null
      categoryName: string | null
      categoryId: bigint | null
      productFeedId: bigint | null
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["stores"]>
    composites: {}
  }

  type storesGetPayload<S extends boolean | null | undefined | storesDefaultArgs> = $Result.GetResult<Prisma.$storesPayload, S>

  type storesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<storesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StoresCountAggregateInputType | true
    }

  export interface storesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['stores'], meta: { name: 'stores' } }
    /**
     * Find zero or one Stores that matches the filter.
     * @param {storesFindUniqueArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends storesFindUniqueArgs>(args: SelectSubset<T, storesFindUniqueArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Stores that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {storesFindUniqueOrThrowArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends storesFindUniqueOrThrowArgs>(args: SelectSubset<T, storesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storesFindFirstArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends storesFindFirstArgs>(args?: SelectSubset<T, storesFindFirstArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Stores that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storesFindFirstOrThrowArgs} args - Arguments to find a Stores
     * @example
     * // Get one Stores
     * const stores = await prisma.stores.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends storesFindFirstOrThrowArgs>(args?: SelectSubset<T, storesFindFirstOrThrowArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Stores that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Stores
     * const stores = await prisma.stores.findMany()
     * 
     * // Get first 10 Stores
     * const stores = await prisma.stores.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const storesWithIdOnly = await prisma.stores.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends storesFindManyArgs>(args?: SelectSubset<T, storesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Stores.
     * @param {storesCreateArgs} args - Arguments to create a Stores.
     * @example
     * // Create one Stores
     * const Stores = await prisma.stores.create({
     *   data: {
     *     // ... data to create a Stores
     *   }
     * })
     * 
     */
    create<T extends storesCreateArgs>(args: SelectSubset<T, storesCreateArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Stores.
     * @param {storesCreateManyArgs} args - Arguments to create many Stores.
     * @example
     * // Create many Stores
     * const stores = await prisma.stores.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends storesCreateManyArgs>(args?: SelectSubset<T, storesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Stores.
     * @param {storesDeleteArgs} args - Arguments to delete one Stores.
     * @example
     * // Delete one Stores
     * const Stores = await prisma.stores.delete({
     *   where: {
     *     // ... filter to delete one Stores
     *   }
     * })
     * 
     */
    delete<T extends storesDeleteArgs>(args: SelectSubset<T, storesDeleteArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Stores.
     * @param {storesUpdateArgs} args - Arguments to update one Stores.
     * @example
     * // Update one Stores
     * const stores = await prisma.stores.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends storesUpdateArgs>(args: SelectSubset<T, storesUpdateArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Stores.
     * @param {storesDeleteManyArgs} args - Arguments to filter Stores to delete.
     * @example
     * // Delete a few Stores
     * const { count } = await prisma.stores.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends storesDeleteManyArgs>(args?: SelectSubset<T, storesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Stores
     * const stores = await prisma.stores.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends storesUpdateManyArgs>(args: SelectSubset<T, storesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Stores.
     * @param {storesUpsertArgs} args - Arguments to update or create a Stores.
     * @example
     * // Update or create a Stores
     * const stores = await prisma.stores.upsert({
     *   create: {
     *     // ... data to create a Stores
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Stores we want to update
     *   }
     * })
     */
    upsert<T extends storesUpsertArgs>(args: SelectSubset<T, storesUpsertArgs<ExtArgs>>): Prisma__storesClient<$Result.GetResult<Prisma.$storesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storesCountArgs} args - Arguments to filter Stores to count.
     * @example
     * // Count the number of Stores
     * const count = await prisma.stores.count({
     *   where: {
     *     // ... the filter for the Stores we want to count
     *   }
     * })
    **/
    count<T extends storesCountArgs>(
      args?: Subset<T, storesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StoresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StoresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StoresAggregateArgs>(args: Subset<T, StoresAggregateArgs>): Prisma.PrismaPromise<GetStoresAggregateType<T>>

    /**
     * Group by Stores.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {storesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends storesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: storesGroupByArgs['orderBy'] }
        : { orderBy?: storesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, storesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStoresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the stores model
   */
  readonly fields: storesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for stores.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__storesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    offers<T extends stores$offersArgs<ExtArgs> = {}>(args?: Subset<T, stores$offersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$offersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    companies<T extends companiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, companiesDefaultArgs<ExtArgs>>): Prisma__companiesClient<$Result.GetResult<Prisma.$companiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the stores model
   */
  interface storesFieldRefs {
    readonly id: FieldRef<"stores", 'BigInt'>
    readonly company_id: FieldRef<"stores", 'BigInt'>
    readonly name: FieldRef<"stores", 'String'>
    readonly image: FieldRef<"stores", 'String'>
    readonly description: FieldRef<"stores", 'String'>
    readonly status: FieldRef<"stores", 'Int'>
    readonly channelId: FieldRef<"stores", 'BigInt'>
    readonly channelName: FieldRef<"stores", 'String'>
    readonly programId: FieldRef<"stores", 'BigInt'>
    readonly categoryName: FieldRef<"stores", 'String'>
    readonly categoryId: FieldRef<"stores", 'BigInt'>
    readonly productFeedId: FieldRef<"stores", 'BigInt'>
    readonly created_at: FieldRef<"stores", 'DateTime'>
    readonly updated_at: FieldRef<"stores", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * stores findUnique
   */
  export type storesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    /**
     * Filter, which stores to fetch.
     */
    where: storesWhereUniqueInput
  }

  /**
   * stores findUniqueOrThrow
   */
  export type storesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    /**
     * Filter, which stores to fetch.
     */
    where: storesWhereUniqueInput
  }

  /**
   * stores findFirst
   */
  export type storesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    /**
     * Filter, which stores to fetch.
     */
    where?: storesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: storesOrderByWithRelationInput | storesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stores.
     */
    cursor?: storesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stores.
     */
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * stores findFirstOrThrow
   */
  export type storesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    /**
     * Filter, which stores to fetch.
     */
    where?: storesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: storesOrderByWithRelationInput | storesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for stores.
     */
    cursor?: storesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of stores.
     */
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * stores findMany
   */
  export type storesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    /**
     * Filter, which stores to fetch.
     */
    where?: storesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of stores to fetch.
     */
    orderBy?: storesOrderByWithRelationInput | storesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing stores.
     */
    cursor?: storesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` stores from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` stores.
     */
    skip?: number
    distinct?: StoresScalarFieldEnum | StoresScalarFieldEnum[]
  }

  /**
   * stores create
   */
  export type storesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    /**
     * The data needed to create a stores.
     */
    data: XOR<storesCreateInput, storesUncheckedCreateInput>
  }

  /**
   * stores createMany
   */
  export type storesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many stores.
     */
    data: storesCreateManyInput | storesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * stores update
   */
  export type storesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    /**
     * The data needed to update a stores.
     */
    data: XOR<storesUpdateInput, storesUncheckedUpdateInput>
    /**
     * Choose, which stores to update.
     */
    where: storesWhereUniqueInput
  }

  /**
   * stores updateMany
   */
  export type storesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update stores.
     */
    data: XOR<storesUpdateManyMutationInput, storesUncheckedUpdateManyInput>
    /**
     * Filter which stores to update
     */
    where?: storesWhereInput
    /**
     * Limit how many stores to update.
     */
    limit?: number
  }

  /**
   * stores upsert
   */
  export type storesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    /**
     * The filter to search for the stores to update in case it exists.
     */
    where: storesWhereUniqueInput
    /**
     * In case the stores found by the `where` argument doesn't exist, create a new stores with this data.
     */
    create: XOR<storesCreateInput, storesUncheckedCreateInput>
    /**
     * In case the stores was found with the provided `where` argument, update it with this data.
     */
    update: XOR<storesUpdateInput, storesUncheckedUpdateInput>
  }

  /**
   * stores delete
   */
  export type storesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
    /**
     * Filter which stores to delete.
     */
    where: storesWhereUniqueInput
  }

  /**
   * stores deleteMany
   */
  export type storesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which stores to delete
     */
    where?: storesWhereInput
    /**
     * Limit how many stores to delete.
     */
    limit?: number
  }

  /**
   * stores.offers
   */
  export type stores$offersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the offers
     */
    select?: offersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the offers
     */
    omit?: offersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: offersInclude<ExtArgs> | null
    where?: offersWhereInput
    orderBy?: offersOrderByWithRelationInput | offersOrderByWithRelationInput[]
    cursor?: offersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OffersScalarFieldEnum | OffersScalarFieldEnum[]
  }

  /**
   * stores without action
   */
  export type storesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the stores
     */
    select?: storesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the stores
     */
    omit?: storesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: storesInclude<ExtArgs> | null
  }


  /**
   * Model subscriptions
   */

  export type AggregateSubscriptions = {
    _count: SubscriptionsCountAggregateOutputType | null
    _avg: SubscriptionsAvgAggregateOutputType | null
    _sum: SubscriptionsSumAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  export type SubscriptionsAvgAggregateOutputType = {
    id: number | null
    price: Decimal | null
    duration: number | null
  }

  export type SubscriptionsSumAggregateOutputType = {
    id: bigint | null
    price: Decimal | null
    duration: number | null
  }

  export type SubscriptionsMinAggregateOutputType = {
    id: bigint | null
    name: string | null
    price: Decimal | null
    duration: number | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubscriptionsMaxAggregateOutputType = {
    id: bigint | null
    name: string | null
    price: Decimal | null
    duration: number | null
    status: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SubscriptionsCountAggregateOutputType = {
    id: number
    name: number
    price: number
    duration: number
    features: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SubscriptionsAvgAggregateInputType = {
    id?: true
    price?: true
    duration?: true
  }

  export type SubscriptionsSumAggregateInputType = {
    id?: true
    price?: true
    duration?: true
  }

  export type SubscriptionsMinAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type SubscriptionsMaxAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type SubscriptionsCountAggregateInputType = {
    id?: true
    name?: true
    price?: true
    duration?: true
    features?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SubscriptionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to aggregate.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subscriptions
    **/
    _count?: true | SubscriptionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubscriptionsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubscriptionsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubscriptionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type GetSubscriptionsAggregateType<T extends SubscriptionsAggregateArgs> = {
        [P in keyof T & keyof AggregateSubscriptions]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubscriptions[P]>
      : GetScalarType<T[P], AggregateSubscriptions[P]>
  }




  export type subscriptionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: subscriptionsWhereInput
    orderBy?: subscriptionsOrderByWithAggregationInput | subscriptionsOrderByWithAggregationInput[]
    by: SubscriptionsScalarFieldEnum[] | SubscriptionsScalarFieldEnum
    having?: subscriptionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubscriptionsCountAggregateInputType | true
    _avg?: SubscriptionsAvgAggregateInputType
    _sum?: SubscriptionsSumAggregateInputType
    _min?: SubscriptionsMinAggregateInputType
    _max?: SubscriptionsMaxAggregateInputType
  }

  export type SubscriptionsGroupByOutputType = {
    id: bigint
    name: string
    price: Decimal
    duration: number
    features: JsonValue | null
    status: boolean
    created_at: Date | null
    updated_at: Date | null
    _count: SubscriptionsCountAggregateOutputType | null
    _avg: SubscriptionsAvgAggregateOutputType | null
    _sum: SubscriptionsSumAggregateOutputType | null
    _min: SubscriptionsMinAggregateOutputType | null
    _max: SubscriptionsMaxAggregateOutputType | null
  }

  type GetSubscriptionsGroupByPayload<T extends subscriptionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubscriptionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubscriptionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
            : GetScalarType<T[P], SubscriptionsGroupByOutputType[P]>
        }
      >
    >


  export type subscriptionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    features?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    company_subscriptions?: boolean | subscriptions$company_subscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subscriptions"]>



  export type subscriptionsSelectScalar = {
    id?: boolean
    name?: boolean
    price?: boolean
    duration?: boolean
    features?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type subscriptionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "price" | "duration" | "features" | "status" | "created_at" | "updated_at", ExtArgs["result"]["subscriptions"]>
  export type subscriptionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    company_subscriptions?: boolean | subscriptions$company_subscriptionsArgs<ExtArgs>
    _count?: boolean | SubscriptionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $subscriptionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "subscriptions"
    objects: {
      company_subscriptions: Prisma.$company_subscriptionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      name: string
      price: Prisma.Decimal
      duration: number
      features: Prisma.JsonValue | null
      status: boolean
      created_at: Date | null
      updated_at: Date | null
    }, ExtArgs["result"]["subscriptions"]>
    composites: {}
  }

  type subscriptionsGetPayload<S extends boolean | null | undefined | subscriptionsDefaultArgs> = $Result.GetResult<Prisma.$subscriptionsPayload, S>

  type subscriptionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<subscriptionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SubscriptionsCountAggregateInputType | true
    }

  export interface subscriptionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['subscriptions'], meta: { name: 'subscriptions' } }
    /**
     * Find zero or one Subscriptions that matches the filter.
     * @param {subscriptionsFindUniqueArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends subscriptionsFindUniqueArgs>(args: SelectSubset<T, subscriptionsFindUniqueArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Subscriptions that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {subscriptionsFindUniqueOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends subscriptionsFindUniqueOrThrowArgs>(args: SelectSubset<T, subscriptionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindFirstArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends subscriptionsFindFirstArgs>(args?: SelectSubset<T, subscriptionsFindFirstArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Subscriptions that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindFirstOrThrowArgs} args - Arguments to find a Subscriptions
     * @example
     * // Get one Subscriptions
     * const subscriptions = await prisma.subscriptions.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends subscriptionsFindFirstOrThrowArgs>(args?: SelectSubset<T, subscriptionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Subscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany()
     * 
     * // Get first 10 Subscriptions
     * const subscriptions = await prisma.subscriptions.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subscriptionsWithIdOnly = await prisma.subscriptions.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends subscriptionsFindManyArgs>(args?: SelectSubset<T, subscriptionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Subscriptions.
     * @param {subscriptionsCreateArgs} args - Arguments to create a Subscriptions.
     * @example
     * // Create one Subscriptions
     * const Subscriptions = await prisma.subscriptions.create({
     *   data: {
     *     // ... data to create a Subscriptions
     *   }
     * })
     * 
     */
    create<T extends subscriptionsCreateArgs>(args: SelectSubset<T, subscriptionsCreateArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Subscriptions.
     * @param {subscriptionsCreateManyArgs} args - Arguments to create many Subscriptions.
     * @example
     * // Create many Subscriptions
     * const subscriptions = await prisma.subscriptions.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends subscriptionsCreateManyArgs>(args?: SelectSubset<T, subscriptionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Subscriptions.
     * @param {subscriptionsDeleteArgs} args - Arguments to delete one Subscriptions.
     * @example
     * // Delete one Subscriptions
     * const Subscriptions = await prisma.subscriptions.delete({
     *   where: {
     *     // ... filter to delete one Subscriptions
     *   }
     * })
     * 
     */
    delete<T extends subscriptionsDeleteArgs>(args: SelectSubset<T, subscriptionsDeleteArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Subscriptions.
     * @param {subscriptionsUpdateArgs} args - Arguments to update one Subscriptions.
     * @example
     * // Update one Subscriptions
     * const subscriptions = await prisma.subscriptions.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends subscriptionsUpdateArgs>(args: SelectSubset<T, subscriptionsUpdateArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Subscriptions.
     * @param {subscriptionsDeleteManyArgs} args - Arguments to filter Subscriptions to delete.
     * @example
     * // Delete a few Subscriptions
     * const { count } = await prisma.subscriptions.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends subscriptionsDeleteManyArgs>(args?: SelectSubset<T, subscriptionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subscriptions
     * const subscriptions = await prisma.subscriptions.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends subscriptionsUpdateManyArgs>(args: SelectSubset<T, subscriptionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subscriptions.
     * @param {subscriptionsUpsertArgs} args - Arguments to update or create a Subscriptions.
     * @example
     * // Update or create a Subscriptions
     * const subscriptions = await prisma.subscriptions.upsert({
     *   create: {
     *     // ... data to create a Subscriptions
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subscriptions we want to update
     *   }
     * })
     */
    upsert<T extends subscriptionsUpsertArgs>(args: SelectSubset<T, subscriptionsUpsertArgs<ExtArgs>>): Prisma__subscriptionsClient<$Result.GetResult<Prisma.$subscriptionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsCountArgs} args - Arguments to filter Subscriptions to count.
     * @example
     * // Count the number of Subscriptions
     * const count = await prisma.subscriptions.count({
     *   where: {
     *     // ... the filter for the Subscriptions we want to count
     *   }
     * })
    **/
    count<T extends subscriptionsCountArgs>(
      args?: Subset<T, subscriptionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubscriptionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubscriptionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubscriptionsAggregateArgs>(args: Subset<T, SubscriptionsAggregateArgs>): Prisma.PrismaPromise<GetSubscriptionsAggregateType<T>>

    /**
     * Group by Subscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subscriptionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends subscriptionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: subscriptionsGroupByArgs['orderBy'] }
        : { orderBy?: subscriptionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, subscriptionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubscriptionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the subscriptions model
   */
  readonly fields: subscriptionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for subscriptions.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__subscriptionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    company_subscriptions<T extends subscriptions$company_subscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, subscriptions$company_subscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$company_subscriptionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the subscriptions model
   */
  interface subscriptionsFieldRefs {
    readonly id: FieldRef<"subscriptions", 'BigInt'>
    readonly name: FieldRef<"subscriptions", 'String'>
    readonly price: FieldRef<"subscriptions", 'Decimal'>
    readonly duration: FieldRef<"subscriptions", 'Int'>
    readonly features: FieldRef<"subscriptions", 'Json'>
    readonly status: FieldRef<"subscriptions", 'Boolean'>
    readonly created_at: FieldRef<"subscriptions", 'DateTime'>
    readonly updated_at: FieldRef<"subscriptions", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * subscriptions findUnique
   */
  export type subscriptionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions findUniqueOrThrow
   */
  export type subscriptionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions findFirst
   */
  export type subscriptionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions findFirstOrThrow
   */
  export type subscriptionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subscriptions.
     */
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions findMany
   */
  export type subscriptionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter, which subscriptions to fetch.
     */
    where?: subscriptionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subscriptions to fetch.
     */
    orderBy?: subscriptionsOrderByWithRelationInput | subscriptionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subscriptions.
     */
    cursor?: subscriptionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subscriptions.
     */
    skip?: number
    distinct?: SubscriptionsScalarFieldEnum | SubscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions create
   */
  export type subscriptionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to create a subscriptions.
     */
    data: XOR<subscriptionsCreateInput, subscriptionsUncheckedCreateInput>
  }

  /**
   * subscriptions createMany
   */
  export type subscriptionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many subscriptions.
     */
    data: subscriptionsCreateManyInput | subscriptionsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * subscriptions update
   */
  export type subscriptionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * The data needed to update a subscriptions.
     */
    data: XOR<subscriptionsUpdateInput, subscriptionsUncheckedUpdateInput>
    /**
     * Choose, which subscriptions to update.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions updateMany
   */
  export type subscriptionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update subscriptions.
     */
    data: XOR<subscriptionsUpdateManyMutationInput, subscriptionsUncheckedUpdateManyInput>
    /**
     * Filter which subscriptions to update
     */
    where?: subscriptionsWhereInput
    /**
     * Limit how many subscriptions to update.
     */
    limit?: number
  }

  /**
   * subscriptions upsert
   */
  export type subscriptionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * The filter to search for the subscriptions to update in case it exists.
     */
    where: subscriptionsWhereUniqueInput
    /**
     * In case the subscriptions found by the `where` argument doesn't exist, create a new subscriptions with this data.
     */
    create: XOR<subscriptionsCreateInput, subscriptionsUncheckedCreateInput>
    /**
     * In case the subscriptions was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subscriptionsUpdateInput, subscriptionsUncheckedUpdateInput>
  }

  /**
   * subscriptions delete
   */
  export type subscriptionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
    /**
     * Filter which subscriptions to delete.
     */
    where: subscriptionsWhereUniqueInput
  }

  /**
   * subscriptions deleteMany
   */
  export type subscriptionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which subscriptions to delete
     */
    where?: subscriptionsWhereInput
    /**
     * Limit how many subscriptions to delete.
     */
    limit?: number
  }

  /**
   * subscriptions.company_subscriptions
   */
  export type subscriptions$company_subscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the company_subscriptions
     */
    select?: company_subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the company_subscriptions
     */
    omit?: company_subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: company_subscriptionsInclude<ExtArgs> | null
    where?: company_subscriptionsWhereInput
    orderBy?: company_subscriptionsOrderByWithRelationInput | company_subscriptionsOrderByWithRelationInput[]
    cursor?: company_subscriptionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Company_subscriptionsScalarFieldEnum | Company_subscriptionsScalarFieldEnum[]
  }

  /**
   * subscriptions without action
   */
  export type subscriptionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the subscriptions
     */
    select?: subscriptionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the subscriptions
     */
    omit?: subscriptionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: subscriptionsInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const Failed_jobsScalarFieldEnum: {
    id: 'id',
    uuid: 'uuid',
    connection: 'connection',
    queue: 'queue',
    payload: 'payload',
    exception: 'exception',
    failed_at: 'failed_at'
  };

  export type Failed_jobsScalarFieldEnum = (typeof Failed_jobsScalarFieldEnum)[keyof typeof Failed_jobsScalarFieldEnum]


  export const JobsScalarFieldEnum: {
    id: 'id',
    queue: 'queue',
    payload: 'payload',
    attempts: 'attempts',
    reserved_at: 'reserved_at',
    available_at: 'available_at',
    created_at: 'created_at'
  };

  export type JobsScalarFieldEnum = (typeof JobsScalarFieldEnum)[keyof typeof JobsScalarFieldEnum]


  export const MigrationsScalarFieldEnum: {
    id: 'id',
    migration: 'migration',
    batch: 'batch'
  };

  export type MigrationsScalarFieldEnum = (typeof MigrationsScalarFieldEnum)[keyof typeof MigrationsScalarFieldEnum]


  export const Model_has_permissionsScalarFieldEnum: {
    permission_id: 'permission_id',
    model_type: 'model_type',
    model_id: 'model_id'
  };

  export type Model_has_permissionsScalarFieldEnum = (typeof Model_has_permissionsScalarFieldEnum)[keyof typeof Model_has_permissionsScalarFieldEnum]


  export const Model_has_rolesScalarFieldEnum: {
    role_id: 'role_id',
    model_type: 'model_type',
    model_id: 'model_id'
  };

  export type Model_has_rolesScalarFieldEnum = (typeof Model_has_rolesScalarFieldEnum)[keyof typeof Model_has_rolesScalarFieldEnum]


  export const Password_reset_tokensScalarFieldEnum: {
    email: 'email',
    token: 'token',
    created_at: 'created_at'
  };

  export type Password_reset_tokensScalarFieldEnum = (typeof Password_reset_tokensScalarFieldEnum)[keyof typeof Password_reset_tokensScalarFieldEnum]


  export const PermissionsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    guard_name: 'guard_name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PermissionsScalarFieldEnum = (typeof PermissionsScalarFieldEnum)[keyof typeof PermissionsScalarFieldEnum]


  export const Role_has_permissionsScalarFieldEnum: {
    permission_id: 'permission_id',
    role_id: 'role_id'
  };

  export type Role_has_permissionsScalarFieldEnum = (typeof Role_has_permissionsScalarFieldEnum)[keyof typeof Role_has_permissionsScalarFieldEnum]


  export const RolesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    guard_name: 'guard_name',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type RolesScalarFieldEnum = (typeof RolesScalarFieldEnum)[keyof typeof RolesScalarFieldEnum]


  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    email_verified_at: 'email_verified_at',
    password: 'password',
    company_id: 'company_id',
    remember_token: 'remember_token',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const CacheScalarFieldEnum: {
    key: 'key',
    value: 'value',
    expiration: 'expiration'
  };

  export type CacheScalarFieldEnum = (typeof CacheScalarFieldEnum)[keyof typeof CacheScalarFieldEnum]


  export const Cache_locksScalarFieldEnum: {
    key: 'key',
    owner: 'owner',
    expiration: 'expiration'
  };

  export type Cache_locksScalarFieldEnum = (typeof Cache_locksScalarFieldEnum)[keyof typeof Cache_locksScalarFieldEnum]


  export const Job_batchesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    total_jobs: 'total_jobs',
    pending_jobs: 'pending_jobs',
    failed_jobs: 'failed_jobs',
    failed_job_ids: 'failed_job_ids',
    options: 'options',
    cancelled_at: 'cancelled_at',
    created_at: 'created_at',
    finished_at: 'finished_at'
  };

  export type Job_batchesScalarFieldEnum = (typeof Job_batchesScalarFieldEnum)[keyof typeof Job_batchesScalarFieldEnum]


  export const SessionsScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    payload: 'payload',
    last_activity: 'last_activity'
  };

  export type SessionsScalarFieldEnum = (typeof SessionsScalarFieldEnum)[keyof typeof SessionsScalarFieldEnum]


  export const CategoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    parent_id: 'parent_id',
    company_id: 'company_id',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CategoriesScalarFieldEnum = (typeof CategoriesScalarFieldEnum)[keyof typeof CategoriesScalarFieldEnum]


  export const CompaniesScalarFieldEnum: {
    id: 'id',
    registration_no: 'registration_no',
    vat: 'vat',
    name: 'name',
    email: 'email',
    domain: 'domain',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type CompaniesScalarFieldEnum = (typeof CompaniesScalarFieldEnum)[keyof typeof CompaniesScalarFieldEnum]


  export const Company_frontend_settingsScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    settings: 'settings',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Company_frontend_settingsScalarFieldEnum = (typeof Company_frontend_settingsScalarFieldEnum)[keyof typeof Company_frontend_settingsScalarFieldEnum]


  export const Company_integrationsScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    provider: 'provider',
    credentials: 'credentials',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Company_integrationsScalarFieldEnum = (typeof Company_integrationsScalarFieldEnum)[keyof typeof Company_integrationsScalarFieldEnum]


  export const Company_profilesScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    phone: 'phone',
    address: 'address',
    country: 'country',
    zipcode: 'zipcode',
    city: 'city',
    state: 'state',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Company_profilesScalarFieldEnum = (typeof Company_profilesScalarFieldEnum)[keyof typeof Company_profilesScalarFieldEnum]


  export const Company_subscriptionsScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    subscription_id: 'subscription_id',
    start_date: 'start_date',
    end_date: 'end_date',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Company_subscriptionsScalarFieldEnum = (typeof Company_subscriptionsScalarFieldEnum)[keyof typeof Company_subscriptionsScalarFieldEnum]


  export const Integration_category_mappingsScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    provider: 'provider',
    external_category: 'external_category',
    category_id: 'category_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Integration_category_mappingsScalarFieldEnum = (typeof Integration_category_mappingsScalarFieldEnum)[keyof typeof Integration_category_mappingsScalarFieldEnum]


  export const MenusScalarFieldEnum: {
    id: 'id',
    title: 'title',
    href: 'href',
    icon: 'icon',
    role: 'role',
    permission: 'permission',
    parent_id: 'parent_id',
    order: 'order',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type MenusScalarFieldEnum = (typeof MenusScalarFieldEnum)[keyof typeof MenusScalarFieldEnum]


  export const Offer_categoryScalarFieldEnum: {
    id: 'id',
    offer_id: 'offer_id',
    category_id: 'category_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type Offer_categoryScalarFieldEnum = (typeof Offer_categoryScalarFieldEnum)[keyof typeof Offer_categoryScalarFieldEnum]


  export const OffersScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    store_id: 'store_id',
    category_id: 'category_id',
    title: 'title',
    description: 'description',
    product_url: 'product_url',
    image_url: 'image_url',
    price: 'price',
    code: 'code',
    start_date: 'start_date',
    end_date: 'end_date',
    link: 'link',
    is_featured: 'is_featured',
    is_exclusive: 'is_exclusive',
    is_deal: 'is_deal',
    path: 'path',
    thumbnail: 'thumbnail',
    sku: 'sku',
    product_name: 'product_name',
    product_price: 'product_price',
    old_price: 'old_price',
    source: 'source',
    type: 'type',
    external_id: 'external_id',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type OffersScalarFieldEnum = (typeof OffersScalarFieldEnum)[keyof typeof OffersScalarFieldEnum]


  export const PaymentsScalarFieldEnum: {
    id: 'id',
    company_subscription_id: 'company_subscription_id',
    amount: 'amount',
    payment_method: 'payment_method',
    payment_status: 'payment_status',
    transaction_id: 'transaction_id',
    paid_at: 'paid_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PaymentsScalarFieldEnum = (typeof PaymentsScalarFieldEnum)[keyof typeof PaymentsScalarFieldEnum]


  export const StoresScalarFieldEnum: {
    id: 'id',
    company_id: 'company_id',
    name: 'name',
    image: 'image',
    description: 'description',
    status: 'status',
    channelId: 'channelId',
    channelName: 'channelName',
    programId: 'programId',
    categoryName: 'categoryName',
    categoryId: 'categoryId',
    productFeedId: 'productFeedId',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type StoresScalarFieldEnum = (typeof StoresScalarFieldEnum)[keyof typeof StoresScalarFieldEnum]


  export const SubscriptionsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    price: 'price',
    duration: 'duration',
    features: 'features',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SubscriptionsScalarFieldEnum = (typeof SubscriptionsScalarFieldEnum)[keyof typeof SubscriptionsScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const failed_jobsOrderByRelevanceFieldEnum: {
    uuid: 'uuid',
    connection: 'connection',
    queue: 'queue',
    payload: 'payload',
    exception: 'exception'
  };

  export type failed_jobsOrderByRelevanceFieldEnum = (typeof failed_jobsOrderByRelevanceFieldEnum)[keyof typeof failed_jobsOrderByRelevanceFieldEnum]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const jobsOrderByRelevanceFieldEnum: {
    queue: 'queue',
    payload: 'payload'
  };

  export type jobsOrderByRelevanceFieldEnum = (typeof jobsOrderByRelevanceFieldEnum)[keyof typeof jobsOrderByRelevanceFieldEnum]


  export const migrationsOrderByRelevanceFieldEnum: {
    migration: 'migration'
  };

  export type migrationsOrderByRelevanceFieldEnum = (typeof migrationsOrderByRelevanceFieldEnum)[keyof typeof migrationsOrderByRelevanceFieldEnum]


  export const model_has_permissionsOrderByRelevanceFieldEnum: {
    model_type: 'model_type'
  };

  export type model_has_permissionsOrderByRelevanceFieldEnum = (typeof model_has_permissionsOrderByRelevanceFieldEnum)[keyof typeof model_has_permissionsOrderByRelevanceFieldEnum]


  export const model_has_rolesOrderByRelevanceFieldEnum: {
    model_type: 'model_type'
  };

  export type model_has_rolesOrderByRelevanceFieldEnum = (typeof model_has_rolesOrderByRelevanceFieldEnum)[keyof typeof model_has_rolesOrderByRelevanceFieldEnum]


  export const password_reset_tokensOrderByRelevanceFieldEnum: {
    email: 'email',
    token: 'token'
  };

  export type password_reset_tokensOrderByRelevanceFieldEnum = (typeof password_reset_tokensOrderByRelevanceFieldEnum)[keyof typeof password_reset_tokensOrderByRelevanceFieldEnum]


  export const permissionsOrderByRelevanceFieldEnum: {
    name: 'name',
    guard_name: 'guard_name'
  };

  export type permissionsOrderByRelevanceFieldEnum = (typeof permissionsOrderByRelevanceFieldEnum)[keyof typeof permissionsOrderByRelevanceFieldEnum]


  export const rolesOrderByRelevanceFieldEnum: {
    name: 'name',
    guard_name: 'guard_name'
  };

  export type rolesOrderByRelevanceFieldEnum = (typeof rolesOrderByRelevanceFieldEnum)[keyof typeof rolesOrderByRelevanceFieldEnum]


  export const usersOrderByRelevanceFieldEnum: {
    name: 'name',
    email: 'email',
    password: 'password',
    remember_token: 'remember_token'
  };

  export type usersOrderByRelevanceFieldEnum = (typeof usersOrderByRelevanceFieldEnum)[keyof typeof usersOrderByRelevanceFieldEnum]


  export const cacheOrderByRelevanceFieldEnum: {
    key: 'key',
    value: 'value'
  };

  export type cacheOrderByRelevanceFieldEnum = (typeof cacheOrderByRelevanceFieldEnum)[keyof typeof cacheOrderByRelevanceFieldEnum]


  export const cache_locksOrderByRelevanceFieldEnum: {
    key: 'key',
    owner: 'owner'
  };

  export type cache_locksOrderByRelevanceFieldEnum = (typeof cache_locksOrderByRelevanceFieldEnum)[keyof typeof cache_locksOrderByRelevanceFieldEnum]


  export const job_batchesOrderByRelevanceFieldEnum: {
    id: 'id',
    name: 'name',
    failed_job_ids: 'failed_job_ids',
    options: 'options'
  };

  export type job_batchesOrderByRelevanceFieldEnum = (typeof job_batchesOrderByRelevanceFieldEnum)[keyof typeof job_batchesOrderByRelevanceFieldEnum]


  export const sessionsOrderByRelevanceFieldEnum: {
    id: 'id',
    ip_address: 'ip_address',
    user_agent: 'user_agent',
    payload: 'payload'
  };

  export type sessionsOrderByRelevanceFieldEnum = (typeof sessionsOrderByRelevanceFieldEnum)[keyof typeof sessionsOrderByRelevanceFieldEnum]


  export const categoriesOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type categoriesOrderByRelevanceFieldEnum = (typeof categoriesOrderByRelevanceFieldEnum)[keyof typeof categoriesOrderByRelevanceFieldEnum]


  export const companiesOrderByRelevanceFieldEnum: {
    registration_no: 'registration_no',
    vat: 'vat',
    name: 'name',
    email: 'email',
    domain: 'domain'
  };

  export type companiesOrderByRelevanceFieldEnum = (typeof companiesOrderByRelevanceFieldEnum)[keyof typeof companiesOrderByRelevanceFieldEnum]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const company_integrationsOrderByRelevanceFieldEnum: {
    provider: 'provider'
  };

  export type company_integrationsOrderByRelevanceFieldEnum = (typeof company_integrationsOrderByRelevanceFieldEnum)[keyof typeof company_integrationsOrderByRelevanceFieldEnum]


  export const company_profilesOrderByRelevanceFieldEnum: {
    phone: 'phone',
    address: 'address',
    country: 'country',
    zipcode: 'zipcode',
    city: 'city',
    state: 'state'
  };

  export type company_profilesOrderByRelevanceFieldEnum = (typeof company_profilesOrderByRelevanceFieldEnum)[keyof typeof company_profilesOrderByRelevanceFieldEnum]


  export const company_subscriptionsOrderByRelevanceFieldEnum: {
    status: 'status'
  };

  export type company_subscriptionsOrderByRelevanceFieldEnum = (typeof company_subscriptionsOrderByRelevanceFieldEnum)[keyof typeof company_subscriptionsOrderByRelevanceFieldEnum]


  export const integration_category_mappingsOrderByRelevanceFieldEnum: {
    provider: 'provider',
    external_category: 'external_category'
  };

  export type integration_category_mappingsOrderByRelevanceFieldEnum = (typeof integration_category_mappingsOrderByRelevanceFieldEnum)[keyof typeof integration_category_mappingsOrderByRelevanceFieldEnum]


  export const menusOrderByRelevanceFieldEnum: {
    title: 'title',
    href: 'href',
    icon: 'icon',
    role: 'role',
    permission: 'permission'
  };

  export type menusOrderByRelevanceFieldEnum = (typeof menusOrderByRelevanceFieldEnum)[keyof typeof menusOrderByRelevanceFieldEnum]


  export const offersOrderByRelevanceFieldEnum: {
    title: 'title',
    description: 'description',
    product_url: 'product_url',
    image_url: 'image_url',
    code: 'code',
    link: 'link',
    path: 'path',
    thumbnail: 'thumbnail',
    sku: 'sku',
    product_name: 'product_name',
    source: 'source',
    external_id: 'external_id'
  };

  export type offersOrderByRelevanceFieldEnum = (typeof offersOrderByRelevanceFieldEnum)[keyof typeof offersOrderByRelevanceFieldEnum]


  export const paymentsOrderByRelevanceFieldEnum: {
    payment_method: 'payment_method',
    payment_status: 'payment_status',
    transaction_id: 'transaction_id'
  };

  export type paymentsOrderByRelevanceFieldEnum = (typeof paymentsOrderByRelevanceFieldEnum)[keyof typeof paymentsOrderByRelevanceFieldEnum]


  export const storesOrderByRelevanceFieldEnum: {
    name: 'name',
    image: 'image',
    description: 'description',
    channelName: 'channelName',
    categoryName: 'categoryName'
  };

  export type storesOrderByRelevanceFieldEnum = (typeof storesOrderByRelevanceFieldEnum)[keyof typeof storesOrderByRelevanceFieldEnum]


  export const subscriptionsOrderByRelevanceFieldEnum: {
    name: 'name'
  };

  export type subscriptionsOrderByRelevanceFieldEnum = (typeof subscriptionsOrderByRelevanceFieldEnum)[keyof typeof subscriptionsOrderByRelevanceFieldEnum]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'offers_type'
   */
  export type Enumoffers_typeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'offers_type'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type failed_jobsWhereInput = {
    AND?: failed_jobsWhereInput | failed_jobsWhereInput[]
    OR?: failed_jobsWhereInput[]
    NOT?: failed_jobsWhereInput | failed_jobsWhereInput[]
    id?: BigIntFilter<"failed_jobs"> | bigint | number
    uuid?: StringFilter<"failed_jobs"> | string
    connection?: StringFilter<"failed_jobs"> | string
    queue?: StringFilter<"failed_jobs"> | string
    payload?: StringFilter<"failed_jobs"> | string
    exception?: StringFilter<"failed_jobs"> | string
    failed_at?: DateTimeFilter<"failed_jobs"> | Date | string
  }

  export type failed_jobsOrderByWithRelationInput = {
    id?: SortOrder
    uuid?: SortOrder
    connection?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    exception?: SortOrder
    failed_at?: SortOrder
    _relevance?: failed_jobsOrderByRelevanceInput
  }

  export type failed_jobsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    uuid?: string
    AND?: failed_jobsWhereInput | failed_jobsWhereInput[]
    OR?: failed_jobsWhereInput[]
    NOT?: failed_jobsWhereInput | failed_jobsWhereInput[]
    connection?: StringFilter<"failed_jobs"> | string
    queue?: StringFilter<"failed_jobs"> | string
    payload?: StringFilter<"failed_jobs"> | string
    exception?: StringFilter<"failed_jobs"> | string
    failed_at?: DateTimeFilter<"failed_jobs"> | Date | string
  }, "id" | "uuid">

  export type failed_jobsOrderByWithAggregationInput = {
    id?: SortOrder
    uuid?: SortOrder
    connection?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    exception?: SortOrder
    failed_at?: SortOrder
    _count?: failed_jobsCountOrderByAggregateInput
    _avg?: failed_jobsAvgOrderByAggregateInput
    _max?: failed_jobsMaxOrderByAggregateInput
    _min?: failed_jobsMinOrderByAggregateInput
    _sum?: failed_jobsSumOrderByAggregateInput
  }

  export type failed_jobsScalarWhereWithAggregatesInput = {
    AND?: failed_jobsScalarWhereWithAggregatesInput | failed_jobsScalarWhereWithAggregatesInput[]
    OR?: failed_jobsScalarWhereWithAggregatesInput[]
    NOT?: failed_jobsScalarWhereWithAggregatesInput | failed_jobsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"failed_jobs"> | bigint | number
    uuid?: StringWithAggregatesFilter<"failed_jobs"> | string
    connection?: StringWithAggregatesFilter<"failed_jobs"> | string
    queue?: StringWithAggregatesFilter<"failed_jobs"> | string
    payload?: StringWithAggregatesFilter<"failed_jobs"> | string
    exception?: StringWithAggregatesFilter<"failed_jobs"> | string
    failed_at?: DateTimeWithAggregatesFilter<"failed_jobs"> | Date | string
  }

  export type jobsWhereInput = {
    AND?: jobsWhereInput | jobsWhereInput[]
    OR?: jobsWhereInput[]
    NOT?: jobsWhereInput | jobsWhereInput[]
    id?: BigIntFilter<"jobs"> | bigint | number
    queue?: StringFilter<"jobs"> | string
    payload?: StringFilter<"jobs"> | string
    attempts?: IntFilter<"jobs"> | number
    reserved_at?: IntNullableFilter<"jobs"> | number | null
    available_at?: IntFilter<"jobs"> | number
    created_at?: IntFilter<"jobs"> | number
  }

  export type jobsOrderByWithRelationInput = {
    id?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    attempts?: SortOrder
    reserved_at?: SortOrderInput | SortOrder
    available_at?: SortOrder
    created_at?: SortOrder
    _relevance?: jobsOrderByRelevanceInput
  }

  export type jobsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: jobsWhereInput | jobsWhereInput[]
    OR?: jobsWhereInput[]
    NOT?: jobsWhereInput | jobsWhereInput[]
    queue?: StringFilter<"jobs"> | string
    payload?: StringFilter<"jobs"> | string
    attempts?: IntFilter<"jobs"> | number
    reserved_at?: IntNullableFilter<"jobs"> | number | null
    available_at?: IntFilter<"jobs"> | number
    created_at?: IntFilter<"jobs"> | number
  }, "id">

  export type jobsOrderByWithAggregationInput = {
    id?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    attempts?: SortOrder
    reserved_at?: SortOrderInput | SortOrder
    available_at?: SortOrder
    created_at?: SortOrder
    _count?: jobsCountOrderByAggregateInput
    _avg?: jobsAvgOrderByAggregateInput
    _max?: jobsMaxOrderByAggregateInput
    _min?: jobsMinOrderByAggregateInput
    _sum?: jobsSumOrderByAggregateInput
  }

  export type jobsScalarWhereWithAggregatesInput = {
    AND?: jobsScalarWhereWithAggregatesInput | jobsScalarWhereWithAggregatesInput[]
    OR?: jobsScalarWhereWithAggregatesInput[]
    NOT?: jobsScalarWhereWithAggregatesInput | jobsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"jobs"> | bigint | number
    queue?: StringWithAggregatesFilter<"jobs"> | string
    payload?: StringWithAggregatesFilter<"jobs"> | string
    attempts?: IntWithAggregatesFilter<"jobs"> | number
    reserved_at?: IntNullableWithAggregatesFilter<"jobs"> | number | null
    available_at?: IntWithAggregatesFilter<"jobs"> | number
    created_at?: IntWithAggregatesFilter<"jobs"> | number
  }

  export type migrationsWhereInput = {
    AND?: migrationsWhereInput | migrationsWhereInput[]
    OR?: migrationsWhereInput[]
    NOT?: migrationsWhereInput | migrationsWhereInput[]
    id?: IntFilter<"migrations"> | number
    migration?: StringFilter<"migrations"> | string
    batch?: IntFilter<"migrations"> | number
  }

  export type migrationsOrderByWithRelationInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
    _relevance?: migrationsOrderByRelevanceInput
  }

  export type migrationsWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: migrationsWhereInput | migrationsWhereInput[]
    OR?: migrationsWhereInput[]
    NOT?: migrationsWhereInput | migrationsWhereInput[]
    migration?: StringFilter<"migrations"> | string
    batch?: IntFilter<"migrations"> | number
  }, "id">

  export type migrationsOrderByWithAggregationInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
    _count?: migrationsCountOrderByAggregateInput
    _avg?: migrationsAvgOrderByAggregateInput
    _max?: migrationsMaxOrderByAggregateInput
    _min?: migrationsMinOrderByAggregateInput
    _sum?: migrationsSumOrderByAggregateInput
  }

  export type migrationsScalarWhereWithAggregatesInput = {
    AND?: migrationsScalarWhereWithAggregatesInput | migrationsScalarWhereWithAggregatesInput[]
    OR?: migrationsScalarWhereWithAggregatesInput[]
    NOT?: migrationsScalarWhereWithAggregatesInput | migrationsScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"migrations"> | number
    migration?: StringWithAggregatesFilter<"migrations"> | string
    batch?: IntWithAggregatesFilter<"migrations"> | number
  }

  export type model_has_permissionsWhereInput = {
    AND?: model_has_permissionsWhereInput | model_has_permissionsWhereInput[]
    OR?: model_has_permissionsWhereInput[]
    NOT?: model_has_permissionsWhereInput | model_has_permissionsWhereInput[]
    permission_id?: BigIntFilter<"model_has_permissions"> | bigint | number
    model_type?: StringFilter<"model_has_permissions"> | string
    model_id?: BigIntFilter<"model_has_permissions"> | bigint | number
    permissions?: XOR<PermissionsScalarRelationFilter, permissionsWhereInput>
  }

  export type model_has_permissionsOrderByWithRelationInput = {
    permission_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
    permissions?: permissionsOrderByWithRelationInput
    _relevance?: model_has_permissionsOrderByRelevanceInput
  }

  export type model_has_permissionsWhereUniqueInput = Prisma.AtLeast<{
    permission_id_model_id_model_type?: model_has_permissionsPermission_idModel_idModel_typeCompoundUniqueInput
    AND?: model_has_permissionsWhereInput | model_has_permissionsWhereInput[]
    OR?: model_has_permissionsWhereInput[]
    NOT?: model_has_permissionsWhereInput | model_has_permissionsWhereInput[]
    permission_id?: BigIntFilter<"model_has_permissions"> | bigint | number
    model_type?: StringFilter<"model_has_permissions"> | string
    model_id?: BigIntFilter<"model_has_permissions"> | bigint | number
    permissions?: XOR<PermissionsScalarRelationFilter, permissionsWhereInput>
  }, "permission_id_model_id_model_type">

  export type model_has_permissionsOrderByWithAggregationInput = {
    permission_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
    _count?: model_has_permissionsCountOrderByAggregateInput
    _avg?: model_has_permissionsAvgOrderByAggregateInput
    _max?: model_has_permissionsMaxOrderByAggregateInput
    _min?: model_has_permissionsMinOrderByAggregateInput
    _sum?: model_has_permissionsSumOrderByAggregateInput
  }

  export type model_has_permissionsScalarWhereWithAggregatesInput = {
    AND?: model_has_permissionsScalarWhereWithAggregatesInput | model_has_permissionsScalarWhereWithAggregatesInput[]
    OR?: model_has_permissionsScalarWhereWithAggregatesInput[]
    NOT?: model_has_permissionsScalarWhereWithAggregatesInput | model_has_permissionsScalarWhereWithAggregatesInput[]
    permission_id?: BigIntWithAggregatesFilter<"model_has_permissions"> | bigint | number
    model_type?: StringWithAggregatesFilter<"model_has_permissions"> | string
    model_id?: BigIntWithAggregatesFilter<"model_has_permissions"> | bigint | number
  }

  export type model_has_rolesWhereInput = {
    AND?: model_has_rolesWhereInput | model_has_rolesWhereInput[]
    OR?: model_has_rolesWhereInput[]
    NOT?: model_has_rolesWhereInput | model_has_rolesWhereInput[]
    role_id?: BigIntFilter<"model_has_roles"> | bigint | number
    model_type?: StringFilter<"model_has_roles"> | string
    model_id?: BigIntFilter<"model_has_roles"> | bigint | number
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
  }

  export type model_has_rolesOrderByWithRelationInput = {
    role_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
    roles?: rolesOrderByWithRelationInput
    _relevance?: model_has_rolesOrderByRelevanceInput
  }

  export type model_has_rolesWhereUniqueInput = Prisma.AtLeast<{
    role_id_model_id_model_type?: model_has_rolesRole_idModel_idModel_typeCompoundUniqueInput
    AND?: model_has_rolesWhereInput | model_has_rolesWhereInput[]
    OR?: model_has_rolesWhereInput[]
    NOT?: model_has_rolesWhereInput | model_has_rolesWhereInput[]
    role_id?: BigIntFilter<"model_has_roles"> | bigint | number
    model_type?: StringFilter<"model_has_roles"> | string
    model_id?: BigIntFilter<"model_has_roles"> | bigint | number
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
  }, "role_id_model_id_model_type">

  export type model_has_rolesOrderByWithAggregationInput = {
    role_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
    _count?: model_has_rolesCountOrderByAggregateInput
    _avg?: model_has_rolesAvgOrderByAggregateInput
    _max?: model_has_rolesMaxOrderByAggregateInput
    _min?: model_has_rolesMinOrderByAggregateInput
    _sum?: model_has_rolesSumOrderByAggregateInput
  }

  export type model_has_rolesScalarWhereWithAggregatesInput = {
    AND?: model_has_rolesScalarWhereWithAggregatesInput | model_has_rolesScalarWhereWithAggregatesInput[]
    OR?: model_has_rolesScalarWhereWithAggregatesInput[]
    NOT?: model_has_rolesScalarWhereWithAggregatesInput | model_has_rolesScalarWhereWithAggregatesInput[]
    role_id?: BigIntWithAggregatesFilter<"model_has_roles"> | bigint | number
    model_type?: StringWithAggregatesFilter<"model_has_roles"> | string
    model_id?: BigIntWithAggregatesFilter<"model_has_roles"> | bigint | number
  }

  export type password_reset_tokensWhereInput = {
    AND?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    OR?: password_reset_tokensWhereInput[]
    NOT?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    email?: StringFilter<"password_reset_tokens"> | string
    token?: StringFilter<"password_reset_tokens"> | string
    created_at?: DateTimeNullableFilter<"password_reset_tokens"> | Date | string | null
  }

  export type password_reset_tokensOrderByWithRelationInput = {
    email?: SortOrder
    token?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _relevance?: password_reset_tokensOrderByRelevanceInput
  }

  export type password_reset_tokensWhereUniqueInput = Prisma.AtLeast<{
    email?: string
    AND?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    OR?: password_reset_tokensWhereInput[]
    NOT?: password_reset_tokensWhereInput | password_reset_tokensWhereInput[]
    token?: StringFilter<"password_reset_tokens"> | string
    created_at?: DateTimeNullableFilter<"password_reset_tokens"> | Date | string | null
  }, "email">

  export type password_reset_tokensOrderByWithAggregationInput = {
    email?: SortOrder
    token?: SortOrder
    created_at?: SortOrderInput | SortOrder
    _count?: password_reset_tokensCountOrderByAggregateInput
    _max?: password_reset_tokensMaxOrderByAggregateInput
    _min?: password_reset_tokensMinOrderByAggregateInput
  }

  export type password_reset_tokensScalarWhereWithAggregatesInput = {
    AND?: password_reset_tokensScalarWhereWithAggregatesInput | password_reset_tokensScalarWhereWithAggregatesInput[]
    OR?: password_reset_tokensScalarWhereWithAggregatesInput[]
    NOT?: password_reset_tokensScalarWhereWithAggregatesInput | password_reset_tokensScalarWhereWithAggregatesInput[]
    email?: StringWithAggregatesFilter<"password_reset_tokens"> | string
    token?: StringWithAggregatesFilter<"password_reset_tokens"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"password_reset_tokens"> | Date | string | null
  }

  export type permissionsWhereInput = {
    AND?: permissionsWhereInput | permissionsWhereInput[]
    OR?: permissionsWhereInput[]
    NOT?: permissionsWhereInput | permissionsWhereInput[]
    id?: BigIntFilter<"permissions"> | bigint | number
    name?: StringFilter<"permissions"> | string
    guard_name?: StringFilter<"permissions"> | string
    created_at?: DateTimeNullableFilter<"permissions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"permissions"> | Date | string | null
    model_has_permissions?: Model_has_permissionsListRelationFilter
    role_has_permissions?: Role_has_permissionsListRelationFilter
  }

  export type permissionsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    model_has_permissions?: model_has_permissionsOrderByRelationAggregateInput
    role_has_permissions?: role_has_permissionsOrderByRelationAggregateInput
    _relevance?: permissionsOrderByRelevanceInput
  }

  export type permissionsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    name_guard_name?: permissionsNameGuard_nameCompoundUniqueInput
    AND?: permissionsWhereInput | permissionsWhereInput[]
    OR?: permissionsWhereInput[]
    NOT?: permissionsWhereInput | permissionsWhereInput[]
    name?: StringFilter<"permissions"> | string
    guard_name?: StringFilter<"permissions"> | string
    created_at?: DateTimeNullableFilter<"permissions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"permissions"> | Date | string | null
    model_has_permissions?: Model_has_permissionsListRelationFilter
    role_has_permissions?: Role_has_permissionsListRelationFilter
  }, "id" | "name_guard_name">

  export type permissionsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: permissionsCountOrderByAggregateInput
    _avg?: permissionsAvgOrderByAggregateInput
    _max?: permissionsMaxOrderByAggregateInput
    _min?: permissionsMinOrderByAggregateInput
    _sum?: permissionsSumOrderByAggregateInput
  }

  export type permissionsScalarWhereWithAggregatesInput = {
    AND?: permissionsScalarWhereWithAggregatesInput | permissionsScalarWhereWithAggregatesInput[]
    OR?: permissionsScalarWhereWithAggregatesInput[]
    NOT?: permissionsScalarWhereWithAggregatesInput | permissionsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"permissions"> | bigint | number
    name?: StringWithAggregatesFilter<"permissions"> | string
    guard_name?: StringWithAggregatesFilter<"permissions"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"permissions"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"permissions"> | Date | string | null
  }

  export type role_has_permissionsWhereInput = {
    AND?: role_has_permissionsWhereInput | role_has_permissionsWhereInput[]
    OR?: role_has_permissionsWhereInput[]
    NOT?: role_has_permissionsWhereInput | role_has_permissionsWhereInput[]
    permission_id?: BigIntFilter<"role_has_permissions"> | bigint | number
    role_id?: BigIntFilter<"role_has_permissions"> | bigint | number
    permissions?: XOR<PermissionsScalarRelationFilter, permissionsWhereInput>
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
  }

  export type role_has_permissionsOrderByWithRelationInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
    permissions?: permissionsOrderByWithRelationInput
    roles?: rolesOrderByWithRelationInput
  }

  export type role_has_permissionsWhereUniqueInput = Prisma.AtLeast<{
    permission_id_role_id?: role_has_permissionsPermission_idRole_idCompoundUniqueInput
    AND?: role_has_permissionsWhereInput | role_has_permissionsWhereInput[]
    OR?: role_has_permissionsWhereInput[]
    NOT?: role_has_permissionsWhereInput | role_has_permissionsWhereInput[]
    permission_id?: BigIntFilter<"role_has_permissions"> | bigint | number
    role_id?: BigIntFilter<"role_has_permissions"> | bigint | number
    permissions?: XOR<PermissionsScalarRelationFilter, permissionsWhereInput>
    roles?: XOR<RolesScalarRelationFilter, rolesWhereInput>
  }, "permission_id_role_id">

  export type role_has_permissionsOrderByWithAggregationInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
    _count?: role_has_permissionsCountOrderByAggregateInput
    _avg?: role_has_permissionsAvgOrderByAggregateInput
    _max?: role_has_permissionsMaxOrderByAggregateInput
    _min?: role_has_permissionsMinOrderByAggregateInput
    _sum?: role_has_permissionsSumOrderByAggregateInput
  }

  export type role_has_permissionsScalarWhereWithAggregatesInput = {
    AND?: role_has_permissionsScalarWhereWithAggregatesInput | role_has_permissionsScalarWhereWithAggregatesInput[]
    OR?: role_has_permissionsScalarWhereWithAggregatesInput[]
    NOT?: role_has_permissionsScalarWhereWithAggregatesInput | role_has_permissionsScalarWhereWithAggregatesInput[]
    permission_id?: BigIntWithAggregatesFilter<"role_has_permissions"> | bigint | number
    role_id?: BigIntWithAggregatesFilter<"role_has_permissions"> | bigint | number
  }

  export type rolesWhereInput = {
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    id?: BigIntFilter<"roles"> | bigint | number
    name?: StringFilter<"roles"> | string
    guard_name?: StringFilter<"roles"> | string
    created_at?: DateTimeNullableFilter<"roles"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"roles"> | Date | string | null
    model_has_roles?: Model_has_rolesListRelationFilter
    role_has_permissions?: Role_has_permissionsListRelationFilter
  }

  export type rolesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    model_has_roles?: model_has_rolesOrderByRelationAggregateInput
    role_has_permissions?: role_has_permissionsOrderByRelationAggregateInput
    _relevance?: rolesOrderByRelevanceInput
  }

  export type rolesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    name_guard_name?: rolesNameGuard_nameCompoundUniqueInput
    AND?: rolesWhereInput | rolesWhereInput[]
    OR?: rolesWhereInput[]
    NOT?: rolesWhereInput | rolesWhereInput[]
    name?: StringFilter<"roles"> | string
    guard_name?: StringFilter<"roles"> | string
    created_at?: DateTimeNullableFilter<"roles"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"roles"> | Date | string | null
    model_has_roles?: Model_has_rolesListRelationFilter
    role_has_permissions?: Role_has_permissionsListRelationFilter
  }, "id" | "name_guard_name">

  export type rolesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: rolesCountOrderByAggregateInput
    _avg?: rolesAvgOrderByAggregateInput
    _max?: rolesMaxOrderByAggregateInput
    _min?: rolesMinOrderByAggregateInput
    _sum?: rolesSumOrderByAggregateInput
  }

  export type rolesScalarWhereWithAggregatesInput = {
    AND?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    OR?: rolesScalarWhereWithAggregatesInput[]
    NOT?: rolesScalarWhereWithAggregatesInput | rolesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"roles"> | bigint | number
    name?: StringWithAggregatesFilter<"roles"> | string
    guard_name?: StringWithAggregatesFilter<"roles"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"roles"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"roles"> | Date | string | null
  }

  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: BigIntFilter<"users"> | bigint | number
    name?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    email_verified_at?: DateTimeNullableFilter<"users"> | Date | string | null
    password?: StringFilter<"users"> | string
    company_id?: BigIntNullableFilter<"users"> | bigint | number | null
    remember_token?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    companies?: XOR<CompaniesNullableScalarRelationFilter, companiesWhereInput> | null
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrderInput | SortOrder
    password?: SortOrder
    company_id?: SortOrderInput | SortOrder
    remember_token?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    companies?: companiesOrderByWithRelationInput
    _relevance?: usersOrderByRelevanceInput
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    email?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringFilter<"users"> | string
    email_verified_at?: DateTimeNullableFilter<"users"> | Date | string | null
    password?: StringFilter<"users"> | string
    company_id?: BigIntNullableFilter<"users"> | bigint | number | null
    remember_token?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
    companies?: XOR<CompaniesNullableScalarRelationFilter, companiesWhereInput> | null
  }, "id" | "email">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrderInput | SortOrder
    password?: SortOrder
    company_id?: SortOrderInput | SortOrder
    remember_token?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: usersCountOrderByAggregateInput
    _avg?: usersAvgOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
    _sum?: usersSumOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"users"> | bigint | number
    name?: StringWithAggregatesFilter<"users"> | string
    email?: StringWithAggregatesFilter<"users"> | string
    email_verified_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    password?: StringWithAggregatesFilter<"users"> | string
    company_id?: BigIntNullableWithAggregatesFilter<"users"> | bigint | number | null
    remember_token?: StringNullableWithAggregatesFilter<"users"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"users"> | Date | string | null
  }

  export type cacheWhereInput = {
    AND?: cacheWhereInput | cacheWhereInput[]
    OR?: cacheWhereInput[]
    NOT?: cacheWhereInput | cacheWhereInput[]
    key?: StringFilter<"cache"> | string
    value?: StringFilter<"cache"> | string
    expiration?: IntFilter<"cache"> | number
  }

  export type cacheOrderByWithRelationInput = {
    key?: SortOrder
    value?: SortOrder
    expiration?: SortOrder
    _relevance?: cacheOrderByRelevanceInput
  }

  export type cacheWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: cacheWhereInput | cacheWhereInput[]
    OR?: cacheWhereInput[]
    NOT?: cacheWhereInput | cacheWhereInput[]
    value?: StringFilter<"cache"> | string
    expiration?: IntFilter<"cache"> | number
  }, "key">

  export type cacheOrderByWithAggregationInput = {
    key?: SortOrder
    value?: SortOrder
    expiration?: SortOrder
    _count?: cacheCountOrderByAggregateInput
    _avg?: cacheAvgOrderByAggregateInput
    _max?: cacheMaxOrderByAggregateInput
    _min?: cacheMinOrderByAggregateInput
    _sum?: cacheSumOrderByAggregateInput
  }

  export type cacheScalarWhereWithAggregatesInput = {
    AND?: cacheScalarWhereWithAggregatesInput | cacheScalarWhereWithAggregatesInput[]
    OR?: cacheScalarWhereWithAggregatesInput[]
    NOT?: cacheScalarWhereWithAggregatesInput | cacheScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"cache"> | string
    value?: StringWithAggregatesFilter<"cache"> | string
    expiration?: IntWithAggregatesFilter<"cache"> | number
  }

  export type cache_locksWhereInput = {
    AND?: cache_locksWhereInput | cache_locksWhereInput[]
    OR?: cache_locksWhereInput[]
    NOT?: cache_locksWhereInput | cache_locksWhereInput[]
    key?: StringFilter<"cache_locks"> | string
    owner?: StringFilter<"cache_locks"> | string
    expiration?: IntFilter<"cache_locks"> | number
  }

  export type cache_locksOrderByWithRelationInput = {
    key?: SortOrder
    owner?: SortOrder
    expiration?: SortOrder
    _relevance?: cache_locksOrderByRelevanceInput
  }

  export type cache_locksWhereUniqueInput = Prisma.AtLeast<{
    key?: string
    AND?: cache_locksWhereInput | cache_locksWhereInput[]
    OR?: cache_locksWhereInput[]
    NOT?: cache_locksWhereInput | cache_locksWhereInput[]
    owner?: StringFilter<"cache_locks"> | string
    expiration?: IntFilter<"cache_locks"> | number
  }, "key">

  export type cache_locksOrderByWithAggregationInput = {
    key?: SortOrder
    owner?: SortOrder
    expiration?: SortOrder
    _count?: cache_locksCountOrderByAggregateInput
    _avg?: cache_locksAvgOrderByAggregateInput
    _max?: cache_locksMaxOrderByAggregateInput
    _min?: cache_locksMinOrderByAggregateInput
    _sum?: cache_locksSumOrderByAggregateInput
  }

  export type cache_locksScalarWhereWithAggregatesInput = {
    AND?: cache_locksScalarWhereWithAggregatesInput | cache_locksScalarWhereWithAggregatesInput[]
    OR?: cache_locksScalarWhereWithAggregatesInput[]
    NOT?: cache_locksScalarWhereWithAggregatesInput | cache_locksScalarWhereWithAggregatesInput[]
    key?: StringWithAggregatesFilter<"cache_locks"> | string
    owner?: StringWithAggregatesFilter<"cache_locks"> | string
    expiration?: IntWithAggregatesFilter<"cache_locks"> | number
  }

  export type job_batchesWhereInput = {
    AND?: job_batchesWhereInput | job_batchesWhereInput[]
    OR?: job_batchesWhereInput[]
    NOT?: job_batchesWhereInput | job_batchesWhereInput[]
    id?: StringFilter<"job_batches"> | string
    name?: StringFilter<"job_batches"> | string
    total_jobs?: IntFilter<"job_batches"> | number
    pending_jobs?: IntFilter<"job_batches"> | number
    failed_jobs?: IntFilter<"job_batches"> | number
    failed_job_ids?: StringFilter<"job_batches"> | string
    options?: StringNullableFilter<"job_batches"> | string | null
    cancelled_at?: IntNullableFilter<"job_batches"> | number | null
    created_at?: IntFilter<"job_batches"> | number
    finished_at?: IntNullableFilter<"job_batches"> | number | null
  }

  export type job_batchesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    total_jobs?: SortOrder
    pending_jobs?: SortOrder
    failed_jobs?: SortOrder
    failed_job_ids?: SortOrder
    options?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    finished_at?: SortOrderInput | SortOrder
    _relevance?: job_batchesOrderByRelevanceInput
  }

  export type job_batchesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: job_batchesWhereInput | job_batchesWhereInput[]
    OR?: job_batchesWhereInput[]
    NOT?: job_batchesWhereInput | job_batchesWhereInput[]
    name?: StringFilter<"job_batches"> | string
    total_jobs?: IntFilter<"job_batches"> | number
    pending_jobs?: IntFilter<"job_batches"> | number
    failed_jobs?: IntFilter<"job_batches"> | number
    failed_job_ids?: StringFilter<"job_batches"> | string
    options?: StringNullableFilter<"job_batches"> | string | null
    cancelled_at?: IntNullableFilter<"job_batches"> | number | null
    created_at?: IntFilter<"job_batches"> | number
    finished_at?: IntNullableFilter<"job_batches"> | number | null
  }, "id">

  export type job_batchesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    total_jobs?: SortOrder
    pending_jobs?: SortOrder
    failed_jobs?: SortOrder
    failed_job_ids?: SortOrder
    options?: SortOrderInput | SortOrder
    cancelled_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    finished_at?: SortOrderInput | SortOrder
    _count?: job_batchesCountOrderByAggregateInput
    _avg?: job_batchesAvgOrderByAggregateInput
    _max?: job_batchesMaxOrderByAggregateInput
    _min?: job_batchesMinOrderByAggregateInput
    _sum?: job_batchesSumOrderByAggregateInput
  }

  export type job_batchesScalarWhereWithAggregatesInput = {
    AND?: job_batchesScalarWhereWithAggregatesInput | job_batchesScalarWhereWithAggregatesInput[]
    OR?: job_batchesScalarWhereWithAggregatesInput[]
    NOT?: job_batchesScalarWhereWithAggregatesInput | job_batchesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"job_batches"> | string
    name?: StringWithAggregatesFilter<"job_batches"> | string
    total_jobs?: IntWithAggregatesFilter<"job_batches"> | number
    pending_jobs?: IntWithAggregatesFilter<"job_batches"> | number
    failed_jobs?: IntWithAggregatesFilter<"job_batches"> | number
    failed_job_ids?: StringWithAggregatesFilter<"job_batches"> | string
    options?: StringNullableWithAggregatesFilter<"job_batches"> | string | null
    cancelled_at?: IntNullableWithAggregatesFilter<"job_batches"> | number | null
    created_at?: IntWithAggregatesFilter<"job_batches"> | number
    finished_at?: IntNullableWithAggregatesFilter<"job_batches"> | number | null
  }

  export type sessionsWhereInput = {
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    id?: StringFilter<"sessions"> | string
    user_id?: BigIntNullableFilter<"sessions"> | bigint | number | null
    ip_address?: StringNullableFilter<"sessions"> | string | null
    user_agent?: StringNullableFilter<"sessions"> | string | null
    payload?: StringFilter<"sessions"> | string
    last_activity?: IntFilter<"sessions"> | number
  }

  export type sessionsOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    payload?: SortOrder
    last_activity?: SortOrder
    _relevance?: sessionsOrderByRelevanceInput
  }

  export type sessionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: sessionsWhereInput | sessionsWhereInput[]
    OR?: sessionsWhereInput[]
    NOT?: sessionsWhereInput | sessionsWhereInput[]
    user_id?: BigIntNullableFilter<"sessions"> | bigint | number | null
    ip_address?: StringNullableFilter<"sessions"> | string | null
    user_agent?: StringNullableFilter<"sessions"> | string | null
    payload?: StringFilter<"sessions"> | string
    last_activity?: IntFilter<"sessions"> | number
  }, "id">

  export type sessionsOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrderInput | SortOrder
    ip_address?: SortOrderInput | SortOrder
    user_agent?: SortOrderInput | SortOrder
    payload?: SortOrder
    last_activity?: SortOrder
    _count?: sessionsCountOrderByAggregateInput
    _avg?: sessionsAvgOrderByAggregateInput
    _max?: sessionsMaxOrderByAggregateInput
    _min?: sessionsMinOrderByAggregateInput
    _sum?: sessionsSumOrderByAggregateInput
  }

  export type sessionsScalarWhereWithAggregatesInput = {
    AND?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    OR?: sessionsScalarWhereWithAggregatesInput[]
    NOT?: sessionsScalarWhereWithAggregatesInput | sessionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"sessions"> | string
    user_id?: BigIntNullableWithAggregatesFilter<"sessions"> | bigint | number | null
    ip_address?: StringNullableWithAggregatesFilter<"sessions"> | string | null
    user_agent?: StringNullableWithAggregatesFilter<"sessions"> | string | null
    payload?: StringWithAggregatesFilter<"sessions"> | string
    last_activity?: IntWithAggregatesFilter<"sessions"> | number
  }

  export type categoriesWhereInput = {
    AND?: categoriesWhereInput | categoriesWhereInput[]
    OR?: categoriesWhereInput[]
    NOT?: categoriesWhereInput | categoriesWhereInput[]
    id?: BigIntFilter<"categories"> | bigint | number
    name?: StringFilter<"categories"> | string
    parent_id?: BigIntNullableFilter<"categories"> | bigint | number | null
    company_id?: BigIntFilter<"categories"> | bigint | number
    status?: BoolFilter<"categories"> | boolean
    created_at?: DateTimeNullableFilter<"categories"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"categories"> | Date | string | null
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    other_categories?: CategoriesListRelationFilter
    integration_category_mappings?: Integration_category_mappingsListRelationFilter
    offer_category?: Offer_categoryListRelationFilter
    offers?: OffersListRelationFilter
  }

  export type categoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    company_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    companies?: companiesOrderByWithRelationInput
    categories?: categoriesOrderByWithRelationInput
    other_categories?: categoriesOrderByRelationAggregateInput
    integration_category_mappings?: integration_category_mappingsOrderByRelationAggregateInput
    offer_category?: offer_categoryOrderByRelationAggregateInput
    offers?: offersOrderByRelationAggregateInput
    _relevance?: categoriesOrderByRelevanceInput
  }

  export type categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: categoriesWhereInput | categoriesWhereInput[]
    OR?: categoriesWhereInput[]
    NOT?: categoriesWhereInput | categoriesWhereInput[]
    name?: StringFilter<"categories"> | string
    parent_id?: BigIntNullableFilter<"categories"> | bigint | number | null
    company_id?: BigIntFilter<"categories"> | bigint | number
    status?: BoolFilter<"categories"> | boolean
    created_at?: DateTimeNullableFilter<"categories"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"categories"> | Date | string | null
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    other_categories?: CategoriesListRelationFilter
    integration_category_mappings?: Integration_category_mappingsListRelationFilter
    offer_category?: Offer_categoryListRelationFilter
    offers?: OffersListRelationFilter
  }, "id">

  export type categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    parent_id?: SortOrderInput | SortOrder
    company_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: categoriesCountOrderByAggregateInput
    _avg?: categoriesAvgOrderByAggregateInput
    _max?: categoriesMaxOrderByAggregateInput
    _min?: categoriesMinOrderByAggregateInput
    _sum?: categoriesSumOrderByAggregateInput
  }

  export type categoriesScalarWhereWithAggregatesInput = {
    AND?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]
    OR?: categoriesScalarWhereWithAggregatesInput[]
    NOT?: categoriesScalarWhereWithAggregatesInput | categoriesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"categories"> | bigint | number
    name?: StringWithAggregatesFilter<"categories"> | string
    parent_id?: BigIntNullableWithAggregatesFilter<"categories"> | bigint | number | null
    company_id?: BigIntWithAggregatesFilter<"categories"> | bigint | number
    status?: BoolWithAggregatesFilter<"categories"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"categories"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"categories"> | Date | string | null
  }

  export type companiesWhereInput = {
    AND?: companiesWhereInput | companiesWhereInput[]
    OR?: companiesWhereInput[]
    NOT?: companiesWhereInput | companiesWhereInput[]
    id?: BigIntFilter<"companies"> | bigint | number
    registration_no?: StringNullableFilter<"companies"> | string | null
    vat?: StringNullableFilter<"companies"> | string | null
    name?: StringFilter<"companies"> | string
    email?: StringFilter<"companies"> | string
    domain?: StringFilter<"companies"> | string
    status?: BoolFilter<"companies"> | boolean
    created_at?: DateTimeNullableFilter<"companies"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"companies"> | Date | string | null
    categories?: CategoriesListRelationFilter
    company_frontend_settings?: Company_frontend_settingsListRelationFilter
    company_integrations?: Company_integrationsListRelationFilter
    company_profiles?: Company_profilesListRelationFilter
    company_subscriptions?: Company_subscriptionsListRelationFilter
    integration_category_mappings?: Integration_category_mappingsListRelationFilter
    offers?: OffersListRelationFilter
    stores?: StoresListRelationFilter
    users?: UsersListRelationFilter
  }

  export type companiesOrderByWithRelationInput = {
    id?: SortOrder
    registration_no?: SortOrderInput | SortOrder
    vat?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    domain?: SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    categories?: categoriesOrderByRelationAggregateInput
    company_frontend_settings?: company_frontend_settingsOrderByRelationAggregateInput
    company_integrations?: company_integrationsOrderByRelationAggregateInput
    company_profiles?: company_profilesOrderByRelationAggregateInput
    company_subscriptions?: company_subscriptionsOrderByRelationAggregateInput
    integration_category_mappings?: integration_category_mappingsOrderByRelationAggregateInput
    offers?: offersOrderByRelationAggregateInput
    stores?: storesOrderByRelationAggregateInput
    users?: usersOrderByRelationAggregateInput
    _relevance?: companiesOrderByRelevanceInput
  }

  export type companiesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    email?: string
    domain?: string
    AND?: companiesWhereInput | companiesWhereInput[]
    OR?: companiesWhereInput[]
    NOT?: companiesWhereInput | companiesWhereInput[]
    registration_no?: StringNullableFilter<"companies"> | string | null
    vat?: StringNullableFilter<"companies"> | string | null
    name?: StringFilter<"companies"> | string
    status?: BoolFilter<"companies"> | boolean
    created_at?: DateTimeNullableFilter<"companies"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"companies"> | Date | string | null
    categories?: CategoriesListRelationFilter
    company_frontend_settings?: Company_frontend_settingsListRelationFilter
    company_integrations?: Company_integrationsListRelationFilter
    company_profiles?: Company_profilesListRelationFilter
    company_subscriptions?: Company_subscriptionsListRelationFilter
    integration_category_mappings?: Integration_category_mappingsListRelationFilter
    offers?: OffersListRelationFilter
    stores?: StoresListRelationFilter
    users?: UsersListRelationFilter
  }, "id" | "email" | "domain">

  export type companiesOrderByWithAggregationInput = {
    id?: SortOrder
    registration_no?: SortOrderInput | SortOrder
    vat?: SortOrderInput | SortOrder
    name?: SortOrder
    email?: SortOrder
    domain?: SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: companiesCountOrderByAggregateInput
    _avg?: companiesAvgOrderByAggregateInput
    _max?: companiesMaxOrderByAggregateInput
    _min?: companiesMinOrderByAggregateInput
    _sum?: companiesSumOrderByAggregateInput
  }

  export type companiesScalarWhereWithAggregatesInput = {
    AND?: companiesScalarWhereWithAggregatesInput | companiesScalarWhereWithAggregatesInput[]
    OR?: companiesScalarWhereWithAggregatesInput[]
    NOT?: companiesScalarWhereWithAggregatesInput | companiesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"companies"> | bigint | number
    registration_no?: StringNullableWithAggregatesFilter<"companies"> | string | null
    vat?: StringNullableWithAggregatesFilter<"companies"> | string | null
    name?: StringWithAggregatesFilter<"companies"> | string
    email?: StringWithAggregatesFilter<"companies"> | string
    domain?: StringWithAggregatesFilter<"companies"> | string
    status?: BoolWithAggregatesFilter<"companies"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"companies"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"companies"> | Date | string | null
  }

  export type company_frontend_settingsWhereInput = {
    AND?: company_frontend_settingsWhereInput | company_frontend_settingsWhereInput[]
    OR?: company_frontend_settingsWhereInput[]
    NOT?: company_frontend_settingsWhereInput | company_frontend_settingsWhereInput[]
    id?: BigIntFilter<"company_frontend_settings"> | bigint | number
    company_id?: BigIntFilter<"company_frontend_settings"> | bigint | number
    settings?: JsonNullableFilter<"company_frontend_settings">
    created_at?: DateTimeNullableFilter<"company_frontend_settings"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"company_frontend_settings"> | Date | string | null
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }

  export type company_frontend_settingsOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrder
    settings?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    companies?: companiesOrderByWithRelationInput
  }

  export type company_frontend_settingsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: company_frontend_settingsWhereInput | company_frontend_settingsWhereInput[]
    OR?: company_frontend_settingsWhereInput[]
    NOT?: company_frontend_settingsWhereInput | company_frontend_settingsWhereInput[]
    company_id?: BigIntFilter<"company_frontend_settings"> | bigint | number
    settings?: JsonNullableFilter<"company_frontend_settings">
    created_at?: DateTimeNullableFilter<"company_frontend_settings"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"company_frontend_settings"> | Date | string | null
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }, "id">

  export type company_frontend_settingsOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrder
    settings?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: company_frontend_settingsCountOrderByAggregateInput
    _avg?: company_frontend_settingsAvgOrderByAggregateInput
    _max?: company_frontend_settingsMaxOrderByAggregateInput
    _min?: company_frontend_settingsMinOrderByAggregateInput
    _sum?: company_frontend_settingsSumOrderByAggregateInput
  }

  export type company_frontend_settingsScalarWhereWithAggregatesInput = {
    AND?: company_frontend_settingsScalarWhereWithAggregatesInput | company_frontend_settingsScalarWhereWithAggregatesInput[]
    OR?: company_frontend_settingsScalarWhereWithAggregatesInput[]
    NOT?: company_frontend_settingsScalarWhereWithAggregatesInput | company_frontend_settingsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"company_frontend_settings"> | bigint | number
    company_id?: BigIntWithAggregatesFilter<"company_frontend_settings"> | bigint | number
    settings?: JsonNullableWithAggregatesFilter<"company_frontend_settings">
    created_at?: DateTimeNullableWithAggregatesFilter<"company_frontend_settings"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"company_frontend_settings"> | Date | string | null
  }

  export type company_integrationsWhereInput = {
    AND?: company_integrationsWhereInput | company_integrationsWhereInput[]
    OR?: company_integrationsWhereInput[]
    NOT?: company_integrationsWhereInput | company_integrationsWhereInput[]
    id?: BigIntFilter<"company_integrations"> | bigint | number
    company_id?: BigIntFilter<"company_integrations"> | bigint | number
    provider?: StringFilter<"company_integrations"> | string
    credentials?: JsonFilter<"company_integrations">
    status?: BoolFilter<"company_integrations"> | boolean
    created_at?: DateTimeNullableFilter<"company_integrations"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"company_integrations"> | Date | string | null
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }

  export type company_integrationsOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrder
    provider?: SortOrder
    credentials?: SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    companies?: companiesOrderByWithRelationInput
    _relevance?: company_integrationsOrderByRelevanceInput
  }

  export type company_integrationsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    company_id_provider?: company_integrationsCompany_idProviderCompoundUniqueInput
    AND?: company_integrationsWhereInput | company_integrationsWhereInput[]
    OR?: company_integrationsWhereInput[]
    NOT?: company_integrationsWhereInput | company_integrationsWhereInput[]
    company_id?: BigIntFilter<"company_integrations"> | bigint | number
    provider?: StringFilter<"company_integrations"> | string
    credentials?: JsonFilter<"company_integrations">
    status?: BoolFilter<"company_integrations"> | boolean
    created_at?: DateTimeNullableFilter<"company_integrations"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"company_integrations"> | Date | string | null
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }, "id" | "company_id_provider">

  export type company_integrationsOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrder
    provider?: SortOrder
    credentials?: SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: company_integrationsCountOrderByAggregateInput
    _avg?: company_integrationsAvgOrderByAggregateInput
    _max?: company_integrationsMaxOrderByAggregateInput
    _min?: company_integrationsMinOrderByAggregateInput
    _sum?: company_integrationsSumOrderByAggregateInput
  }

  export type company_integrationsScalarWhereWithAggregatesInput = {
    AND?: company_integrationsScalarWhereWithAggregatesInput | company_integrationsScalarWhereWithAggregatesInput[]
    OR?: company_integrationsScalarWhereWithAggregatesInput[]
    NOT?: company_integrationsScalarWhereWithAggregatesInput | company_integrationsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"company_integrations"> | bigint | number
    company_id?: BigIntWithAggregatesFilter<"company_integrations"> | bigint | number
    provider?: StringWithAggregatesFilter<"company_integrations"> | string
    credentials?: JsonWithAggregatesFilter<"company_integrations">
    status?: BoolWithAggregatesFilter<"company_integrations"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"company_integrations"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"company_integrations"> | Date | string | null
  }

  export type company_profilesWhereInput = {
    AND?: company_profilesWhereInput | company_profilesWhereInput[]
    OR?: company_profilesWhereInput[]
    NOT?: company_profilesWhereInput | company_profilesWhereInput[]
    id?: BigIntFilter<"company_profiles"> | bigint | number
    company_id?: BigIntFilter<"company_profiles"> | bigint | number
    phone?: StringNullableFilter<"company_profiles"> | string | null
    address?: StringNullableFilter<"company_profiles"> | string | null
    country?: StringNullableFilter<"company_profiles"> | string | null
    zipcode?: StringNullableFilter<"company_profiles"> | string | null
    city?: StringNullableFilter<"company_profiles"> | string | null
    state?: StringNullableFilter<"company_profiles"> | string | null
    created_at?: DateTimeNullableFilter<"company_profiles"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"company_profiles"> | Date | string | null
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }

  export type company_profilesOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    zipcode?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    companies?: companiesOrderByWithRelationInput
    _relevance?: company_profilesOrderByRelevanceInput
  }

  export type company_profilesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: company_profilesWhereInput | company_profilesWhereInput[]
    OR?: company_profilesWhereInput[]
    NOT?: company_profilesWhereInput | company_profilesWhereInput[]
    company_id?: BigIntFilter<"company_profiles"> | bigint | number
    phone?: StringNullableFilter<"company_profiles"> | string | null
    address?: StringNullableFilter<"company_profiles"> | string | null
    country?: StringNullableFilter<"company_profiles"> | string | null
    zipcode?: StringNullableFilter<"company_profiles"> | string | null
    city?: StringNullableFilter<"company_profiles"> | string | null
    state?: StringNullableFilter<"company_profiles"> | string | null
    created_at?: DateTimeNullableFilter<"company_profiles"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"company_profiles"> | Date | string | null
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }, "id">

  export type company_profilesOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    country?: SortOrderInput | SortOrder
    zipcode?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    state?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: company_profilesCountOrderByAggregateInput
    _avg?: company_profilesAvgOrderByAggregateInput
    _max?: company_profilesMaxOrderByAggregateInput
    _min?: company_profilesMinOrderByAggregateInput
    _sum?: company_profilesSumOrderByAggregateInput
  }

  export type company_profilesScalarWhereWithAggregatesInput = {
    AND?: company_profilesScalarWhereWithAggregatesInput | company_profilesScalarWhereWithAggregatesInput[]
    OR?: company_profilesScalarWhereWithAggregatesInput[]
    NOT?: company_profilesScalarWhereWithAggregatesInput | company_profilesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"company_profiles"> | bigint | number
    company_id?: BigIntWithAggregatesFilter<"company_profiles"> | bigint | number
    phone?: StringNullableWithAggregatesFilter<"company_profiles"> | string | null
    address?: StringNullableWithAggregatesFilter<"company_profiles"> | string | null
    country?: StringNullableWithAggregatesFilter<"company_profiles"> | string | null
    zipcode?: StringNullableWithAggregatesFilter<"company_profiles"> | string | null
    city?: StringNullableWithAggregatesFilter<"company_profiles"> | string | null
    state?: StringNullableWithAggregatesFilter<"company_profiles"> | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"company_profiles"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"company_profiles"> | Date | string | null
  }

  export type company_subscriptionsWhereInput = {
    AND?: company_subscriptionsWhereInput | company_subscriptionsWhereInput[]
    OR?: company_subscriptionsWhereInput[]
    NOT?: company_subscriptionsWhereInput | company_subscriptionsWhereInput[]
    id?: BigIntFilter<"company_subscriptions"> | bigint | number
    company_id?: BigIntFilter<"company_subscriptions"> | bigint | number
    subscription_id?: BigIntFilter<"company_subscriptions"> | bigint | number
    start_date?: DateTimeFilter<"company_subscriptions"> | Date | string
    end_date?: DateTimeFilter<"company_subscriptions"> | Date | string
    status?: StringFilter<"company_subscriptions"> | string
    created_at?: DateTimeNullableFilter<"company_subscriptions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"company_subscriptions"> | Date | string | null
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    subscriptions?: XOR<SubscriptionsScalarRelationFilter, subscriptionsWhereInput>
    payments?: PaymentsListRelationFilter
  }

  export type company_subscriptionsOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrder
    subscription_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    companies?: companiesOrderByWithRelationInput
    subscriptions?: subscriptionsOrderByWithRelationInput
    payments?: paymentsOrderByRelationAggregateInput
    _relevance?: company_subscriptionsOrderByRelevanceInput
  }

  export type company_subscriptionsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: company_subscriptionsWhereInput | company_subscriptionsWhereInput[]
    OR?: company_subscriptionsWhereInput[]
    NOT?: company_subscriptionsWhereInput | company_subscriptionsWhereInput[]
    company_id?: BigIntFilter<"company_subscriptions"> | bigint | number
    subscription_id?: BigIntFilter<"company_subscriptions"> | bigint | number
    start_date?: DateTimeFilter<"company_subscriptions"> | Date | string
    end_date?: DateTimeFilter<"company_subscriptions"> | Date | string
    status?: StringFilter<"company_subscriptions"> | string
    created_at?: DateTimeNullableFilter<"company_subscriptions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"company_subscriptions"> | Date | string | null
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    subscriptions?: XOR<SubscriptionsScalarRelationFilter, subscriptionsWhereInput>
    payments?: PaymentsListRelationFilter
  }, "id">

  export type company_subscriptionsOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrder
    subscription_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: company_subscriptionsCountOrderByAggregateInput
    _avg?: company_subscriptionsAvgOrderByAggregateInput
    _max?: company_subscriptionsMaxOrderByAggregateInput
    _min?: company_subscriptionsMinOrderByAggregateInput
    _sum?: company_subscriptionsSumOrderByAggregateInput
  }

  export type company_subscriptionsScalarWhereWithAggregatesInput = {
    AND?: company_subscriptionsScalarWhereWithAggregatesInput | company_subscriptionsScalarWhereWithAggregatesInput[]
    OR?: company_subscriptionsScalarWhereWithAggregatesInput[]
    NOT?: company_subscriptionsScalarWhereWithAggregatesInput | company_subscriptionsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"company_subscriptions"> | bigint | number
    company_id?: BigIntWithAggregatesFilter<"company_subscriptions"> | bigint | number
    subscription_id?: BigIntWithAggregatesFilter<"company_subscriptions"> | bigint | number
    start_date?: DateTimeWithAggregatesFilter<"company_subscriptions"> | Date | string
    end_date?: DateTimeWithAggregatesFilter<"company_subscriptions"> | Date | string
    status?: StringWithAggregatesFilter<"company_subscriptions"> | string
    created_at?: DateTimeNullableWithAggregatesFilter<"company_subscriptions"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"company_subscriptions"> | Date | string | null
  }

  export type integration_category_mappingsWhereInput = {
    AND?: integration_category_mappingsWhereInput | integration_category_mappingsWhereInput[]
    OR?: integration_category_mappingsWhereInput[]
    NOT?: integration_category_mappingsWhereInput | integration_category_mappingsWhereInput[]
    id?: BigIntFilter<"integration_category_mappings"> | bigint | number
    company_id?: BigIntNullableFilter<"integration_category_mappings"> | bigint | number | null
    provider?: StringFilter<"integration_category_mappings"> | string
    external_category?: StringFilter<"integration_category_mappings"> | string
    category_id?: BigIntNullableFilter<"integration_category_mappings"> | bigint | number | null
    created_at?: DateTimeNullableFilter<"integration_category_mappings"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"integration_category_mappings"> | Date | string | null
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    companies?: XOR<CompaniesNullableScalarRelationFilter, companiesWhereInput> | null
  }

  export type integration_category_mappingsOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrderInput | SortOrder
    provider?: SortOrder
    external_category?: SortOrder
    category_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    categories?: categoriesOrderByWithRelationInput
    companies?: companiesOrderByWithRelationInput
    _relevance?: integration_category_mappingsOrderByRelevanceInput
  }

  export type integration_category_mappingsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    company_id_provider_external_category?: integration_category_mappingsCompany_idProviderExternal_categoryCompoundUniqueInput
    AND?: integration_category_mappingsWhereInput | integration_category_mappingsWhereInput[]
    OR?: integration_category_mappingsWhereInput[]
    NOT?: integration_category_mappingsWhereInput | integration_category_mappingsWhereInput[]
    company_id?: BigIntNullableFilter<"integration_category_mappings"> | bigint | number | null
    provider?: StringFilter<"integration_category_mappings"> | string
    external_category?: StringFilter<"integration_category_mappings"> | string
    category_id?: BigIntNullableFilter<"integration_category_mappings"> | bigint | number | null
    created_at?: DateTimeNullableFilter<"integration_category_mappings"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"integration_category_mappings"> | Date | string | null
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    companies?: XOR<CompaniesNullableScalarRelationFilter, companiesWhereInput> | null
  }, "id" | "company_id_provider_external_category">

  export type integration_category_mappingsOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrderInput | SortOrder
    provider?: SortOrder
    external_category?: SortOrder
    category_id?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: integration_category_mappingsCountOrderByAggregateInput
    _avg?: integration_category_mappingsAvgOrderByAggregateInput
    _max?: integration_category_mappingsMaxOrderByAggregateInput
    _min?: integration_category_mappingsMinOrderByAggregateInput
    _sum?: integration_category_mappingsSumOrderByAggregateInput
  }

  export type integration_category_mappingsScalarWhereWithAggregatesInput = {
    AND?: integration_category_mappingsScalarWhereWithAggregatesInput | integration_category_mappingsScalarWhereWithAggregatesInput[]
    OR?: integration_category_mappingsScalarWhereWithAggregatesInput[]
    NOT?: integration_category_mappingsScalarWhereWithAggregatesInput | integration_category_mappingsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"integration_category_mappings"> | bigint | number
    company_id?: BigIntNullableWithAggregatesFilter<"integration_category_mappings"> | bigint | number | null
    provider?: StringWithAggregatesFilter<"integration_category_mappings"> | string
    external_category?: StringWithAggregatesFilter<"integration_category_mappings"> | string
    category_id?: BigIntNullableWithAggregatesFilter<"integration_category_mappings"> | bigint | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"integration_category_mappings"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"integration_category_mappings"> | Date | string | null
  }

  export type menusWhereInput = {
    AND?: menusWhereInput | menusWhereInput[]
    OR?: menusWhereInput[]
    NOT?: menusWhereInput | menusWhereInput[]
    id?: BigIntFilter<"menus"> | bigint | number
    title?: StringFilter<"menus"> | string
    href?: StringNullableFilter<"menus"> | string | null
    icon?: StringNullableFilter<"menus"> | string | null
    role?: StringNullableFilter<"menus"> | string | null
    permission?: StringNullableFilter<"menus"> | string | null
    parent_id?: BigIntNullableFilter<"menus"> | bigint | number | null
    order?: IntFilter<"menus"> | number
    created_at?: DateTimeNullableFilter<"menus"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"menus"> | Date | string | null
    menus?: XOR<MenusNullableScalarRelationFilter, menusWhereInput> | null
    other_menus?: MenusListRelationFilter
  }

  export type menusOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    href?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    permission?: SortOrderInput | SortOrder
    parent_id?: SortOrderInput | SortOrder
    order?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    menus?: menusOrderByWithRelationInput
    other_menus?: menusOrderByRelationAggregateInput
    _relevance?: menusOrderByRelevanceInput
  }

  export type menusWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: menusWhereInput | menusWhereInput[]
    OR?: menusWhereInput[]
    NOT?: menusWhereInput | menusWhereInput[]
    title?: StringFilter<"menus"> | string
    href?: StringNullableFilter<"menus"> | string | null
    icon?: StringNullableFilter<"menus"> | string | null
    role?: StringNullableFilter<"menus"> | string | null
    permission?: StringNullableFilter<"menus"> | string | null
    parent_id?: BigIntNullableFilter<"menus"> | bigint | number | null
    order?: IntFilter<"menus"> | number
    created_at?: DateTimeNullableFilter<"menus"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"menus"> | Date | string | null
    menus?: XOR<MenusNullableScalarRelationFilter, menusWhereInput> | null
    other_menus?: MenusListRelationFilter
  }, "id">

  export type menusOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    href?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    permission?: SortOrderInput | SortOrder
    parent_id?: SortOrderInput | SortOrder
    order?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: menusCountOrderByAggregateInput
    _avg?: menusAvgOrderByAggregateInput
    _max?: menusMaxOrderByAggregateInput
    _min?: menusMinOrderByAggregateInput
    _sum?: menusSumOrderByAggregateInput
  }

  export type menusScalarWhereWithAggregatesInput = {
    AND?: menusScalarWhereWithAggregatesInput | menusScalarWhereWithAggregatesInput[]
    OR?: menusScalarWhereWithAggregatesInput[]
    NOT?: menusScalarWhereWithAggregatesInput | menusScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"menus"> | bigint | number
    title?: StringWithAggregatesFilter<"menus"> | string
    href?: StringNullableWithAggregatesFilter<"menus"> | string | null
    icon?: StringNullableWithAggregatesFilter<"menus"> | string | null
    role?: StringNullableWithAggregatesFilter<"menus"> | string | null
    permission?: StringNullableWithAggregatesFilter<"menus"> | string | null
    parent_id?: BigIntNullableWithAggregatesFilter<"menus"> | bigint | number | null
    order?: IntWithAggregatesFilter<"menus"> | number
    created_at?: DateTimeNullableWithAggregatesFilter<"menus"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"menus"> | Date | string | null
  }

  export type offer_categoryWhereInput = {
    AND?: offer_categoryWhereInput | offer_categoryWhereInput[]
    OR?: offer_categoryWhereInput[]
    NOT?: offer_categoryWhereInput | offer_categoryWhereInput[]
    id?: BigIntFilter<"offer_category"> | bigint | number
    offer_id?: BigIntFilter<"offer_category"> | bigint | number
    category_id?: BigIntFilter<"offer_category"> | bigint | number
    created_at?: DateTimeNullableFilter<"offer_category"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"offer_category"> | Date | string | null
    categories?: XOR<CategoriesScalarRelationFilter, categoriesWhereInput>
    offers?: XOR<OffersScalarRelationFilter, offersWhereInput>
  }

  export type offer_categoryOrderByWithRelationInput = {
    id?: SortOrder
    offer_id?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    categories?: categoriesOrderByWithRelationInput
    offers?: offersOrderByWithRelationInput
  }

  export type offer_categoryWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    offer_id_category_id?: offer_categoryOffer_idCategory_idCompoundUniqueInput
    AND?: offer_categoryWhereInput | offer_categoryWhereInput[]
    OR?: offer_categoryWhereInput[]
    NOT?: offer_categoryWhereInput | offer_categoryWhereInput[]
    offer_id?: BigIntFilter<"offer_category"> | bigint | number
    category_id?: BigIntFilter<"offer_category"> | bigint | number
    created_at?: DateTimeNullableFilter<"offer_category"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"offer_category"> | Date | string | null
    categories?: XOR<CategoriesScalarRelationFilter, categoriesWhereInput>
    offers?: XOR<OffersScalarRelationFilter, offersWhereInput>
  }, "id" | "offer_id_category_id">

  export type offer_categoryOrderByWithAggregationInput = {
    id?: SortOrder
    offer_id?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: offer_categoryCountOrderByAggregateInput
    _avg?: offer_categoryAvgOrderByAggregateInput
    _max?: offer_categoryMaxOrderByAggregateInput
    _min?: offer_categoryMinOrderByAggregateInput
    _sum?: offer_categorySumOrderByAggregateInput
  }

  export type offer_categoryScalarWhereWithAggregatesInput = {
    AND?: offer_categoryScalarWhereWithAggregatesInput | offer_categoryScalarWhereWithAggregatesInput[]
    OR?: offer_categoryScalarWhereWithAggregatesInput[]
    NOT?: offer_categoryScalarWhereWithAggregatesInput | offer_categoryScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"offer_category"> | bigint | number
    offer_id?: BigIntWithAggregatesFilter<"offer_category"> | bigint | number
    category_id?: BigIntWithAggregatesFilter<"offer_category"> | bigint | number
    created_at?: DateTimeNullableWithAggregatesFilter<"offer_category"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"offer_category"> | Date | string | null
  }

  export type offersWhereInput = {
    AND?: offersWhereInput | offersWhereInput[]
    OR?: offersWhereInput[]
    NOT?: offersWhereInput | offersWhereInput[]
    id?: BigIntFilter<"offers"> | bigint | number
    company_id?: BigIntFilter<"offers"> | bigint | number
    store_id?: BigIntFilter<"offers"> | bigint | number
    category_id?: BigIntNullableFilter<"offers"> | bigint | number | null
    title?: StringFilter<"offers"> | string
    description?: StringNullableFilter<"offers"> | string | null
    product_url?: StringNullableFilter<"offers"> | string | null
    image_url?: StringNullableFilter<"offers"> | string | null
    price?: DecimalNullableFilter<"offers"> | Decimal | DecimalJsLike | number | string | null
    code?: StringNullableFilter<"offers"> | string | null
    start_date?: DateTimeNullableFilter<"offers"> | Date | string | null
    end_date?: DateTimeNullableFilter<"offers"> | Date | string | null
    link?: StringNullableFilter<"offers"> | string | null
    is_featured?: BoolFilter<"offers"> | boolean
    is_exclusive?: BoolFilter<"offers"> | boolean
    is_deal?: BoolFilter<"offers"> | boolean
    path?: StringNullableFilter<"offers"> | string | null
    thumbnail?: StringNullableFilter<"offers"> | string | null
    sku?: StringNullableFilter<"offers"> | string | null
    product_name?: StringNullableFilter<"offers"> | string | null
    product_price?: DecimalNullableFilter<"offers"> | Decimal | DecimalJsLike | number | string | null
    old_price?: DecimalNullableFilter<"offers"> | Decimal | DecimalJsLike | number | string | null
    source?: StringNullableFilter<"offers"> | string | null
    type?: Enumoffers_typeFilter<"offers"> | $Enums.offers_type
    external_id?: StringNullableFilter<"offers"> | string | null
    status?: BoolFilter<"offers"> | boolean
    created_at?: DateTimeNullableFilter<"offers"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"offers"> | Date | string | null
    offer_category?: Offer_categoryListRelationFilter
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    stores?: XOR<StoresScalarRelationFilter, storesWhereInput>
  }

  export type offersOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrder
    store_id?: SortOrder
    category_id?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    product_url?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    is_featured?: SortOrder
    is_exclusive?: SortOrder
    is_deal?: SortOrder
    path?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    product_name?: SortOrderInput | SortOrder
    product_price?: SortOrderInput | SortOrder
    old_price?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    type?: SortOrder
    external_id?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    offer_category?: offer_categoryOrderByRelationAggregateInput
    categories?: categoriesOrderByWithRelationInput
    companies?: companiesOrderByWithRelationInput
    stores?: storesOrderByWithRelationInput
    _relevance?: offersOrderByRelevanceInput
  }

  export type offersWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    company_id_external_id_source?: offersCompany_idExternal_idSourceCompoundUniqueInput
    AND?: offersWhereInput | offersWhereInput[]
    OR?: offersWhereInput[]
    NOT?: offersWhereInput | offersWhereInput[]
    company_id?: BigIntFilter<"offers"> | bigint | number
    store_id?: BigIntFilter<"offers"> | bigint | number
    category_id?: BigIntNullableFilter<"offers"> | bigint | number | null
    title?: StringFilter<"offers"> | string
    description?: StringNullableFilter<"offers"> | string | null
    product_url?: StringNullableFilter<"offers"> | string | null
    image_url?: StringNullableFilter<"offers"> | string | null
    price?: DecimalNullableFilter<"offers"> | Decimal | DecimalJsLike | number | string | null
    code?: StringNullableFilter<"offers"> | string | null
    start_date?: DateTimeNullableFilter<"offers"> | Date | string | null
    end_date?: DateTimeNullableFilter<"offers"> | Date | string | null
    link?: StringNullableFilter<"offers"> | string | null
    is_featured?: BoolFilter<"offers"> | boolean
    is_exclusive?: BoolFilter<"offers"> | boolean
    is_deal?: BoolFilter<"offers"> | boolean
    path?: StringNullableFilter<"offers"> | string | null
    thumbnail?: StringNullableFilter<"offers"> | string | null
    sku?: StringNullableFilter<"offers"> | string | null
    product_name?: StringNullableFilter<"offers"> | string | null
    product_price?: DecimalNullableFilter<"offers"> | Decimal | DecimalJsLike | number | string | null
    old_price?: DecimalNullableFilter<"offers"> | Decimal | DecimalJsLike | number | string | null
    source?: StringNullableFilter<"offers"> | string | null
    type?: Enumoffers_typeFilter<"offers"> | $Enums.offers_type
    external_id?: StringNullableFilter<"offers"> | string | null
    status?: BoolFilter<"offers"> | boolean
    created_at?: DateTimeNullableFilter<"offers"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"offers"> | Date | string | null
    offer_category?: Offer_categoryListRelationFilter
    categories?: XOR<CategoriesNullableScalarRelationFilter, categoriesWhereInput> | null
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
    stores?: XOR<StoresScalarRelationFilter, storesWhereInput>
  }, "id" | "company_id_external_id_source">

  export type offersOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrder
    store_id?: SortOrder
    category_id?: SortOrderInput | SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    product_url?: SortOrderInput | SortOrder
    image_url?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    code?: SortOrderInput | SortOrder
    start_date?: SortOrderInput | SortOrder
    end_date?: SortOrderInput | SortOrder
    link?: SortOrderInput | SortOrder
    is_featured?: SortOrder
    is_exclusive?: SortOrder
    is_deal?: SortOrder
    path?: SortOrderInput | SortOrder
    thumbnail?: SortOrderInput | SortOrder
    sku?: SortOrderInput | SortOrder
    product_name?: SortOrderInput | SortOrder
    product_price?: SortOrderInput | SortOrder
    old_price?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    type?: SortOrder
    external_id?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: offersCountOrderByAggregateInput
    _avg?: offersAvgOrderByAggregateInput
    _max?: offersMaxOrderByAggregateInput
    _min?: offersMinOrderByAggregateInput
    _sum?: offersSumOrderByAggregateInput
  }

  export type offersScalarWhereWithAggregatesInput = {
    AND?: offersScalarWhereWithAggregatesInput | offersScalarWhereWithAggregatesInput[]
    OR?: offersScalarWhereWithAggregatesInput[]
    NOT?: offersScalarWhereWithAggregatesInput | offersScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"offers"> | bigint | number
    company_id?: BigIntWithAggregatesFilter<"offers"> | bigint | number
    store_id?: BigIntWithAggregatesFilter<"offers"> | bigint | number
    category_id?: BigIntNullableWithAggregatesFilter<"offers"> | bigint | number | null
    title?: StringWithAggregatesFilter<"offers"> | string
    description?: StringNullableWithAggregatesFilter<"offers"> | string | null
    product_url?: StringNullableWithAggregatesFilter<"offers"> | string | null
    image_url?: StringNullableWithAggregatesFilter<"offers"> | string | null
    price?: DecimalNullableWithAggregatesFilter<"offers"> | Decimal | DecimalJsLike | number | string | null
    code?: StringNullableWithAggregatesFilter<"offers"> | string | null
    start_date?: DateTimeNullableWithAggregatesFilter<"offers"> | Date | string | null
    end_date?: DateTimeNullableWithAggregatesFilter<"offers"> | Date | string | null
    link?: StringNullableWithAggregatesFilter<"offers"> | string | null
    is_featured?: BoolWithAggregatesFilter<"offers"> | boolean
    is_exclusive?: BoolWithAggregatesFilter<"offers"> | boolean
    is_deal?: BoolWithAggregatesFilter<"offers"> | boolean
    path?: StringNullableWithAggregatesFilter<"offers"> | string | null
    thumbnail?: StringNullableWithAggregatesFilter<"offers"> | string | null
    sku?: StringNullableWithAggregatesFilter<"offers"> | string | null
    product_name?: StringNullableWithAggregatesFilter<"offers"> | string | null
    product_price?: DecimalNullableWithAggregatesFilter<"offers"> | Decimal | DecimalJsLike | number | string | null
    old_price?: DecimalNullableWithAggregatesFilter<"offers"> | Decimal | DecimalJsLike | number | string | null
    source?: StringNullableWithAggregatesFilter<"offers"> | string | null
    type?: Enumoffers_typeWithAggregatesFilter<"offers"> | $Enums.offers_type
    external_id?: StringNullableWithAggregatesFilter<"offers"> | string | null
    status?: BoolWithAggregatesFilter<"offers"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"offers"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"offers"> | Date | string | null
  }

  export type paymentsWhereInput = {
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    id?: BigIntFilter<"payments"> | bigint | number
    company_subscription_id?: BigIntFilter<"payments"> | bigint | number
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_method?: StringFilter<"payments"> | string
    payment_status?: StringFilter<"payments"> | string
    transaction_id?: StringNullableFilter<"payments"> | string | null
    paid_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    created_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    company_subscriptions?: XOR<Company_subscriptionsScalarRelationFilter, company_subscriptionsWhereInput>
  }

  export type paymentsOrderByWithRelationInput = {
    id?: SortOrder
    company_subscription_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    payment_status?: SortOrder
    transaction_id?: SortOrderInput | SortOrder
    paid_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    company_subscriptions?: company_subscriptionsOrderByWithRelationInput
    _relevance?: paymentsOrderByRelevanceInput
  }

  export type paymentsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: paymentsWhereInput | paymentsWhereInput[]
    OR?: paymentsWhereInput[]
    NOT?: paymentsWhereInput | paymentsWhereInput[]
    company_subscription_id?: BigIntFilter<"payments"> | bigint | number
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_method?: StringFilter<"payments"> | string
    payment_status?: StringFilter<"payments"> | string
    transaction_id?: StringNullableFilter<"payments"> | string | null
    paid_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    created_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    company_subscriptions?: XOR<Company_subscriptionsScalarRelationFilter, company_subscriptionsWhereInput>
  }, "id">

  export type paymentsOrderByWithAggregationInput = {
    id?: SortOrder
    company_subscription_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    payment_status?: SortOrder
    transaction_id?: SortOrderInput | SortOrder
    paid_at?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: paymentsCountOrderByAggregateInput
    _avg?: paymentsAvgOrderByAggregateInput
    _max?: paymentsMaxOrderByAggregateInput
    _min?: paymentsMinOrderByAggregateInput
    _sum?: paymentsSumOrderByAggregateInput
  }

  export type paymentsScalarWhereWithAggregatesInput = {
    AND?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    OR?: paymentsScalarWhereWithAggregatesInput[]
    NOT?: paymentsScalarWhereWithAggregatesInput | paymentsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"payments"> | bigint | number
    company_subscription_id?: BigIntWithAggregatesFilter<"payments"> | bigint | number
    amount?: DecimalWithAggregatesFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_method?: StringWithAggregatesFilter<"payments"> | string
    payment_status?: StringWithAggregatesFilter<"payments"> | string
    transaction_id?: StringNullableWithAggregatesFilter<"payments"> | string | null
    paid_at?: DateTimeNullableWithAggregatesFilter<"payments"> | Date | string | null
    created_at?: DateTimeNullableWithAggregatesFilter<"payments"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"payments"> | Date | string | null
  }

  export type storesWhereInput = {
    AND?: storesWhereInput | storesWhereInput[]
    OR?: storesWhereInput[]
    NOT?: storesWhereInput | storesWhereInput[]
    id?: BigIntFilter<"stores"> | bigint | number
    company_id?: BigIntFilter<"stores"> | bigint | number
    name?: StringFilter<"stores"> | string
    image?: StringNullableFilter<"stores"> | string | null
    description?: StringNullableFilter<"stores"> | string | null
    status?: IntFilter<"stores"> | number
    channelId?: BigIntNullableFilter<"stores"> | bigint | number | null
    channelName?: StringNullableFilter<"stores"> | string | null
    programId?: BigIntNullableFilter<"stores"> | bigint | number | null
    categoryName?: StringNullableFilter<"stores"> | string | null
    categoryId?: BigIntNullableFilter<"stores"> | bigint | number | null
    productFeedId?: BigIntNullableFilter<"stores"> | bigint | number | null
    created_at?: DateTimeNullableFilter<"stores"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"stores"> | Date | string | null
    offers?: OffersListRelationFilter
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }

  export type storesOrderByWithRelationInput = {
    id?: SortOrder
    company_id?: SortOrder
    name?: SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    channelId?: SortOrderInput | SortOrder
    channelName?: SortOrderInput | SortOrder
    programId?: SortOrderInput | SortOrder
    categoryName?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    productFeedId?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    offers?: offersOrderByRelationAggregateInput
    companies?: companiesOrderByWithRelationInput
    _relevance?: storesOrderByRelevanceInput
  }

  export type storesWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: storesWhereInput | storesWhereInput[]
    OR?: storesWhereInput[]
    NOT?: storesWhereInput | storesWhereInput[]
    company_id?: BigIntFilter<"stores"> | bigint | number
    name?: StringFilter<"stores"> | string
    image?: StringNullableFilter<"stores"> | string | null
    description?: StringNullableFilter<"stores"> | string | null
    status?: IntFilter<"stores"> | number
    channelId?: BigIntNullableFilter<"stores"> | bigint | number | null
    channelName?: StringNullableFilter<"stores"> | string | null
    programId?: BigIntNullableFilter<"stores"> | bigint | number | null
    categoryName?: StringNullableFilter<"stores"> | string | null
    categoryId?: BigIntNullableFilter<"stores"> | bigint | number | null
    productFeedId?: BigIntNullableFilter<"stores"> | bigint | number | null
    created_at?: DateTimeNullableFilter<"stores"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"stores"> | Date | string | null
    offers?: OffersListRelationFilter
    companies?: XOR<CompaniesScalarRelationFilter, companiesWhereInput>
  }, "id">

  export type storesOrderByWithAggregationInput = {
    id?: SortOrder
    company_id?: SortOrder
    name?: SortOrder
    image?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    channelId?: SortOrderInput | SortOrder
    channelName?: SortOrderInput | SortOrder
    programId?: SortOrderInput | SortOrder
    categoryName?: SortOrderInput | SortOrder
    categoryId?: SortOrderInput | SortOrder
    productFeedId?: SortOrderInput | SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: storesCountOrderByAggregateInput
    _avg?: storesAvgOrderByAggregateInput
    _max?: storesMaxOrderByAggregateInput
    _min?: storesMinOrderByAggregateInput
    _sum?: storesSumOrderByAggregateInput
  }

  export type storesScalarWhereWithAggregatesInput = {
    AND?: storesScalarWhereWithAggregatesInput | storesScalarWhereWithAggregatesInput[]
    OR?: storesScalarWhereWithAggregatesInput[]
    NOT?: storesScalarWhereWithAggregatesInput | storesScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"stores"> | bigint | number
    company_id?: BigIntWithAggregatesFilter<"stores"> | bigint | number
    name?: StringWithAggregatesFilter<"stores"> | string
    image?: StringNullableWithAggregatesFilter<"stores"> | string | null
    description?: StringNullableWithAggregatesFilter<"stores"> | string | null
    status?: IntWithAggregatesFilter<"stores"> | number
    channelId?: BigIntNullableWithAggregatesFilter<"stores"> | bigint | number | null
    channelName?: StringNullableWithAggregatesFilter<"stores"> | string | null
    programId?: BigIntNullableWithAggregatesFilter<"stores"> | bigint | number | null
    categoryName?: StringNullableWithAggregatesFilter<"stores"> | string | null
    categoryId?: BigIntNullableWithAggregatesFilter<"stores"> | bigint | number | null
    productFeedId?: BigIntNullableWithAggregatesFilter<"stores"> | bigint | number | null
    created_at?: DateTimeNullableWithAggregatesFilter<"stores"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"stores"> | Date | string | null
  }

  export type subscriptionsWhereInput = {
    AND?: subscriptionsWhereInput | subscriptionsWhereInput[]
    OR?: subscriptionsWhereInput[]
    NOT?: subscriptionsWhereInput | subscriptionsWhereInput[]
    id?: BigIntFilter<"subscriptions"> | bigint | number
    name?: StringFilter<"subscriptions"> | string
    price?: DecimalFilter<"subscriptions"> | Decimal | DecimalJsLike | number | string
    duration?: IntFilter<"subscriptions"> | number
    features?: JsonNullableFilter<"subscriptions">
    status?: BoolFilter<"subscriptions"> | boolean
    created_at?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    company_subscriptions?: Company_subscriptionsListRelationFilter
  }

  export type subscriptionsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    features?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    company_subscriptions?: company_subscriptionsOrderByRelationAggregateInput
    _relevance?: subscriptionsOrderByRelevanceInput
  }

  export type subscriptionsWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: subscriptionsWhereInput | subscriptionsWhereInput[]
    OR?: subscriptionsWhereInput[]
    NOT?: subscriptionsWhereInput | subscriptionsWhereInput[]
    name?: StringFilter<"subscriptions"> | string
    price?: DecimalFilter<"subscriptions"> | Decimal | DecimalJsLike | number | string
    duration?: IntFilter<"subscriptions"> | number
    features?: JsonNullableFilter<"subscriptions">
    status?: BoolFilter<"subscriptions"> | boolean
    created_at?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"subscriptions"> | Date | string | null
    company_subscriptions?: Company_subscriptionsListRelationFilter
  }, "id">

  export type subscriptionsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    features?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrderInput | SortOrder
    updated_at?: SortOrderInput | SortOrder
    _count?: subscriptionsCountOrderByAggregateInput
    _avg?: subscriptionsAvgOrderByAggregateInput
    _max?: subscriptionsMaxOrderByAggregateInput
    _min?: subscriptionsMinOrderByAggregateInput
    _sum?: subscriptionsSumOrderByAggregateInput
  }

  export type subscriptionsScalarWhereWithAggregatesInput = {
    AND?: subscriptionsScalarWhereWithAggregatesInput | subscriptionsScalarWhereWithAggregatesInput[]
    OR?: subscriptionsScalarWhereWithAggregatesInput[]
    NOT?: subscriptionsScalarWhereWithAggregatesInput | subscriptionsScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"subscriptions"> | bigint | number
    name?: StringWithAggregatesFilter<"subscriptions"> | string
    price?: DecimalWithAggregatesFilter<"subscriptions"> | Decimal | DecimalJsLike | number | string
    duration?: IntWithAggregatesFilter<"subscriptions"> | number
    features?: JsonNullableWithAggregatesFilter<"subscriptions">
    status?: BoolWithAggregatesFilter<"subscriptions"> | boolean
    created_at?: DateTimeNullableWithAggregatesFilter<"subscriptions"> | Date | string | null
    updated_at?: DateTimeNullableWithAggregatesFilter<"subscriptions"> | Date | string | null
  }

  export type failed_jobsCreateInput = {
    id?: bigint | number
    uuid: string
    connection: string
    queue: string
    payload: string
    exception: string
    failed_at?: Date | string
  }

  export type failed_jobsUncheckedCreateInput = {
    id?: bigint | number
    uuid: string
    connection: string
    queue: string
    payload: string
    exception: string
    failed_at?: Date | string
  }

  export type failed_jobsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    uuid?: StringFieldUpdateOperationsInput | string
    connection?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    exception?: StringFieldUpdateOperationsInput | string
    failed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type failed_jobsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    uuid?: StringFieldUpdateOperationsInput | string
    connection?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    exception?: StringFieldUpdateOperationsInput | string
    failed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type failed_jobsCreateManyInput = {
    id?: bigint | number
    uuid: string
    connection: string
    queue: string
    payload: string
    exception: string
    failed_at?: Date | string
  }

  export type failed_jobsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    uuid?: StringFieldUpdateOperationsInput | string
    connection?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    exception?: StringFieldUpdateOperationsInput | string
    failed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type failed_jobsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    uuid?: StringFieldUpdateOperationsInput | string
    connection?: StringFieldUpdateOperationsInput | string
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    exception?: StringFieldUpdateOperationsInput | string
    failed_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type jobsCreateInput = {
    id?: bigint | number
    queue: string
    payload: string
    attempts: number
    reserved_at?: number | null
    available_at: number
    created_at: number
  }

  export type jobsUncheckedCreateInput = {
    id?: bigint | number
    queue: string
    payload: string
    attempts: number
    reserved_at?: number | null
    available_at: number
    created_at: number
  }

  export type jobsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    reserved_at?: NullableIntFieldUpdateOperationsInput | number | null
    available_at?: IntFieldUpdateOperationsInput | number
    created_at?: IntFieldUpdateOperationsInput | number
  }

  export type jobsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    reserved_at?: NullableIntFieldUpdateOperationsInput | number | null
    available_at?: IntFieldUpdateOperationsInput | number
    created_at?: IntFieldUpdateOperationsInput | number
  }

  export type jobsCreateManyInput = {
    id?: bigint | number
    queue: string
    payload: string
    attempts: number
    reserved_at?: number | null
    available_at: number
    created_at: number
  }

  export type jobsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    reserved_at?: NullableIntFieldUpdateOperationsInput | number | null
    available_at?: IntFieldUpdateOperationsInput | number
    created_at?: IntFieldUpdateOperationsInput | number
  }

  export type jobsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    queue?: StringFieldUpdateOperationsInput | string
    payload?: StringFieldUpdateOperationsInput | string
    attempts?: IntFieldUpdateOperationsInput | number
    reserved_at?: NullableIntFieldUpdateOperationsInput | number | null
    available_at?: IntFieldUpdateOperationsInput | number
    created_at?: IntFieldUpdateOperationsInput | number
  }

  export type migrationsCreateInput = {
    migration: string
    batch: number
  }

  export type migrationsUncheckedCreateInput = {
    id?: number
    migration: string
    batch: number
  }

  export type migrationsUpdateInput = {
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type migrationsUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type migrationsCreateManyInput = {
    id?: number
    migration: string
    batch: number
  }

  export type migrationsUpdateManyMutationInput = {
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type migrationsUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    migration?: StringFieldUpdateOperationsInput | string
    batch?: IntFieldUpdateOperationsInput | number
  }

  export type model_has_permissionsCreateInput = {
    model_type: string
    model_id: bigint | number
    permissions: permissionsCreateNestedOneWithoutModel_has_permissionsInput
  }

  export type model_has_permissionsUncheckedCreateInput = {
    permission_id: bigint | number
    model_type: string
    model_id: bigint | number
  }

  export type model_has_permissionsUpdateInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
    permissions?: permissionsUpdateOneRequiredWithoutModel_has_permissionsNestedInput
  }

  export type model_has_permissionsUncheckedUpdateInput = {
    permission_id?: BigIntFieldUpdateOperationsInput | bigint | number
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_permissionsCreateManyInput = {
    permission_id: bigint | number
    model_type: string
    model_id: bigint | number
  }

  export type model_has_permissionsUpdateManyMutationInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_permissionsUncheckedUpdateManyInput = {
    permission_id?: BigIntFieldUpdateOperationsInput | bigint | number
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_rolesCreateInput = {
    model_type: string
    model_id: bigint | number
    roles: rolesCreateNestedOneWithoutModel_has_rolesInput
  }

  export type model_has_rolesUncheckedCreateInput = {
    role_id: bigint | number
    model_type: string
    model_id: bigint | number
  }

  export type model_has_rolesUpdateInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
    roles?: rolesUpdateOneRequiredWithoutModel_has_rolesNestedInput
  }

  export type model_has_rolesUncheckedUpdateInput = {
    role_id?: BigIntFieldUpdateOperationsInput | bigint | number
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_rolesCreateManyInput = {
    role_id: bigint | number
    model_type: string
    model_id: bigint | number
  }

  export type model_has_rolesUpdateManyMutationInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_rolesUncheckedUpdateManyInput = {
    role_id?: BigIntFieldUpdateOperationsInput | bigint | number
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type password_reset_tokensCreateInput = {
    email: string
    token: string
    created_at?: Date | string | null
  }

  export type password_reset_tokensUncheckedCreateInput = {
    email: string
    token: string
    created_at?: Date | string | null
  }

  export type password_reset_tokensUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_reset_tokensUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_reset_tokensCreateManyInput = {
    email: string
    token: string
    created_at?: Date | string | null
  }

  export type password_reset_tokensUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type password_reset_tokensUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type permissionsCreateInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    model_has_permissions?: model_has_permissionsCreateNestedManyWithoutPermissionsInput
    role_has_permissions?: role_has_permissionsCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsUncheckedCreateInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    model_has_permissions?: model_has_permissionsUncheckedCreateNestedManyWithoutPermissionsInput
    role_has_permissions?: role_has_permissionsUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_has_permissions?: model_has_permissionsUpdateManyWithoutPermissionsNestedInput
    role_has_permissions?: role_has_permissionsUpdateManyWithoutPermissionsNestedInput
  }

  export type permissionsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_has_permissions?: model_has_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput
    role_has_permissions?: role_has_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type permissionsCreateManyInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type permissionsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type permissionsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type role_has_permissionsCreateInput = {
    permissions: permissionsCreateNestedOneWithoutRole_has_permissionsInput
    roles: rolesCreateNestedOneWithoutRole_has_permissionsInput
  }

  export type role_has_permissionsUncheckedCreateInput = {
    permission_id: bigint | number
    role_id: bigint | number
  }

  export type role_has_permissionsUpdateInput = {
    permissions?: permissionsUpdateOneRequiredWithoutRole_has_permissionsNestedInput
    roles?: rolesUpdateOneRequiredWithoutRole_has_permissionsNestedInput
  }

  export type role_has_permissionsUncheckedUpdateInput = {
    permission_id?: BigIntFieldUpdateOperationsInput | bigint | number
    role_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type role_has_permissionsCreateManyInput = {
    permission_id: bigint | number
    role_id: bigint | number
  }

  export type role_has_permissionsUpdateManyMutationInput = {

  }

  export type role_has_permissionsUncheckedUpdateManyInput = {
    permission_id?: BigIntFieldUpdateOperationsInput | bigint | number
    role_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type rolesCreateInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    model_has_roles?: model_has_rolesCreateNestedManyWithoutRolesInput
    role_has_permissions?: role_has_permissionsCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    model_has_roles?: model_has_rolesUncheckedCreateNestedManyWithoutRolesInput
    role_has_permissions?: role_has_permissionsUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_has_roles?: model_has_rolesUpdateManyWithoutRolesNestedInput
    role_has_permissions?: role_has_permissionsUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_has_roles?: model_has_rolesUncheckedUpdateManyWithoutRolesNestedInput
    role_has_permissions?: role_has_permissionsUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type rolesCreateManyInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type rolesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type rolesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    companies?: companiesCreateNestedOneWithoutUsersInput
  }

  export type usersUncheckedCreateInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    company_id?: bigint | number | null
    remember_token?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneWithoutUsersNestedInput
  }

  export type usersUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    company_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersCreateManyInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    company_id?: bigint | number | null
    remember_token?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    company_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type cacheCreateInput = {
    key: string
    value: string
    expiration: number
  }

  export type cacheUncheckedCreateInput = {
    key: string
    value: string
    expiration: number
  }

  export type cacheUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cacheUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cacheCreateManyInput = {
    key: string
    value: string
    expiration: number
  }

  export type cacheUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cacheUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cache_locksCreateInput = {
    key: string
    owner: string
    expiration: number
  }

  export type cache_locksUncheckedCreateInput = {
    key: string
    owner: string
    expiration: number
  }

  export type cache_locksUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cache_locksUncheckedUpdateInput = {
    key?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cache_locksCreateManyInput = {
    key: string
    owner: string
    expiration: number
  }

  export type cache_locksUpdateManyMutationInput = {
    key?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type cache_locksUncheckedUpdateManyInput = {
    key?: StringFieldUpdateOperationsInput | string
    owner?: StringFieldUpdateOperationsInput | string
    expiration?: IntFieldUpdateOperationsInput | number
  }

  export type job_batchesCreateInput = {
    id: string
    name: string
    total_jobs: number
    pending_jobs: number
    failed_jobs: number
    failed_job_ids: string
    options?: string | null
    cancelled_at?: number | null
    created_at: number
    finished_at?: number | null
  }

  export type job_batchesUncheckedCreateInput = {
    id: string
    name: string
    total_jobs: number
    pending_jobs: number
    failed_jobs: number
    failed_job_ids: string
    options?: string | null
    cancelled_at?: number | null
    created_at: number
    finished_at?: number | null
  }

  export type job_batchesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    total_jobs?: IntFieldUpdateOperationsInput | number
    pending_jobs?: IntFieldUpdateOperationsInput | number
    failed_jobs?: IntFieldUpdateOperationsInput | number
    failed_job_ids?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: IntFieldUpdateOperationsInput | number
    finished_at?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type job_batchesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    total_jobs?: IntFieldUpdateOperationsInput | number
    pending_jobs?: IntFieldUpdateOperationsInput | number
    failed_jobs?: IntFieldUpdateOperationsInput | number
    failed_job_ids?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: IntFieldUpdateOperationsInput | number
    finished_at?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type job_batchesCreateManyInput = {
    id: string
    name: string
    total_jobs: number
    pending_jobs: number
    failed_jobs: number
    failed_job_ids: string
    options?: string | null
    cancelled_at?: number | null
    created_at: number
    finished_at?: number | null
  }

  export type job_batchesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    total_jobs?: IntFieldUpdateOperationsInput | number
    pending_jobs?: IntFieldUpdateOperationsInput | number
    failed_jobs?: IntFieldUpdateOperationsInput | number
    failed_job_ids?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: IntFieldUpdateOperationsInput | number
    finished_at?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type job_batchesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    total_jobs?: IntFieldUpdateOperationsInput | number
    pending_jobs?: IntFieldUpdateOperationsInput | number
    failed_jobs?: IntFieldUpdateOperationsInput | number
    failed_job_ids?: StringFieldUpdateOperationsInput | string
    options?: NullableStringFieldUpdateOperationsInput | string | null
    cancelled_at?: NullableIntFieldUpdateOperationsInput | number | null
    created_at?: IntFieldUpdateOperationsInput | number
    finished_at?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type sessionsCreateInput = {
    id: string
    user_id?: bigint | number | null
    ip_address?: string | null
    user_agent?: string | null
    payload: string
    last_activity: number
  }

  export type sessionsUncheckedCreateInput = {
    id: string
    user_id?: bigint | number | null
    ip_address?: string | null
    user_agent?: string | null
    payload: string
    last_activity: number
  }

  export type sessionsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    last_activity?: IntFieldUpdateOperationsInput | number
  }

  export type sessionsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    last_activity?: IntFieldUpdateOperationsInput | number
  }

  export type sessionsCreateManyInput = {
    id: string
    user_id?: bigint | number | null
    ip_address?: string | null
    user_agent?: string | null
    payload: string
    last_activity: number
  }

  export type sessionsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    last_activity?: IntFieldUpdateOperationsInput | number
  }

  export type sessionsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    ip_address?: NullableStringFieldUpdateOperationsInput | string | null
    user_agent?: NullableStringFieldUpdateOperationsInput | string | null
    payload?: StringFieldUpdateOperationsInput | string
    last_activity?: IntFieldUpdateOperationsInput | number
  }

  export type categoriesCreateInput = {
    id?: bigint | number
    name: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    companies: companiesCreateNestedOneWithoutCategoriesInput
    categories?: categoriesCreateNestedOneWithoutOther_categoriesInput
    other_categories?: categoriesCreateNestedManyWithoutCategoriesInput
    integration_category_mappings?: integration_category_mappingsCreateNestedManyWithoutCategoriesInput
    offer_category?: offer_categoryCreateNestedManyWithoutCategoriesInput
    offers?: offersCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateInput = {
    id?: bigint | number
    name: string
    parent_id?: bigint | number | null
    company_id: bigint | number
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    other_categories?: categoriesUncheckedCreateNestedManyWithoutCategoriesInput
    integration_category_mappings?: integration_category_mappingsUncheckedCreateNestedManyWithoutCategoriesInput
    offer_category?: offer_categoryUncheckedCreateNestedManyWithoutCategoriesInput
    offers?: offersUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutCategoriesNestedInput
    categories?: categoriesUpdateOneWithoutOther_categoriesNestedInput
    other_categories?: categoriesUpdateManyWithoutCategoriesNestedInput
    integration_category_mappings?: integration_category_mappingsUpdateManyWithoutCategoriesNestedInput
    offer_category?: offer_categoryUpdateManyWithoutCategoriesNestedInput
    offers?: offersUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_categories?: categoriesUncheckedUpdateManyWithoutCategoriesNestedInput
    integration_category_mappings?: integration_category_mappingsUncheckedUpdateManyWithoutCategoriesNestedInput
    offer_category?: offer_categoryUncheckedUpdateManyWithoutCategoriesNestedInput
    offers?: offersUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesCreateManyInput = {
    id?: bigint | number
    name: string
    parent_id?: bigint | number | null
    company_id: bigint | number
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type categoriesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type categoriesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companiesCreateInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutCompaniesInput
    company_frontend_settings?: company_frontend_settingsCreateNestedManyWithoutCompaniesInput
    company_integrations?: company_integrationsCreateNestedManyWithoutCompaniesInput
    company_profiles?: company_profilesCreateNestedManyWithoutCompaniesInput
    company_subscriptions?: company_subscriptionsCreateNestedManyWithoutCompaniesInput
    integration_category_mappings?: integration_category_mappingsCreateNestedManyWithoutCompaniesInput
    offers?: offersCreateNestedManyWithoutCompaniesInput
    stores?: storesCreateNestedManyWithoutCompaniesInput
    users?: usersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutCompaniesInput
    company_frontend_settings?: company_frontend_settingsUncheckedCreateNestedManyWithoutCompaniesInput
    company_integrations?: company_integrationsUncheckedCreateNestedManyWithoutCompaniesInput
    company_profiles?: company_profilesUncheckedCreateNestedManyWithoutCompaniesInput
    company_subscriptions?: company_subscriptionsUncheckedCreateNestedManyWithoutCompaniesInput
    integration_category_mappings?: integration_category_mappingsUncheckedCreateNestedManyWithoutCompaniesInput
    offers?: offersUncheckedCreateNestedManyWithoutCompaniesInput
    stores?: storesUncheckedCreateNestedManyWithoutCompaniesInput
    users?: usersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutCompaniesNestedInput
    company_frontend_settings?: company_frontend_settingsUpdateManyWithoutCompaniesNestedInput
    company_integrations?: company_integrationsUpdateManyWithoutCompaniesNestedInput
    company_profiles?: company_profilesUpdateManyWithoutCompaniesNestedInput
    company_subscriptions?: company_subscriptionsUpdateManyWithoutCompaniesNestedInput
    integration_category_mappings?: integration_category_mappingsUpdateManyWithoutCompaniesNestedInput
    offers?: offersUpdateManyWithoutCompaniesNestedInput
    stores?: storesUpdateManyWithoutCompaniesNestedInput
    users?: usersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutCompaniesNestedInput
    company_frontend_settings?: company_frontend_settingsUncheckedUpdateManyWithoutCompaniesNestedInput
    company_integrations?: company_integrationsUncheckedUpdateManyWithoutCompaniesNestedInput
    company_profiles?: company_profilesUncheckedUpdateManyWithoutCompaniesNestedInput
    company_subscriptions?: company_subscriptionsUncheckedUpdateManyWithoutCompaniesNestedInput
    integration_category_mappings?: integration_category_mappingsUncheckedUpdateManyWithoutCompaniesNestedInput
    offers?: offersUncheckedUpdateManyWithoutCompaniesNestedInput
    stores?: storesUncheckedUpdateManyWithoutCompaniesNestedInput
    users?: usersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesCreateManyInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type companiesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type companiesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_frontend_settingsCreateInput = {
    id?: bigint | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
    companies: companiesCreateNestedOneWithoutCompany_frontend_settingsInput
  }

  export type company_frontend_settingsUncheckedCreateInput = {
    id?: bigint | number
    company_id: bigint | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_frontend_settingsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutCompany_frontend_settingsNestedInput
  }

  export type company_frontend_settingsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_frontend_settingsCreateManyInput = {
    id?: bigint | number
    company_id: bigint | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_frontend_settingsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_frontend_settingsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_integrationsCreateInput = {
    id?: bigint | number
    provider: string
    credentials: JsonNullValueInput | InputJsonValue
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    companies: companiesCreateNestedOneWithoutCompany_integrationsInput
  }

  export type company_integrationsUncheckedCreateInput = {
    id?: bigint | number
    company_id: bigint | number
    provider: string
    credentials: JsonNullValueInput | InputJsonValue
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_integrationsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    provider?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutCompany_integrationsNestedInput
  }

  export type company_integrationsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    provider?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_integrationsCreateManyInput = {
    id?: bigint | number
    company_id: bigint | number
    provider: string
    credentials: JsonNullValueInput | InputJsonValue
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_integrationsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    provider?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_integrationsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    provider?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_profilesCreateInput = {
    id?: bigint | number
    phone?: string | null
    address?: string | null
    country?: string | null
    zipcode?: string | null
    city?: string | null
    state?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    companies: companiesCreateNestedOneWithoutCompany_profilesInput
  }

  export type company_profilesUncheckedCreateInput = {
    id?: bigint | number
    company_id: bigint | number
    phone?: string | null
    address?: string | null
    country?: string | null
    zipcode?: string | null
    city?: string | null
    state?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_profilesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutCompany_profilesNestedInput
  }

  export type company_profilesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_profilesCreateManyInput = {
    id?: bigint | number
    company_id: bigint | number
    phone?: string | null
    address?: string | null
    country?: string | null
    zipcode?: string | null
    city?: string | null
    state?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_profilesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_profilesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_subscriptionsCreateInput = {
    id?: bigint | number
    start_date: Date | string
    end_date: Date | string
    status: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    companies: companiesCreateNestedOneWithoutCompany_subscriptionsInput
    subscriptions: subscriptionsCreateNestedOneWithoutCompany_subscriptionsInput
    payments?: paymentsCreateNestedManyWithoutCompany_subscriptionsInput
  }

  export type company_subscriptionsUncheckedCreateInput = {
    id?: bigint | number
    company_id: bigint | number
    subscription_id: bigint | number
    start_date: Date | string
    end_date: Date | string
    status: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    payments?: paymentsUncheckedCreateNestedManyWithoutCompany_subscriptionsInput
  }

  export type company_subscriptionsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutCompany_subscriptionsNestedInput
    subscriptions?: subscriptionsUpdateOneRequiredWithoutCompany_subscriptionsNestedInput
    payments?: paymentsUpdateManyWithoutCompany_subscriptionsNestedInput
  }

  export type company_subscriptionsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subscription_id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payments?: paymentsUncheckedUpdateManyWithoutCompany_subscriptionsNestedInput
  }

  export type company_subscriptionsCreateManyInput = {
    id?: bigint | number
    company_id: bigint | number
    subscription_id: bigint | number
    start_date: Date | string
    end_date: Date | string
    status: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_subscriptionsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_subscriptionsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subscription_id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type integration_category_mappingsCreateInput = {
    id?: bigint | number
    provider: string
    external_category: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesCreateNestedOneWithoutIntegration_category_mappingsInput
    companies?: companiesCreateNestedOneWithoutIntegration_category_mappingsInput
  }

  export type integration_category_mappingsUncheckedCreateInput = {
    id?: bigint | number
    company_id?: bigint | number | null
    provider: string
    external_category: string
    category_id?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type integration_category_mappingsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    provider?: StringFieldUpdateOperationsInput | string
    external_category?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateOneWithoutIntegration_category_mappingsNestedInput
    companies?: companiesUpdateOneWithoutIntegration_category_mappingsNestedInput
  }

  export type integration_category_mappingsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    provider?: StringFieldUpdateOperationsInput | string
    external_category?: StringFieldUpdateOperationsInput | string
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type integration_category_mappingsCreateManyInput = {
    id?: bigint | number
    company_id?: bigint | number | null
    provider: string
    external_category: string
    category_id?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type integration_category_mappingsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    provider?: StringFieldUpdateOperationsInput | string
    external_category?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type integration_category_mappingsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    provider?: StringFieldUpdateOperationsInput | string
    external_category?: StringFieldUpdateOperationsInput | string
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type menusCreateInput = {
    id?: bigint | number
    title: string
    href?: string | null
    icon?: string | null
    role?: string | null
    permission?: string | null
    order?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    menus?: menusCreateNestedOneWithoutOther_menusInput
    other_menus?: menusCreateNestedManyWithoutMenusInput
  }

  export type menusUncheckedCreateInput = {
    id?: bigint | number
    title: string
    href?: string | null
    icon?: string | null
    role?: string | null
    permission?: string | null
    parent_id?: bigint | number | null
    order?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    other_menus?: menusUncheckedCreateNestedManyWithoutMenusInput
  }

  export type menusUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    href?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    menus?: menusUpdateOneWithoutOther_menusNestedInput
    other_menus?: menusUpdateManyWithoutMenusNestedInput
  }

  export type menusUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    href?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    order?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_menus?: menusUncheckedUpdateManyWithoutMenusNestedInput
  }

  export type menusCreateManyInput = {
    id?: bigint | number
    title: string
    href?: string | null
    icon?: string | null
    role?: string | null
    permission?: string | null
    parent_id?: bigint | number | null
    order?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type menusUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    href?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type menusUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    href?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    order?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type offer_categoryCreateInput = {
    id?: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories: categoriesCreateNestedOneWithoutOffer_categoryInput
    offers: offersCreateNestedOneWithoutOffer_categoryInput
  }

  export type offer_categoryUncheckedCreateInput = {
    id?: bigint | number
    offer_id: bigint | number
    category_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type offer_categoryUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateOneRequiredWithoutOffer_categoryNestedInput
    offers?: offersUpdateOneRequiredWithoutOffer_categoryNestedInput
  }

  export type offer_categoryUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    offer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type offer_categoryCreateManyInput = {
    id?: bigint | number
    offer_id: bigint | number
    category_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type offer_categoryUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type offer_categoryUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    offer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type offersCreateInput = {
    id?: bigint | number
    title: string
    description?: string | null
    product_url?: string | null
    image_url?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    code?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    link?: string | null
    is_featured?: boolean
    is_exclusive?: boolean
    is_deal?: boolean
    path?: string | null
    thumbnail?: string | null
    sku?: string | null
    product_name?: string | null
    product_price?: Decimal | DecimalJsLike | number | string | null
    old_price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    type?: $Enums.offers_type
    external_id?: string | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    offer_category?: offer_categoryCreateNestedManyWithoutOffersInput
    categories?: categoriesCreateNestedOneWithoutOffersInput
    companies: companiesCreateNestedOneWithoutOffersInput
    stores: storesCreateNestedOneWithoutOffersInput
  }

  export type offersUncheckedCreateInput = {
    id?: bigint | number
    company_id: bigint | number
    store_id: bigint | number
    category_id?: bigint | number | null
    title: string
    description?: string | null
    product_url?: string | null
    image_url?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    code?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    link?: string | null
    is_featured?: boolean
    is_exclusive?: boolean
    is_deal?: boolean
    path?: string | null
    thumbnail?: string | null
    sku?: string | null
    product_name?: string | null
    product_price?: Decimal | DecimalJsLike | number | string | null
    old_price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    type?: $Enums.offers_type
    external_id?: string | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    offer_category?: offer_categoryUncheckedCreateNestedManyWithoutOffersInput
  }

  export type offersUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    product_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_exclusive?: BoolFieldUpdateOperationsInput | boolean
    is_deal?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    product_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    old_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: Enumoffers_typeFieldUpdateOperationsInput | $Enums.offers_type
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offer_category?: offer_categoryUpdateManyWithoutOffersNestedInput
    categories?: categoriesUpdateOneWithoutOffersNestedInput
    companies?: companiesUpdateOneRequiredWithoutOffersNestedInput
    stores?: storesUpdateOneRequiredWithoutOffersNestedInput
  }

  export type offersUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    store_id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    product_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_exclusive?: BoolFieldUpdateOperationsInput | boolean
    is_deal?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    product_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    old_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: Enumoffers_typeFieldUpdateOperationsInput | $Enums.offers_type
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offer_category?: offer_categoryUncheckedUpdateManyWithoutOffersNestedInput
  }

  export type offersCreateManyInput = {
    id?: bigint | number
    company_id: bigint | number
    store_id: bigint | number
    category_id?: bigint | number | null
    title: string
    description?: string | null
    product_url?: string | null
    image_url?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    code?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    link?: string | null
    is_featured?: boolean
    is_exclusive?: boolean
    is_deal?: boolean
    path?: string | null
    thumbnail?: string | null
    sku?: string | null
    product_name?: string | null
    product_price?: Decimal | DecimalJsLike | number | string | null
    old_price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    type?: $Enums.offers_type
    external_id?: string | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type offersUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    product_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_exclusive?: BoolFieldUpdateOperationsInput | boolean
    is_deal?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    product_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    old_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: Enumoffers_typeFieldUpdateOperationsInput | $Enums.offers_type
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type offersUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    store_id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    product_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_exclusive?: BoolFieldUpdateOperationsInput | boolean
    is_deal?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    product_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    old_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: Enumoffers_typeFieldUpdateOperationsInput | $Enums.offers_type
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsCreateInput = {
    id?: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    payment_status: string
    transaction_id?: string | null
    paid_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    company_subscriptions: company_subscriptionsCreateNestedOneWithoutPaymentsInput
  }

  export type paymentsUncheckedCreateInput = {
    id?: bigint | number
    company_subscription_id: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    payment_status: string
    transaction_id?: string | null
    paid_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type paymentsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    payment_status?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_subscriptions?: company_subscriptionsUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type paymentsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_subscription_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    payment_status?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsCreateManyInput = {
    id?: bigint | number
    company_subscription_id: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    payment_status: string
    transaction_id?: string | null
    paid_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type paymentsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    payment_status?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_subscription_id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    payment_status?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type storesCreateInput = {
    id?: bigint | number
    name: string
    image?: string | null
    description?: string | null
    status?: number
    channelId?: bigint | number | null
    channelName?: string | null
    programId?: bigint | number | null
    categoryName?: string | null
    categoryId?: bigint | number | null
    productFeedId?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    offers?: offersCreateNestedManyWithoutStoresInput
    companies: companiesCreateNestedOneWithoutStoresInput
  }

  export type storesUncheckedCreateInput = {
    id?: bigint | number
    company_id: bigint | number
    name: string
    image?: string | null
    description?: string | null
    status?: number
    channelId?: bigint | number | null
    channelName?: string | null
    programId?: bigint | number | null
    categoryName?: string | null
    categoryId?: bigint | number | null
    productFeedId?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    offers?: offersUncheckedCreateNestedManyWithoutStoresInput
  }

  export type storesUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    channelId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    productFeedId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offers?: offersUpdateManyWithoutStoresNestedInput
    companies?: companiesUpdateOneRequiredWithoutStoresNestedInput
  }

  export type storesUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    channelId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    productFeedId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offers?: offersUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type storesCreateManyInput = {
    id?: bigint | number
    company_id: bigint | number
    name: string
    image?: string | null
    description?: string | null
    status?: number
    channelId?: bigint | number | null
    channelName?: string | null
    programId?: bigint | number | null
    categoryName?: string | null
    categoryId?: bigint | number | null
    productFeedId?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type storesUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    channelId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    productFeedId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type storesUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    channelId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    productFeedId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subscriptionsCreateInput = {
    id?: bigint | number
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration: number
    features?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    company_subscriptions?: company_subscriptionsCreateNestedManyWithoutSubscriptionsInput
  }

  export type subscriptionsUncheckedCreateInput = {
    id?: bigint | number
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration: number
    features?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    company_subscriptions?: company_subscriptionsUncheckedCreateNestedManyWithoutSubscriptionsInput
  }

  export type subscriptionsUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_subscriptions?: company_subscriptionsUpdateManyWithoutSubscriptionsNestedInput
  }

  export type subscriptionsUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_subscriptions?: company_subscriptionsUncheckedUpdateManyWithoutSubscriptionsNestedInput
  }

  export type subscriptionsCreateManyInput = {
    id?: bigint | number
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration: number
    features?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type subscriptionsUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subscriptionsUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type failed_jobsOrderByRelevanceInput = {
    fields: failed_jobsOrderByRelevanceFieldEnum | failed_jobsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type failed_jobsCountOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    connection?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    exception?: SortOrder
    failed_at?: SortOrder
  }

  export type failed_jobsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type failed_jobsMaxOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    connection?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    exception?: SortOrder
    failed_at?: SortOrder
  }

  export type failed_jobsMinOrderByAggregateInput = {
    id?: SortOrder
    uuid?: SortOrder
    connection?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    exception?: SortOrder
    failed_at?: SortOrder
  }

  export type failed_jobsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type jobsOrderByRelevanceInput = {
    fields: jobsOrderByRelevanceFieldEnum | jobsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type jobsCountOrderByAggregateInput = {
    id?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    attempts?: SortOrder
    reserved_at?: SortOrder
    available_at?: SortOrder
    created_at?: SortOrder
  }

  export type jobsAvgOrderByAggregateInput = {
    id?: SortOrder
    attempts?: SortOrder
    reserved_at?: SortOrder
    available_at?: SortOrder
    created_at?: SortOrder
  }

  export type jobsMaxOrderByAggregateInput = {
    id?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    attempts?: SortOrder
    reserved_at?: SortOrder
    available_at?: SortOrder
    created_at?: SortOrder
  }

  export type jobsMinOrderByAggregateInput = {
    id?: SortOrder
    queue?: SortOrder
    payload?: SortOrder
    attempts?: SortOrder
    reserved_at?: SortOrder
    available_at?: SortOrder
    created_at?: SortOrder
  }

  export type jobsSumOrderByAggregateInput = {
    id?: SortOrder
    attempts?: SortOrder
    reserved_at?: SortOrder
    available_at?: SortOrder
    created_at?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type migrationsOrderByRelevanceInput = {
    fields: migrationsOrderByRelevanceFieldEnum | migrationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type migrationsCountOrderByAggregateInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type migrationsAvgOrderByAggregateInput = {
    id?: SortOrder
    batch?: SortOrder
  }

  export type migrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type migrationsMinOrderByAggregateInput = {
    id?: SortOrder
    migration?: SortOrder
    batch?: SortOrder
  }

  export type migrationsSumOrderByAggregateInput = {
    id?: SortOrder
    batch?: SortOrder
  }

  export type PermissionsScalarRelationFilter = {
    is?: permissionsWhereInput
    isNot?: permissionsWhereInput
  }

  export type model_has_permissionsOrderByRelevanceInput = {
    fields: model_has_permissionsOrderByRelevanceFieldEnum | model_has_permissionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type model_has_permissionsPermission_idModel_idModel_typeCompoundUniqueInput = {
    permission_id: bigint | number
    model_id: bigint | number
    model_type: string
  }

  export type model_has_permissionsCountOrderByAggregateInput = {
    permission_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
  }

  export type model_has_permissionsAvgOrderByAggregateInput = {
    permission_id?: SortOrder
    model_id?: SortOrder
  }

  export type model_has_permissionsMaxOrderByAggregateInput = {
    permission_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
  }

  export type model_has_permissionsMinOrderByAggregateInput = {
    permission_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
  }

  export type model_has_permissionsSumOrderByAggregateInput = {
    permission_id?: SortOrder
    model_id?: SortOrder
  }

  export type RolesScalarRelationFilter = {
    is?: rolesWhereInput
    isNot?: rolesWhereInput
  }

  export type model_has_rolesOrderByRelevanceInput = {
    fields: model_has_rolesOrderByRelevanceFieldEnum | model_has_rolesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type model_has_rolesRole_idModel_idModel_typeCompoundUniqueInput = {
    role_id: bigint | number
    model_id: bigint | number
    model_type: string
  }

  export type model_has_rolesCountOrderByAggregateInput = {
    role_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
  }

  export type model_has_rolesAvgOrderByAggregateInput = {
    role_id?: SortOrder
    model_id?: SortOrder
  }

  export type model_has_rolesMaxOrderByAggregateInput = {
    role_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
  }

  export type model_has_rolesMinOrderByAggregateInput = {
    role_id?: SortOrder
    model_type?: SortOrder
    model_id?: SortOrder
  }

  export type model_has_rolesSumOrderByAggregateInput = {
    role_id?: SortOrder
    model_id?: SortOrder
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type password_reset_tokensOrderByRelevanceInput = {
    fields: password_reset_tokensOrderByRelevanceFieldEnum | password_reset_tokensOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type password_reset_tokensCountOrderByAggregateInput = {
    email?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
  }

  export type password_reset_tokensMaxOrderByAggregateInput = {
    email?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
  }

  export type password_reset_tokensMinOrderByAggregateInput = {
    email?: SortOrder
    token?: SortOrder
    created_at?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type Model_has_permissionsListRelationFilter = {
    every?: model_has_permissionsWhereInput
    some?: model_has_permissionsWhereInput
    none?: model_has_permissionsWhereInput
  }

  export type Role_has_permissionsListRelationFilter = {
    every?: role_has_permissionsWhereInput
    some?: role_has_permissionsWhereInput
    none?: role_has_permissionsWhereInput
  }

  export type model_has_permissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type role_has_permissionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type permissionsOrderByRelevanceInput = {
    fields: permissionsOrderByRelevanceFieldEnum | permissionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type permissionsNameGuard_nameCompoundUniqueInput = {
    name: string
    guard_name: string
  }

  export type permissionsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type permissionsAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type permissionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type permissionsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type permissionsSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type role_has_permissionsPermission_idRole_idCompoundUniqueInput = {
    permission_id: bigint | number
    role_id: bigint | number
  }

  export type role_has_permissionsCountOrderByAggregateInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
  }

  export type role_has_permissionsAvgOrderByAggregateInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
  }

  export type role_has_permissionsMaxOrderByAggregateInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
  }

  export type role_has_permissionsMinOrderByAggregateInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
  }

  export type role_has_permissionsSumOrderByAggregateInput = {
    permission_id?: SortOrder
    role_id?: SortOrder
  }

  export type Model_has_rolesListRelationFilter = {
    every?: model_has_rolesWhereInput
    some?: model_has_rolesWhereInput
    none?: model_has_rolesWhereInput
  }

  export type model_has_rolesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type rolesOrderByRelevanceInput = {
    fields: rolesOrderByRelevanceFieldEnum | rolesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type rolesNameGuard_nameCompoundUniqueInput = {
    name: string
    guard_name: string
  }

  export type rolesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type rolesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type rolesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type rolesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    guard_name?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type rolesSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type CompaniesNullableScalarRelationFilter = {
    is?: companiesWhereInput | null
    isNot?: companiesWhereInput | null
  }

  export type usersOrderByRelevanceInput = {
    fields: usersOrderByRelevanceFieldEnum | usersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrder
    password?: SortOrder
    company_id?: SortOrder
    remember_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrder
    password?: SortOrder
    company_id?: SortOrder
    remember_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    email_verified_at?: SortOrder
    password?: SortOrder
    company_id?: SortOrder
    remember_token?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type usersSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type cacheOrderByRelevanceInput = {
    fields: cacheOrderByRelevanceFieldEnum | cacheOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type cacheCountOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    expiration?: SortOrder
  }

  export type cacheAvgOrderByAggregateInput = {
    expiration?: SortOrder
  }

  export type cacheMaxOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    expiration?: SortOrder
  }

  export type cacheMinOrderByAggregateInput = {
    key?: SortOrder
    value?: SortOrder
    expiration?: SortOrder
  }

  export type cacheSumOrderByAggregateInput = {
    expiration?: SortOrder
  }

  export type cache_locksOrderByRelevanceInput = {
    fields: cache_locksOrderByRelevanceFieldEnum | cache_locksOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type cache_locksCountOrderByAggregateInput = {
    key?: SortOrder
    owner?: SortOrder
    expiration?: SortOrder
  }

  export type cache_locksAvgOrderByAggregateInput = {
    expiration?: SortOrder
  }

  export type cache_locksMaxOrderByAggregateInput = {
    key?: SortOrder
    owner?: SortOrder
    expiration?: SortOrder
  }

  export type cache_locksMinOrderByAggregateInput = {
    key?: SortOrder
    owner?: SortOrder
    expiration?: SortOrder
  }

  export type cache_locksSumOrderByAggregateInput = {
    expiration?: SortOrder
  }

  export type job_batchesOrderByRelevanceInput = {
    fields: job_batchesOrderByRelevanceFieldEnum | job_batchesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type job_batchesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    total_jobs?: SortOrder
    pending_jobs?: SortOrder
    failed_jobs?: SortOrder
    failed_job_ids?: SortOrder
    options?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    finished_at?: SortOrder
  }

  export type job_batchesAvgOrderByAggregateInput = {
    total_jobs?: SortOrder
    pending_jobs?: SortOrder
    failed_jobs?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    finished_at?: SortOrder
  }

  export type job_batchesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    total_jobs?: SortOrder
    pending_jobs?: SortOrder
    failed_jobs?: SortOrder
    failed_job_ids?: SortOrder
    options?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    finished_at?: SortOrder
  }

  export type job_batchesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    total_jobs?: SortOrder
    pending_jobs?: SortOrder
    failed_jobs?: SortOrder
    failed_job_ids?: SortOrder
    options?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    finished_at?: SortOrder
  }

  export type job_batchesSumOrderByAggregateInput = {
    total_jobs?: SortOrder
    pending_jobs?: SortOrder
    failed_jobs?: SortOrder
    cancelled_at?: SortOrder
    created_at?: SortOrder
    finished_at?: SortOrder
  }

  export type sessionsOrderByRelevanceInput = {
    fields: sessionsOrderByRelevanceFieldEnum | sessionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type sessionsCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    payload?: SortOrder
    last_activity?: SortOrder
  }

  export type sessionsAvgOrderByAggregateInput = {
    user_id?: SortOrder
    last_activity?: SortOrder
  }

  export type sessionsMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    payload?: SortOrder
    last_activity?: SortOrder
  }

  export type sessionsMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    ip_address?: SortOrder
    user_agent?: SortOrder
    payload?: SortOrder
    last_activity?: SortOrder
  }

  export type sessionsSumOrderByAggregateInput = {
    user_id?: SortOrder
    last_activity?: SortOrder
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type CompaniesScalarRelationFilter = {
    is?: companiesWhereInput
    isNot?: companiesWhereInput
  }

  export type CategoriesNullableScalarRelationFilter = {
    is?: categoriesWhereInput | null
    isNot?: categoriesWhereInput | null
  }

  export type CategoriesListRelationFilter = {
    every?: categoriesWhereInput
    some?: categoriesWhereInput
    none?: categoriesWhereInput
  }

  export type Integration_category_mappingsListRelationFilter = {
    every?: integration_category_mappingsWhereInput
    some?: integration_category_mappingsWhereInput
    none?: integration_category_mappingsWhereInput
  }

  export type Offer_categoryListRelationFilter = {
    every?: offer_categoryWhereInput
    some?: offer_categoryWhereInput
    none?: offer_categoryWhereInput
  }

  export type OffersListRelationFilter = {
    every?: offersWhereInput
    some?: offersWhereInput
    none?: offersWhereInput
  }

  export type categoriesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type integration_category_mappingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type offer_categoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type offersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type categoriesOrderByRelevanceInput = {
    fields: categoriesOrderByRelevanceFieldEnum | categoriesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parent_id?: SortOrder
    company_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type categoriesAvgOrderByAggregateInput = {
    id?: SortOrder
    parent_id?: SortOrder
    company_id?: SortOrder
  }

  export type categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parent_id?: SortOrder
    company_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    parent_id?: SortOrder
    company_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type categoriesSumOrderByAggregateInput = {
    id?: SortOrder
    parent_id?: SortOrder
    company_id?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type Company_frontend_settingsListRelationFilter = {
    every?: company_frontend_settingsWhereInput
    some?: company_frontend_settingsWhereInput
    none?: company_frontend_settingsWhereInput
  }

  export type Company_integrationsListRelationFilter = {
    every?: company_integrationsWhereInput
    some?: company_integrationsWhereInput
    none?: company_integrationsWhereInput
  }

  export type Company_profilesListRelationFilter = {
    every?: company_profilesWhereInput
    some?: company_profilesWhereInput
    none?: company_profilesWhereInput
  }

  export type Company_subscriptionsListRelationFilter = {
    every?: company_subscriptionsWhereInput
    some?: company_subscriptionsWhereInput
    none?: company_subscriptionsWhereInput
  }

  export type StoresListRelationFilter = {
    every?: storesWhereInput
    some?: storesWhereInput
    none?: storesWhereInput
  }

  export type UsersListRelationFilter = {
    every?: usersWhereInput
    some?: usersWhereInput
    none?: usersWhereInput
  }

  export type company_frontend_settingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type company_integrationsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type company_profilesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type company_subscriptionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type storesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type usersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type companiesOrderByRelevanceInput = {
    fields: companiesOrderByRelevanceFieldEnum | companiesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type companiesCountOrderByAggregateInput = {
    id?: SortOrder
    registration_no?: SortOrder
    vat?: SortOrder
    name?: SortOrder
    email?: SortOrder
    domain?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companiesAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type companiesMaxOrderByAggregateInput = {
    id?: SortOrder
    registration_no?: SortOrder
    vat?: SortOrder
    name?: SortOrder
    email?: SortOrder
    domain?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companiesMinOrderByAggregateInput = {
    id?: SortOrder
    registration_no?: SortOrder
    vat?: SortOrder
    name?: SortOrder
    email?: SortOrder
    domain?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type companiesSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type company_frontend_settingsCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    settings?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_frontend_settingsAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type company_frontend_settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_frontend_settingsMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_frontend_settingsSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type company_integrationsOrderByRelevanceInput = {
    fields: company_integrationsOrderByRelevanceFieldEnum | company_integrationsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type company_integrationsCompany_idProviderCompoundUniqueInput = {
    company_id: bigint | number
    provider: string
  }

  export type company_integrationsCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    provider?: SortOrder
    credentials?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_integrationsAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type company_integrationsMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_integrationsMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    provider?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_integrationsSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type company_profilesOrderByRelevanceInput = {
    fields: company_profilesOrderByRelevanceFieldEnum | company_profilesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type company_profilesCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    country?: SortOrder
    zipcode?: SortOrder
    city?: SortOrder
    state?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_profilesAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type company_profilesMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    country?: SortOrder
    zipcode?: SortOrder
    city?: SortOrder
    state?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_profilesMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    country?: SortOrder
    zipcode?: SortOrder
    city?: SortOrder
    state?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_profilesSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
  }

  export type SubscriptionsScalarRelationFilter = {
    is?: subscriptionsWhereInput
    isNot?: subscriptionsWhereInput
  }

  export type PaymentsListRelationFilter = {
    every?: paymentsWhereInput
    some?: paymentsWhereInput
    none?: paymentsWhereInput
  }

  export type paymentsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type company_subscriptionsOrderByRelevanceInput = {
    fields: company_subscriptionsOrderByRelevanceFieldEnum | company_subscriptionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type company_subscriptionsCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    subscription_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_subscriptionsAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    subscription_id?: SortOrder
  }

  export type company_subscriptionsMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    subscription_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_subscriptionsMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    subscription_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type company_subscriptionsSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    subscription_id?: SortOrder
  }

  export type integration_category_mappingsOrderByRelevanceInput = {
    fields: integration_category_mappingsOrderByRelevanceFieldEnum | integration_category_mappingsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type integration_category_mappingsCompany_idProviderExternal_categoryCompoundUniqueInput = {
    company_id: bigint | number
    provider: string
    external_category: string
  }

  export type integration_category_mappingsCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    provider?: SortOrder
    external_category?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type integration_category_mappingsAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    category_id?: SortOrder
  }

  export type integration_category_mappingsMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    provider?: SortOrder
    external_category?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type integration_category_mappingsMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    provider?: SortOrder
    external_category?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type integration_category_mappingsSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    category_id?: SortOrder
  }

  export type MenusNullableScalarRelationFilter = {
    is?: menusWhereInput | null
    isNot?: menusWhereInput | null
  }

  export type MenusListRelationFilter = {
    every?: menusWhereInput
    some?: menusWhereInput
    none?: menusWhereInput
  }

  export type menusOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type menusOrderByRelevanceInput = {
    fields: menusOrderByRelevanceFieldEnum | menusOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type menusCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    href?: SortOrder
    icon?: SortOrder
    role?: SortOrder
    permission?: SortOrder
    parent_id?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type menusAvgOrderByAggregateInput = {
    id?: SortOrder
    parent_id?: SortOrder
    order?: SortOrder
  }

  export type menusMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    href?: SortOrder
    icon?: SortOrder
    role?: SortOrder
    permission?: SortOrder
    parent_id?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type menusMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    href?: SortOrder
    icon?: SortOrder
    role?: SortOrder
    permission?: SortOrder
    parent_id?: SortOrder
    order?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type menusSumOrderByAggregateInput = {
    id?: SortOrder
    parent_id?: SortOrder
    order?: SortOrder
  }

  export type CategoriesScalarRelationFilter = {
    is?: categoriesWhereInput
    isNot?: categoriesWhereInput
  }

  export type OffersScalarRelationFilter = {
    is?: offersWhereInput
    isNot?: offersWhereInput
  }

  export type offer_categoryOffer_idCategory_idCompoundUniqueInput = {
    offer_id: bigint | number
    category_id: bigint | number
  }

  export type offer_categoryCountOrderByAggregateInput = {
    id?: SortOrder
    offer_id?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type offer_categoryAvgOrderByAggregateInput = {
    id?: SortOrder
    offer_id?: SortOrder
    category_id?: SortOrder
  }

  export type offer_categoryMaxOrderByAggregateInput = {
    id?: SortOrder
    offer_id?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type offer_categoryMinOrderByAggregateInput = {
    id?: SortOrder
    offer_id?: SortOrder
    category_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type offer_categorySumOrderByAggregateInput = {
    id?: SortOrder
    offer_id?: SortOrder
    category_id?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type Enumoffers_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.offers_type | Enumoffers_typeFieldRefInput<$PrismaModel>
    in?: $Enums.offers_type[]
    notIn?: $Enums.offers_type[]
    not?: NestedEnumoffers_typeFilter<$PrismaModel> | $Enums.offers_type
  }

  export type StoresScalarRelationFilter = {
    is?: storesWhereInput
    isNot?: storesWhereInput
  }

  export type offersOrderByRelevanceInput = {
    fields: offersOrderByRelevanceFieldEnum | offersOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type offersCompany_idExternal_idSourceCompoundUniqueInput = {
    company_id: bigint | number
    external_id: string
    source: string
  }

  export type offersCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    store_id?: SortOrder
    category_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    product_url?: SortOrder
    image_url?: SortOrder
    price?: SortOrder
    code?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    link?: SortOrder
    is_featured?: SortOrder
    is_exclusive?: SortOrder
    is_deal?: SortOrder
    path?: SortOrder
    thumbnail?: SortOrder
    sku?: SortOrder
    product_name?: SortOrder
    product_price?: SortOrder
    old_price?: SortOrder
    source?: SortOrder
    type?: SortOrder
    external_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type offersAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    store_id?: SortOrder
    category_id?: SortOrder
    price?: SortOrder
    product_price?: SortOrder
    old_price?: SortOrder
  }

  export type offersMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    store_id?: SortOrder
    category_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    product_url?: SortOrder
    image_url?: SortOrder
    price?: SortOrder
    code?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    link?: SortOrder
    is_featured?: SortOrder
    is_exclusive?: SortOrder
    is_deal?: SortOrder
    path?: SortOrder
    thumbnail?: SortOrder
    sku?: SortOrder
    product_name?: SortOrder
    product_price?: SortOrder
    old_price?: SortOrder
    source?: SortOrder
    type?: SortOrder
    external_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type offersMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    store_id?: SortOrder
    category_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    product_url?: SortOrder
    image_url?: SortOrder
    price?: SortOrder
    code?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    link?: SortOrder
    is_featured?: SortOrder
    is_exclusive?: SortOrder
    is_deal?: SortOrder
    path?: SortOrder
    thumbnail?: SortOrder
    sku?: SortOrder
    product_name?: SortOrder
    product_price?: SortOrder
    old_price?: SortOrder
    source?: SortOrder
    type?: SortOrder
    external_id?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type offersSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    store_id?: SortOrder
    category_id?: SortOrder
    price?: SortOrder
    product_price?: SortOrder
    old_price?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type Enumoffers_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.offers_type | Enumoffers_typeFieldRefInput<$PrismaModel>
    in?: $Enums.offers_type[]
    notIn?: $Enums.offers_type[]
    not?: NestedEnumoffers_typeWithAggregatesFilter<$PrismaModel> | $Enums.offers_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumoffers_typeFilter<$PrismaModel>
    _max?: NestedEnumoffers_typeFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type Company_subscriptionsScalarRelationFilter = {
    is?: company_subscriptionsWhereInput
    isNot?: company_subscriptionsWhereInput
  }

  export type paymentsOrderByRelevanceInput = {
    fields: paymentsOrderByRelevanceFieldEnum | paymentsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type paymentsCountOrderByAggregateInput = {
    id?: SortOrder
    company_subscription_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    payment_status?: SortOrder
    transaction_id?: SortOrder
    paid_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type paymentsAvgOrderByAggregateInput = {
    id?: SortOrder
    company_subscription_id?: SortOrder
    amount?: SortOrder
  }

  export type paymentsMaxOrderByAggregateInput = {
    id?: SortOrder
    company_subscription_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    payment_status?: SortOrder
    transaction_id?: SortOrder
    paid_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type paymentsMinOrderByAggregateInput = {
    id?: SortOrder
    company_subscription_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    payment_status?: SortOrder
    transaction_id?: SortOrder
    paid_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type paymentsSumOrderByAggregateInput = {
    id?: SortOrder
    company_subscription_id?: SortOrder
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type storesOrderByRelevanceInput = {
    fields: storesOrderByRelevanceFieldEnum | storesOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type storesCountOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    status?: SortOrder
    channelId?: SortOrder
    channelName?: SortOrder
    programId?: SortOrder
    categoryName?: SortOrder
    categoryId?: SortOrder
    productFeedId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type storesAvgOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    status?: SortOrder
    channelId?: SortOrder
    programId?: SortOrder
    categoryId?: SortOrder
    productFeedId?: SortOrder
  }

  export type storesMaxOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    status?: SortOrder
    channelId?: SortOrder
    channelName?: SortOrder
    programId?: SortOrder
    categoryName?: SortOrder
    categoryId?: SortOrder
    productFeedId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type storesMinOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    name?: SortOrder
    image?: SortOrder
    description?: SortOrder
    status?: SortOrder
    channelId?: SortOrder
    channelName?: SortOrder
    programId?: SortOrder
    categoryName?: SortOrder
    categoryId?: SortOrder
    productFeedId?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type storesSumOrderByAggregateInput = {
    id?: SortOrder
    company_id?: SortOrder
    status?: SortOrder
    channelId?: SortOrder
    programId?: SortOrder
    categoryId?: SortOrder
    productFeedId?: SortOrder
  }

  export type subscriptionsOrderByRelevanceInput = {
    fields: subscriptionsOrderByRelevanceFieldEnum | subscriptionsOrderByRelevanceFieldEnum[]
    sort: SortOrder
    search: string
  }

  export type subscriptionsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    features?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type subscriptionsAvgOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    duration?: SortOrder
  }

  export type subscriptionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type subscriptionsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    price?: SortOrder
    duration?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type subscriptionsSumOrderByAggregateInput = {
    id?: SortOrder
    price?: SortOrder
    duration?: SortOrder
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type permissionsCreateNestedOneWithoutModel_has_permissionsInput = {
    create?: XOR<permissionsCreateWithoutModel_has_permissionsInput, permissionsUncheckedCreateWithoutModel_has_permissionsInput>
    connectOrCreate?: permissionsCreateOrConnectWithoutModel_has_permissionsInput
    connect?: permissionsWhereUniqueInput
  }

  export type permissionsUpdateOneRequiredWithoutModel_has_permissionsNestedInput = {
    create?: XOR<permissionsCreateWithoutModel_has_permissionsInput, permissionsUncheckedCreateWithoutModel_has_permissionsInput>
    connectOrCreate?: permissionsCreateOrConnectWithoutModel_has_permissionsInput
    upsert?: permissionsUpsertWithoutModel_has_permissionsInput
    connect?: permissionsWhereUniqueInput
    update?: XOR<XOR<permissionsUpdateToOneWithWhereWithoutModel_has_permissionsInput, permissionsUpdateWithoutModel_has_permissionsInput>, permissionsUncheckedUpdateWithoutModel_has_permissionsInput>
  }

  export type rolesCreateNestedOneWithoutModel_has_rolesInput = {
    create?: XOR<rolesCreateWithoutModel_has_rolesInput, rolesUncheckedCreateWithoutModel_has_rolesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutModel_has_rolesInput
    connect?: rolesWhereUniqueInput
  }

  export type rolesUpdateOneRequiredWithoutModel_has_rolesNestedInput = {
    create?: XOR<rolesCreateWithoutModel_has_rolesInput, rolesUncheckedCreateWithoutModel_has_rolesInput>
    connectOrCreate?: rolesCreateOrConnectWithoutModel_has_rolesInput
    upsert?: rolesUpsertWithoutModel_has_rolesInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutModel_has_rolesInput, rolesUpdateWithoutModel_has_rolesInput>, rolesUncheckedUpdateWithoutModel_has_rolesInput>
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type model_has_permissionsCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<model_has_permissionsCreateWithoutPermissionsInput, model_has_permissionsUncheckedCreateWithoutPermissionsInput> | model_has_permissionsCreateWithoutPermissionsInput[] | model_has_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: model_has_permissionsCreateOrConnectWithoutPermissionsInput | model_has_permissionsCreateOrConnectWithoutPermissionsInput[]
    createMany?: model_has_permissionsCreateManyPermissionsInputEnvelope
    connect?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
  }

  export type role_has_permissionsCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<role_has_permissionsCreateWithoutPermissionsInput, role_has_permissionsUncheckedCreateWithoutPermissionsInput> | role_has_permissionsCreateWithoutPermissionsInput[] | role_has_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: role_has_permissionsCreateOrConnectWithoutPermissionsInput | role_has_permissionsCreateOrConnectWithoutPermissionsInput[]
    createMany?: role_has_permissionsCreateManyPermissionsInputEnvelope
    connect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
  }

  export type model_has_permissionsUncheckedCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<model_has_permissionsCreateWithoutPermissionsInput, model_has_permissionsUncheckedCreateWithoutPermissionsInput> | model_has_permissionsCreateWithoutPermissionsInput[] | model_has_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: model_has_permissionsCreateOrConnectWithoutPermissionsInput | model_has_permissionsCreateOrConnectWithoutPermissionsInput[]
    createMany?: model_has_permissionsCreateManyPermissionsInputEnvelope
    connect?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
  }

  export type role_has_permissionsUncheckedCreateNestedManyWithoutPermissionsInput = {
    create?: XOR<role_has_permissionsCreateWithoutPermissionsInput, role_has_permissionsUncheckedCreateWithoutPermissionsInput> | role_has_permissionsCreateWithoutPermissionsInput[] | role_has_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: role_has_permissionsCreateOrConnectWithoutPermissionsInput | role_has_permissionsCreateOrConnectWithoutPermissionsInput[]
    createMany?: role_has_permissionsCreateManyPermissionsInputEnvelope
    connect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
  }

  export type model_has_permissionsUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<model_has_permissionsCreateWithoutPermissionsInput, model_has_permissionsUncheckedCreateWithoutPermissionsInput> | model_has_permissionsCreateWithoutPermissionsInput[] | model_has_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: model_has_permissionsCreateOrConnectWithoutPermissionsInput | model_has_permissionsCreateOrConnectWithoutPermissionsInput[]
    upsert?: model_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput | model_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput[]
    createMany?: model_has_permissionsCreateManyPermissionsInputEnvelope
    set?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
    disconnect?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
    delete?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
    connect?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
    update?: model_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput | model_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: model_has_permissionsUpdateManyWithWhereWithoutPermissionsInput | model_has_permissionsUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: model_has_permissionsScalarWhereInput | model_has_permissionsScalarWhereInput[]
  }

  export type role_has_permissionsUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<role_has_permissionsCreateWithoutPermissionsInput, role_has_permissionsUncheckedCreateWithoutPermissionsInput> | role_has_permissionsCreateWithoutPermissionsInput[] | role_has_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: role_has_permissionsCreateOrConnectWithoutPermissionsInput | role_has_permissionsCreateOrConnectWithoutPermissionsInput[]
    upsert?: role_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput | role_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput[]
    createMany?: role_has_permissionsCreateManyPermissionsInputEnvelope
    set?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    disconnect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    delete?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    connect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    update?: role_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput | role_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: role_has_permissionsUpdateManyWithWhereWithoutPermissionsInput | role_has_permissionsUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: role_has_permissionsScalarWhereInput | role_has_permissionsScalarWhereInput[]
  }

  export type model_has_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<model_has_permissionsCreateWithoutPermissionsInput, model_has_permissionsUncheckedCreateWithoutPermissionsInput> | model_has_permissionsCreateWithoutPermissionsInput[] | model_has_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: model_has_permissionsCreateOrConnectWithoutPermissionsInput | model_has_permissionsCreateOrConnectWithoutPermissionsInput[]
    upsert?: model_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput | model_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput[]
    createMany?: model_has_permissionsCreateManyPermissionsInputEnvelope
    set?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
    disconnect?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
    delete?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
    connect?: model_has_permissionsWhereUniqueInput | model_has_permissionsWhereUniqueInput[]
    update?: model_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput | model_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: model_has_permissionsUpdateManyWithWhereWithoutPermissionsInput | model_has_permissionsUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: model_has_permissionsScalarWhereInput | model_has_permissionsScalarWhereInput[]
  }

  export type role_has_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput = {
    create?: XOR<role_has_permissionsCreateWithoutPermissionsInput, role_has_permissionsUncheckedCreateWithoutPermissionsInput> | role_has_permissionsCreateWithoutPermissionsInput[] | role_has_permissionsUncheckedCreateWithoutPermissionsInput[]
    connectOrCreate?: role_has_permissionsCreateOrConnectWithoutPermissionsInput | role_has_permissionsCreateOrConnectWithoutPermissionsInput[]
    upsert?: role_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput | role_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput[]
    createMany?: role_has_permissionsCreateManyPermissionsInputEnvelope
    set?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    disconnect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    delete?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    connect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    update?: role_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput | role_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput[]
    updateMany?: role_has_permissionsUpdateManyWithWhereWithoutPermissionsInput | role_has_permissionsUpdateManyWithWhereWithoutPermissionsInput[]
    deleteMany?: role_has_permissionsScalarWhereInput | role_has_permissionsScalarWhereInput[]
  }

  export type permissionsCreateNestedOneWithoutRole_has_permissionsInput = {
    create?: XOR<permissionsCreateWithoutRole_has_permissionsInput, permissionsUncheckedCreateWithoutRole_has_permissionsInput>
    connectOrCreate?: permissionsCreateOrConnectWithoutRole_has_permissionsInput
    connect?: permissionsWhereUniqueInput
  }

  export type rolesCreateNestedOneWithoutRole_has_permissionsInput = {
    create?: XOR<rolesCreateWithoutRole_has_permissionsInput, rolesUncheckedCreateWithoutRole_has_permissionsInput>
    connectOrCreate?: rolesCreateOrConnectWithoutRole_has_permissionsInput
    connect?: rolesWhereUniqueInput
  }

  export type permissionsUpdateOneRequiredWithoutRole_has_permissionsNestedInput = {
    create?: XOR<permissionsCreateWithoutRole_has_permissionsInput, permissionsUncheckedCreateWithoutRole_has_permissionsInput>
    connectOrCreate?: permissionsCreateOrConnectWithoutRole_has_permissionsInput
    upsert?: permissionsUpsertWithoutRole_has_permissionsInput
    connect?: permissionsWhereUniqueInput
    update?: XOR<XOR<permissionsUpdateToOneWithWhereWithoutRole_has_permissionsInput, permissionsUpdateWithoutRole_has_permissionsInput>, permissionsUncheckedUpdateWithoutRole_has_permissionsInput>
  }

  export type rolesUpdateOneRequiredWithoutRole_has_permissionsNestedInput = {
    create?: XOR<rolesCreateWithoutRole_has_permissionsInput, rolesUncheckedCreateWithoutRole_has_permissionsInput>
    connectOrCreate?: rolesCreateOrConnectWithoutRole_has_permissionsInput
    upsert?: rolesUpsertWithoutRole_has_permissionsInput
    connect?: rolesWhereUniqueInput
    update?: XOR<XOR<rolesUpdateToOneWithWhereWithoutRole_has_permissionsInput, rolesUpdateWithoutRole_has_permissionsInput>, rolesUncheckedUpdateWithoutRole_has_permissionsInput>
  }

  export type model_has_rolesCreateNestedManyWithoutRolesInput = {
    create?: XOR<model_has_rolesCreateWithoutRolesInput, model_has_rolesUncheckedCreateWithoutRolesInput> | model_has_rolesCreateWithoutRolesInput[] | model_has_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: model_has_rolesCreateOrConnectWithoutRolesInput | model_has_rolesCreateOrConnectWithoutRolesInput[]
    createMany?: model_has_rolesCreateManyRolesInputEnvelope
    connect?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
  }

  export type role_has_permissionsCreateNestedManyWithoutRolesInput = {
    create?: XOR<role_has_permissionsCreateWithoutRolesInput, role_has_permissionsUncheckedCreateWithoutRolesInput> | role_has_permissionsCreateWithoutRolesInput[] | role_has_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_has_permissionsCreateOrConnectWithoutRolesInput | role_has_permissionsCreateOrConnectWithoutRolesInput[]
    createMany?: role_has_permissionsCreateManyRolesInputEnvelope
    connect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
  }

  export type model_has_rolesUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<model_has_rolesCreateWithoutRolesInput, model_has_rolesUncheckedCreateWithoutRolesInput> | model_has_rolesCreateWithoutRolesInput[] | model_has_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: model_has_rolesCreateOrConnectWithoutRolesInput | model_has_rolesCreateOrConnectWithoutRolesInput[]
    createMany?: model_has_rolesCreateManyRolesInputEnvelope
    connect?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
  }

  export type role_has_permissionsUncheckedCreateNestedManyWithoutRolesInput = {
    create?: XOR<role_has_permissionsCreateWithoutRolesInput, role_has_permissionsUncheckedCreateWithoutRolesInput> | role_has_permissionsCreateWithoutRolesInput[] | role_has_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_has_permissionsCreateOrConnectWithoutRolesInput | role_has_permissionsCreateOrConnectWithoutRolesInput[]
    createMany?: role_has_permissionsCreateManyRolesInputEnvelope
    connect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
  }

  export type model_has_rolesUpdateManyWithoutRolesNestedInput = {
    create?: XOR<model_has_rolesCreateWithoutRolesInput, model_has_rolesUncheckedCreateWithoutRolesInput> | model_has_rolesCreateWithoutRolesInput[] | model_has_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: model_has_rolesCreateOrConnectWithoutRolesInput | model_has_rolesCreateOrConnectWithoutRolesInput[]
    upsert?: model_has_rolesUpsertWithWhereUniqueWithoutRolesInput | model_has_rolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: model_has_rolesCreateManyRolesInputEnvelope
    set?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
    disconnect?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
    delete?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
    connect?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
    update?: model_has_rolesUpdateWithWhereUniqueWithoutRolesInput | model_has_rolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: model_has_rolesUpdateManyWithWhereWithoutRolesInput | model_has_rolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: model_has_rolesScalarWhereInput | model_has_rolesScalarWhereInput[]
  }

  export type role_has_permissionsUpdateManyWithoutRolesNestedInput = {
    create?: XOR<role_has_permissionsCreateWithoutRolesInput, role_has_permissionsUncheckedCreateWithoutRolesInput> | role_has_permissionsCreateWithoutRolesInput[] | role_has_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_has_permissionsCreateOrConnectWithoutRolesInput | role_has_permissionsCreateOrConnectWithoutRolesInput[]
    upsert?: role_has_permissionsUpsertWithWhereUniqueWithoutRolesInput | role_has_permissionsUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: role_has_permissionsCreateManyRolesInputEnvelope
    set?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    disconnect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    delete?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    connect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    update?: role_has_permissionsUpdateWithWhereUniqueWithoutRolesInput | role_has_permissionsUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: role_has_permissionsUpdateManyWithWhereWithoutRolesInput | role_has_permissionsUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: role_has_permissionsScalarWhereInput | role_has_permissionsScalarWhereInput[]
  }

  export type model_has_rolesUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<model_has_rolesCreateWithoutRolesInput, model_has_rolesUncheckedCreateWithoutRolesInput> | model_has_rolesCreateWithoutRolesInput[] | model_has_rolesUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: model_has_rolesCreateOrConnectWithoutRolesInput | model_has_rolesCreateOrConnectWithoutRolesInput[]
    upsert?: model_has_rolesUpsertWithWhereUniqueWithoutRolesInput | model_has_rolesUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: model_has_rolesCreateManyRolesInputEnvelope
    set?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
    disconnect?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
    delete?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
    connect?: model_has_rolesWhereUniqueInput | model_has_rolesWhereUniqueInput[]
    update?: model_has_rolesUpdateWithWhereUniqueWithoutRolesInput | model_has_rolesUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: model_has_rolesUpdateManyWithWhereWithoutRolesInput | model_has_rolesUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: model_has_rolesScalarWhereInput | model_has_rolesScalarWhereInput[]
  }

  export type role_has_permissionsUncheckedUpdateManyWithoutRolesNestedInput = {
    create?: XOR<role_has_permissionsCreateWithoutRolesInput, role_has_permissionsUncheckedCreateWithoutRolesInput> | role_has_permissionsCreateWithoutRolesInput[] | role_has_permissionsUncheckedCreateWithoutRolesInput[]
    connectOrCreate?: role_has_permissionsCreateOrConnectWithoutRolesInput | role_has_permissionsCreateOrConnectWithoutRolesInput[]
    upsert?: role_has_permissionsUpsertWithWhereUniqueWithoutRolesInput | role_has_permissionsUpsertWithWhereUniqueWithoutRolesInput[]
    createMany?: role_has_permissionsCreateManyRolesInputEnvelope
    set?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    disconnect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    delete?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    connect?: role_has_permissionsWhereUniqueInput | role_has_permissionsWhereUniqueInput[]
    update?: role_has_permissionsUpdateWithWhereUniqueWithoutRolesInput | role_has_permissionsUpdateWithWhereUniqueWithoutRolesInput[]
    updateMany?: role_has_permissionsUpdateManyWithWhereWithoutRolesInput | role_has_permissionsUpdateManyWithWhereWithoutRolesInput[]
    deleteMany?: role_has_permissionsScalarWhereInput | role_has_permissionsScalarWhereInput[]
  }

  export type companiesCreateNestedOneWithoutUsersInput = {
    create?: XOR<companiesCreateWithoutUsersInput, companiesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: companiesCreateOrConnectWithoutUsersInput
    connect?: companiesWhereUniqueInput
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type companiesUpdateOneWithoutUsersNestedInput = {
    create?: XOR<companiesCreateWithoutUsersInput, companiesUncheckedCreateWithoutUsersInput>
    connectOrCreate?: companiesCreateOrConnectWithoutUsersInput
    upsert?: companiesUpsertWithoutUsersInput
    disconnect?: companiesWhereInput | boolean
    delete?: companiesWhereInput | boolean
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutUsersInput, companiesUpdateWithoutUsersInput>, companiesUncheckedUpdateWithoutUsersInput>
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type companiesCreateNestedOneWithoutCategoriesInput = {
    create?: XOR<companiesCreateWithoutCategoriesInput, companiesUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCategoriesInput
    connect?: companiesWhereUniqueInput
  }

  export type categoriesCreateNestedOneWithoutOther_categoriesInput = {
    create?: XOR<categoriesCreateWithoutOther_categoriesInput, categoriesUncheckedCreateWithoutOther_categoriesInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutOther_categoriesInput
    connect?: categoriesWhereUniqueInput
  }

  export type categoriesCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<categoriesCreateWithoutCategoriesInput, categoriesUncheckedCreateWithoutCategoriesInput> | categoriesCreateWithoutCategoriesInput[] | categoriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutCategoriesInput | categoriesCreateOrConnectWithoutCategoriesInput[]
    createMany?: categoriesCreateManyCategoriesInputEnvelope
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
  }

  export type integration_category_mappingsCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<integration_category_mappingsCreateWithoutCategoriesInput, integration_category_mappingsUncheckedCreateWithoutCategoriesInput> | integration_category_mappingsCreateWithoutCategoriesInput[] | integration_category_mappingsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: integration_category_mappingsCreateOrConnectWithoutCategoriesInput | integration_category_mappingsCreateOrConnectWithoutCategoriesInput[]
    createMany?: integration_category_mappingsCreateManyCategoriesInputEnvelope
    connect?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
  }

  export type offer_categoryCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<offer_categoryCreateWithoutCategoriesInput, offer_categoryUncheckedCreateWithoutCategoriesInput> | offer_categoryCreateWithoutCategoriesInput[] | offer_categoryUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: offer_categoryCreateOrConnectWithoutCategoriesInput | offer_categoryCreateOrConnectWithoutCategoriesInput[]
    createMany?: offer_categoryCreateManyCategoriesInputEnvelope
    connect?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
  }

  export type offersCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<offersCreateWithoutCategoriesInput, offersUncheckedCreateWithoutCategoriesInput> | offersCreateWithoutCategoriesInput[] | offersUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: offersCreateOrConnectWithoutCategoriesInput | offersCreateOrConnectWithoutCategoriesInput[]
    createMany?: offersCreateManyCategoriesInputEnvelope
    connect?: offersWhereUniqueInput | offersWhereUniqueInput[]
  }

  export type categoriesUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<categoriesCreateWithoutCategoriesInput, categoriesUncheckedCreateWithoutCategoriesInput> | categoriesCreateWithoutCategoriesInput[] | categoriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutCategoriesInput | categoriesCreateOrConnectWithoutCategoriesInput[]
    createMany?: categoriesCreateManyCategoriesInputEnvelope
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
  }

  export type integration_category_mappingsUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<integration_category_mappingsCreateWithoutCategoriesInput, integration_category_mappingsUncheckedCreateWithoutCategoriesInput> | integration_category_mappingsCreateWithoutCategoriesInput[] | integration_category_mappingsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: integration_category_mappingsCreateOrConnectWithoutCategoriesInput | integration_category_mappingsCreateOrConnectWithoutCategoriesInput[]
    createMany?: integration_category_mappingsCreateManyCategoriesInputEnvelope
    connect?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
  }

  export type offer_categoryUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<offer_categoryCreateWithoutCategoriesInput, offer_categoryUncheckedCreateWithoutCategoriesInput> | offer_categoryCreateWithoutCategoriesInput[] | offer_categoryUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: offer_categoryCreateOrConnectWithoutCategoriesInput | offer_categoryCreateOrConnectWithoutCategoriesInput[]
    createMany?: offer_categoryCreateManyCategoriesInputEnvelope
    connect?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
  }

  export type offersUncheckedCreateNestedManyWithoutCategoriesInput = {
    create?: XOR<offersCreateWithoutCategoriesInput, offersUncheckedCreateWithoutCategoriesInput> | offersCreateWithoutCategoriesInput[] | offersUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: offersCreateOrConnectWithoutCategoriesInput | offersCreateOrConnectWithoutCategoriesInput[]
    createMany?: offersCreateManyCategoriesInputEnvelope
    connect?: offersWhereUniqueInput | offersWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type companiesUpdateOneRequiredWithoutCategoriesNestedInput = {
    create?: XOR<companiesCreateWithoutCategoriesInput, companiesUncheckedCreateWithoutCategoriesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCategoriesInput
    upsert?: companiesUpsertWithoutCategoriesInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutCategoriesInput, companiesUpdateWithoutCategoriesInput>, companiesUncheckedUpdateWithoutCategoriesInput>
  }

  export type categoriesUpdateOneWithoutOther_categoriesNestedInput = {
    create?: XOR<categoriesCreateWithoutOther_categoriesInput, categoriesUncheckedCreateWithoutOther_categoriesInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutOther_categoriesInput
    upsert?: categoriesUpsertWithoutOther_categoriesInput
    disconnect?: categoriesWhereInput | boolean
    delete?: categoriesWhereInput | boolean
    connect?: categoriesWhereUniqueInput
    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutOther_categoriesInput, categoriesUpdateWithoutOther_categoriesInput>, categoriesUncheckedUpdateWithoutOther_categoriesInput>
  }

  export type categoriesUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<categoriesCreateWithoutCategoriesInput, categoriesUncheckedCreateWithoutCategoriesInput> | categoriesCreateWithoutCategoriesInput[] | categoriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutCategoriesInput | categoriesCreateOrConnectWithoutCategoriesInput[]
    upsert?: categoriesUpsertWithWhereUniqueWithoutCategoriesInput | categoriesUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: categoriesCreateManyCategoriesInputEnvelope
    set?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    disconnect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    delete?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    update?: categoriesUpdateWithWhereUniqueWithoutCategoriesInput | categoriesUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: categoriesUpdateManyWithWhereWithoutCategoriesInput | categoriesUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
  }

  export type integration_category_mappingsUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<integration_category_mappingsCreateWithoutCategoriesInput, integration_category_mappingsUncheckedCreateWithoutCategoriesInput> | integration_category_mappingsCreateWithoutCategoriesInput[] | integration_category_mappingsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: integration_category_mappingsCreateOrConnectWithoutCategoriesInput | integration_category_mappingsCreateOrConnectWithoutCategoriesInput[]
    upsert?: integration_category_mappingsUpsertWithWhereUniqueWithoutCategoriesInput | integration_category_mappingsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: integration_category_mappingsCreateManyCategoriesInputEnvelope
    set?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
    disconnect?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
    delete?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
    connect?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
    update?: integration_category_mappingsUpdateWithWhereUniqueWithoutCategoriesInput | integration_category_mappingsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: integration_category_mappingsUpdateManyWithWhereWithoutCategoriesInput | integration_category_mappingsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: integration_category_mappingsScalarWhereInput | integration_category_mappingsScalarWhereInput[]
  }

  export type offer_categoryUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<offer_categoryCreateWithoutCategoriesInput, offer_categoryUncheckedCreateWithoutCategoriesInput> | offer_categoryCreateWithoutCategoriesInput[] | offer_categoryUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: offer_categoryCreateOrConnectWithoutCategoriesInput | offer_categoryCreateOrConnectWithoutCategoriesInput[]
    upsert?: offer_categoryUpsertWithWhereUniqueWithoutCategoriesInput | offer_categoryUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: offer_categoryCreateManyCategoriesInputEnvelope
    set?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
    disconnect?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
    delete?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
    connect?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
    update?: offer_categoryUpdateWithWhereUniqueWithoutCategoriesInput | offer_categoryUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: offer_categoryUpdateManyWithWhereWithoutCategoriesInput | offer_categoryUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: offer_categoryScalarWhereInput | offer_categoryScalarWhereInput[]
  }

  export type offersUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<offersCreateWithoutCategoriesInput, offersUncheckedCreateWithoutCategoriesInput> | offersCreateWithoutCategoriesInput[] | offersUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: offersCreateOrConnectWithoutCategoriesInput | offersCreateOrConnectWithoutCategoriesInput[]
    upsert?: offersUpsertWithWhereUniqueWithoutCategoriesInput | offersUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: offersCreateManyCategoriesInputEnvelope
    set?: offersWhereUniqueInput | offersWhereUniqueInput[]
    disconnect?: offersWhereUniqueInput | offersWhereUniqueInput[]
    delete?: offersWhereUniqueInput | offersWhereUniqueInput[]
    connect?: offersWhereUniqueInput | offersWhereUniqueInput[]
    update?: offersUpdateWithWhereUniqueWithoutCategoriesInput | offersUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: offersUpdateManyWithWhereWithoutCategoriesInput | offersUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: offersScalarWhereInput | offersScalarWhereInput[]
  }

  export type categoriesUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<categoriesCreateWithoutCategoriesInput, categoriesUncheckedCreateWithoutCategoriesInput> | categoriesCreateWithoutCategoriesInput[] | categoriesUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutCategoriesInput | categoriesCreateOrConnectWithoutCategoriesInput[]
    upsert?: categoriesUpsertWithWhereUniqueWithoutCategoriesInput | categoriesUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: categoriesCreateManyCategoriesInputEnvelope
    set?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    disconnect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    delete?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    update?: categoriesUpdateWithWhereUniqueWithoutCategoriesInput | categoriesUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: categoriesUpdateManyWithWhereWithoutCategoriesInput | categoriesUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
  }

  export type integration_category_mappingsUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<integration_category_mappingsCreateWithoutCategoriesInput, integration_category_mappingsUncheckedCreateWithoutCategoriesInput> | integration_category_mappingsCreateWithoutCategoriesInput[] | integration_category_mappingsUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: integration_category_mappingsCreateOrConnectWithoutCategoriesInput | integration_category_mappingsCreateOrConnectWithoutCategoriesInput[]
    upsert?: integration_category_mappingsUpsertWithWhereUniqueWithoutCategoriesInput | integration_category_mappingsUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: integration_category_mappingsCreateManyCategoriesInputEnvelope
    set?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
    disconnect?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
    delete?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
    connect?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
    update?: integration_category_mappingsUpdateWithWhereUniqueWithoutCategoriesInput | integration_category_mappingsUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: integration_category_mappingsUpdateManyWithWhereWithoutCategoriesInput | integration_category_mappingsUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: integration_category_mappingsScalarWhereInput | integration_category_mappingsScalarWhereInput[]
  }

  export type offer_categoryUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<offer_categoryCreateWithoutCategoriesInput, offer_categoryUncheckedCreateWithoutCategoriesInput> | offer_categoryCreateWithoutCategoriesInput[] | offer_categoryUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: offer_categoryCreateOrConnectWithoutCategoriesInput | offer_categoryCreateOrConnectWithoutCategoriesInput[]
    upsert?: offer_categoryUpsertWithWhereUniqueWithoutCategoriesInput | offer_categoryUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: offer_categoryCreateManyCategoriesInputEnvelope
    set?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
    disconnect?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
    delete?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
    connect?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
    update?: offer_categoryUpdateWithWhereUniqueWithoutCategoriesInput | offer_categoryUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: offer_categoryUpdateManyWithWhereWithoutCategoriesInput | offer_categoryUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: offer_categoryScalarWhereInput | offer_categoryScalarWhereInput[]
  }

  export type offersUncheckedUpdateManyWithoutCategoriesNestedInput = {
    create?: XOR<offersCreateWithoutCategoriesInput, offersUncheckedCreateWithoutCategoriesInput> | offersCreateWithoutCategoriesInput[] | offersUncheckedCreateWithoutCategoriesInput[]
    connectOrCreate?: offersCreateOrConnectWithoutCategoriesInput | offersCreateOrConnectWithoutCategoriesInput[]
    upsert?: offersUpsertWithWhereUniqueWithoutCategoriesInput | offersUpsertWithWhereUniqueWithoutCategoriesInput[]
    createMany?: offersCreateManyCategoriesInputEnvelope
    set?: offersWhereUniqueInput | offersWhereUniqueInput[]
    disconnect?: offersWhereUniqueInput | offersWhereUniqueInput[]
    delete?: offersWhereUniqueInput | offersWhereUniqueInput[]
    connect?: offersWhereUniqueInput | offersWhereUniqueInput[]
    update?: offersUpdateWithWhereUniqueWithoutCategoriesInput | offersUpdateWithWhereUniqueWithoutCategoriesInput[]
    updateMany?: offersUpdateManyWithWhereWithoutCategoriesInput | offersUpdateManyWithWhereWithoutCategoriesInput[]
    deleteMany?: offersScalarWhereInput | offersScalarWhereInput[]
  }

  export type categoriesCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<categoriesCreateWithoutCompaniesInput, categoriesUncheckedCreateWithoutCompaniesInput> | categoriesCreateWithoutCompaniesInput[] | categoriesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutCompaniesInput | categoriesCreateOrConnectWithoutCompaniesInput[]
    createMany?: categoriesCreateManyCompaniesInputEnvelope
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
  }

  export type company_frontend_settingsCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<company_frontend_settingsCreateWithoutCompaniesInput, company_frontend_settingsUncheckedCreateWithoutCompaniesInput> | company_frontend_settingsCreateWithoutCompaniesInput[] | company_frontend_settingsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_frontend_settingsCreateOrConnectWithoutCompaniesInput | company_frontend_settingsCreateOrConnectWithoutCompaniesInput[]
    createMany?: company_frontend_settingsCreateManyCompaniesInputEnvelope
    connect?: company_frontend_settingsWhereUniqueInput | company_frontend_settingsWhereUniqueInput[]
  }

  export type company_integrationsCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<company_integrationsCreateWithoutCompaniesInput, company_integrationsUncheckedCreateWithoutCompaniesInput> | company_integrationsCreateWithoutCompaniesInput[] | company_integrationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_integrationsCreateOrConnectWithoutCompaniesInput | company_integrationsCreateOrConnectWithoutCompaniesInput[]
    createMany?: company_integrationsCreateManyCompaniesInputEnvelope
    connect?: company_integrationsWhereUniqueInput | company_integrationsWhereUniqueInput[]
  }

  export type company_profilesCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<company_profilesCreateWithoutCompaniesInput, company_profilesUncheckedCreateWithoutCompaniesInput> | company_profilesCreateWithoutCompaniesInput[] | company_profilesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_profilesCreateOrConnectWithoutCompaniesInput | company_profilesCreateOrConnectWithoutCompaniesInput[]
    createMany?: company_profilesCreateManyCompaniesInputEnvelope
    connect?: company_profilesWhereUniqueInput | company_profilesWhereUniqueInput[]
  }

  export type company_subscriptionsCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<company_subscriptionsCreateWithoutCompaniesInput, company_subscriptionsUncheckedCreateWithoutCompaniesInput> | company_subscriptionsCreateWithoutCompaniesInput[] | company_subscriptionsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_subscriptionsCreateOrConnectWithoutCompaniesInput | company_subscriptionsCreateOrConnectWithoutCompaniesInput[]
    createMany?: company_subscriptionsCreateManyCompaniesInputEnvelope
    connect?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
  }

  export type integration_category_mappingsCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<integration_category_mappingsCreateWithoutCompaniesInput, integration_category_mappingsUncheckedCreateWithoutCompaniesInput> | integration_category_mappingsCreateWithoutCompaniesInput[] | integration_category_mappingsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: integration_category_mappingsCreateOrConnectWithoutCompaniesInput | integration_category_mappingsCreateOrConnectWithoutCompaniesInput[]
    createMany?: integration_category_mappingsCreateManyCompaniesInputEnvelope
    connect?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
  }

  export type offersCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<offersCreateWithoutCompaniesInput, offersUncheckedCreateWithoutCompaniesInput> | offersCreateWithoutCompaniesInput[] | offersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: offersCreateOrConnectWithoutCompaniesInput | offersCreateOrConnectWithoutCompaniesInput[]
    createMany?: offersCreateManyCompaniesInputEnvelope
    connect?: offersWhereUniqueInput | offersWhereUniqueInput[]
  }

  export type storesCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<storesCreateWithoutCompaniesInput, storesUncheckedCreateWithoutCompaniesInput> | storesCreateWithoutCompaniesInput[] | storesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: storesCreateOrConnectWithoutCompaniesInput | storesCreateOrConnectWithoutCompaniesInput[]
    createMany?: storesCreateManyCompaniesInputEnvelope
    connect?: storesWhereUniqueInput | storesWhereUniqueInput[]
  }

  export type usersCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<usersCreateWithoutCompaniesInput, usersUncheckedCreateWithoutCompaniesInput> | usersCreateWithoutCompaniesInput[] | usersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutCompaniesInput | usersCreateOrConnectWithoutCompaniesInput[]
    createMany?: usersCreateManyCompaniesInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type categoriesUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<categoriesCreateWithoutCompaniesInput, categoriesUncheckedCreateWithoutCompaniesInput> | categoriesCreateWithoutCompaniesInput[] | categoriesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutCompaniesInput | categoriesCreateOrConnectWithoutCompaniesInput[]
    createMany?: categoriesCreateManyCompaniesInputEnvelope
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
  }

  export type company_frontend_settingsUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<company_frontend_settingsCreateWithoutCompaniesInput, company_frontend_settingsUncheckedCreateWithoutCompaniesInput> | company_frontend_settingsCreateWithoutCompaniesInput[] | company_frontend_settingsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_frontend_settingsCreateOrConnectWithoutCompaniesInput | company_frontend_settingsCreateOrConnectWithoutCompaniesInput[]
    createMany?: company_frontend_settingsCreateManyCompaniesInputEnvelope
    connect?: company_frontend_settingsWhereUniqueInput | company_frontend_settingsWhereUniqueInput[]
  }

  export type company_integrationsUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<company_integrationsCreateWithoutCompaniesInput, company_integrationsUncheckedCreateWithoutCompaniesInput> | company_integrationsCreateWithoutCompaniesInput[] | company_integrationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_integrationsCreateOrConnectWithoutCompaniesInput | company_integrationsCreateOrConnectWithoutCompaniesInput[]
    createMany?: company_integrationsCreateManyCompaniesInputEnvelope
    connect?: company_integrationsWhereUniqueInput | company_integrationsWhereUniqueInput[]
  }

  export type company_profilesUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<company_profilesCreateWithoutCompaniesInput, company_profilesUncheckedCreateWithoutCompaniesInput> | company_profilesCreateWithoutCompaniesInput[] | company_profilesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_profilesCreateOrConnectWithoutCompaniesInput | company_profilesCreateOrConnectWithoutCompaniesInput[]
    createMany?: company_profilesCreateManyCompaniesInputEnvelope
    connect?: company_profilesWhereUniqueInput | company_profilesWhereUniqueInput[]
  }

  export type company_subscriptionsUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<company_subscriptionsCreateWithoutCompaniesInput, company_subscriptionsUncheckedCreateWithoutCompaniesInput> | company_subscriptionsCreateWithoutCompaniesInput[] | company_subscriptionsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_subscriptionsCreateOrConnectWithoutCompaniesInput | company_subscriptionsCreateOrConnectWithoutCompaniesInput[]
    createMany?: company_subscriptionsCreateManyCompaniesInputEnvelope
    connect?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
  }

  export type integration_category_mappingsUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<integration_category_mappingsCreateWithoutCompaniesInput, integration_category_mappingsUncheckedCreateWithoutCompaniesInput> | integration_category_mappingsCreateWithoutCompaniesInput[] | integration_category_mappingsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: integration_category_mappingsCreateOrConnectWithoutCompaniesInput | integration_category_mappingsCreateOrConnectWithoutCompaniesInput[]
    createMany?: integration_category_mappingsCreateManyCompaniesInputEnvelope
    connect?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
  }

  export type offersUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<offersCreateWithoutCompaniesInput, offersUncheckedCreateWithoutCompaniesInput> | offersCreateWithoutCompaniesInput[] | offersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: offersCreateOrConnectWithoutCompaniesInput | offersCreateOrConnectWithoutCompaniesInput[]
    createMany?: offersCreateManyCompaniesInputEnvelope
    connect?: offersWhereUniqueInput | offersWhereUniqueInput[]
  }

  export type storesUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<storesCreateWithoutCompaniesInput, storesUncheckedCreateWithoutCompaniesInput> | storesCreateWithoutCompaniesInput[] | storesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: storesCreateOrConnectWithoutCompaniesInput | storesCreateOrConnectWithoutCompaniesInput[]
    createMany?: storesCreateManyCompaniesInputEnvelope
    connect?: storesWhereUniqueInput | storesWhereUniqueInput[]
  }

  export type usersUncheckedCreateNestedManyWithoutCompaniesInput = {
    create?: XOR<usersCreateWithoutCompaniesInput, usersUncheckedCreateWithoutCompaniesInput> | usersCreateWithoutCompaniesInput[] | usersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutCompaniesInput | usersCreateOrConnectWithoutCompaniesInput[]
    createMany?: usersCreateManyCompaniesInputEnvelope
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
  }

  export type categoriesUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<categoriesCreateWithoutCompaniesInput, categoriesUncheckedCreateWithoutCompaniesInput> | categoriesCreateWithoutCompaniesInput[] | categoriesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutCompaniesInput | categoriesCreateOrConnectWithoutCompaniesInput[]
    upsert?: categoriesUpsertWithWhereUniqueWithoutCompaniesInput | categoriesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: categoriesCreateManyCompaniesInputEnvelope
    set?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    disconnect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    delete?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    update?: categoriesUpdateWithWhereUniqueWithoutCompaniesInput | categoriesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: categoriesUpdateManyWithWhereWithoutCompaniesInput | categoriesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
  }

  export type company_frontend_settingsUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<company_frontend_settingsCreateWithoutCompaniesInput, company_frontend_settingsUncheckedCreateWithoutCompaniesInput> | company_frontend_settingsCreateWithoutCompaniesInput[] | company_frontend_settingsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_frontend_settingsCreateOrConnectWithoutCompaniesInput | company_frontend_settingsCreateOrConnectWithoutCompaniesInput[]
    upsert?: company_frontend_settingsUpsertWithWhereUniqueWithoutCompaniesInput | company_frontend_settingsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: company_frontend_settingsCreateManyCompaniesInputEnvelope
    set?: company_frontend_settingsWhereUniqueInput | company_frontend_settingsWhereUniqueInput[]
    disconnect?: company_frontend_settingsWhereUniqueInput | company_frontend_settingsWhereUniqueInput[]
    delete?: company_frontend_settingsWhereUniqueInput | company_frontend_settingsWhereUniqueInput[]
    connect?: company_frontend_settingsWhereUniqueInput | company_frontend_settingsWhereUniqueInput[]
    update?: company_frontend_settingsUpdateWithWhereUniqueWithoutCompaniesInput | company_frontend_settingsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: company_frontend_settingsUpdateManyWithWhereWithoutCompaniesInput | company_frontend_settingsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: company_frontend_settingsScalarWhereInput | company_frontend_settingsScalarWhereInput[]
  }

  export type company_integrationsUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<company_integrationsCreateWithoutCompaniesInput, company_integrationsUncheckedCreateWithoutCompaniesInput> | company_integrationsCreateWithoutCompaniesInput[] | company_integrationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_integrationsCreateOrConnectWithoutCompaniesInput | company_integrationsCreateOrConnectWithoutCompaniesInput[]
    upsert?: company_integrationsUpsertWithWhereUniqueWithoutCompaniesInput | company_integrationsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: company_integrationsCreateManyCompaniesInputEnvelope
    set?: company_integrationsWhereUniqueInput | company_integrationsWhereUniqueInput[]
    disconnect?: company_integrationsWhereUniqueInput | company_integrationsWhereUniqueInput[]
    delete?: company_integrationsWhereUniqueInput | company_integrationsWhereUniqueInput[]
    connect?: company_integrationsWhereUniqueInput | company_integrationsWhereUniqueInput[]
    update?: company_integrationsUpdateWithWhereUniqueWithoutCompaniesInput | company_integrationsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: company_integrationsUpdateManyWithWhereWithoutCompaniesInput | company_integrationsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: company_integrationsScalarWhereInput | company_integrationsScalarWhereInput[]
  }

  export type company_profilesUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<company_profilesCreateWithoutCompaniesInput, company_profilesUncheckedCreateWithoutCompaniesInput> | company_profilesCreateWithoutCompaniesInput[] | company_profilesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_profilesCreateOrConnectWithoutCompaniesInput | company_profilesCreateOrConnectWithoutCompaniesInput[]
    upsert?: company_profilesUpsertWithWhereUniqueWithoutCompaniesInput | company_profilesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: company_profilesCreateManyCompaniesInputEnvelope
    set?: company_profilesWhereUniqueInput | company_profilesWhereUniqueInput[]
    disconnect?: company_profilesWhereUniqueInput | company_profilesWhereUniqueInput[]
    delete?: company_profilesWhereUniqueInput | company_profilesWhereUniqueInput[]
    connect?: company_profilesWhereUniqueInput | company_profilesWhereUniqueInput[]
    update?: company_profilesUpdateWithWhereUniqueWithoutCompaniesInput | company_profilesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: company_profilesUpdateManyWithWhereWithoutCompaniesInput | company_profilesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: company_profilesScalarWhereInput | company_profilesScalarWhereInput[]
  }

  export type company_subscriptionsUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<company_subscriptionsCreateWithoutCompaniesInput, company_subscriptionsUncheckedCreateWithoutCompaniesInput> | company_subscriptionsCreateWithoutCompaniesInput[] | company_subscriptionsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_subscriptionsCreateOrConnectWithoutCompaniesInput | company_subscriptionsCreateOrConnectWithoutCompaniesInput[]
    upsert?: company_subscriptionsUpsertWithWhereUniqueWithoutCompaniesInput | company_subscriptionsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: company_subscriptionsCreateManyCompaniesInputEnvelope
    set?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
    disconnect?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
    delete?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
    connect?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
    update?: company_subscriptionsUpdateWithWhereUniqueWithoutCompaniesInput | company_subscriptionsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: company_subscriptionsUpdateManyWithWhereWithoutCompaniesInput | company_subscriptionsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: company_subscriptionsScalarWhereInput | company_subscriptionsScalarWhereInput[]
  }

  export type integration_category_mappingsUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<integration_category_mappingsCreateWithoutCompaniesInput, integration_category_mappingsUncheckedCreateWithoutCompaniesInput> | integration_category_mappingsCreateWithoutCompaniesInput[] | integration_category_mappingsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: integration_category_mappingsCreateOrConnectWithoutCompaniesInput | integration_category_mappingsCreateOrConnectWithoutCompaniesInput[]
    upsert?: integration_category_mappingsUpsertWithWhereUniqueWithoutCompaniesInput | integration_category_mappingsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: integration_category_mappingsCreateManyCompaniesInputEnvelope
    set?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
    disconnect?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
    delete?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
    connect?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
    update?: integration_category_mappingsUpdateWithWhereUniqueWithoutCompaniesInput | integration_category_mappingsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: integration_category_mappingsUpdateManyWithWhereWithoutCompaniesInput | integration_category_mappingsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: integration_category_mappingsScalarWhereInput | integration_category_mappingsScalarWhereInput[]
  }

  export type offersUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<offersCreateWithoutCompaniesInput, offersUncheckedCreateWithoutCompaniesInput> | offersCreateWithoutCompaniesInput[] | offersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: offersCreateOrConnectWithoutCompaniesInput | offersCreateOrConnectWithoutCompaniesInput[]
    upsert?: offersUpsertWithWhereUniqueWithoutCompaniesInput | offersUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: offersCreateManyCompaniesInputEnvelope
    set?: offersWhereUniqueInput | offersWhereUniqueInput[]
    disconnect?: offersWhereUniqueInput | offersWhereUniqueInput[]
    delete?: offersWhereUniqueInput | offersWhereUniqueInput[]
    connect?: offersWhereUniqueInput | offersWhereUniqueInput[]
    update?: offersUpdateWithWhereUniqueWithoutCompaniesInput | offersUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: offersUpdateManyWithWhereWithoutCompaniesInput | offersUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: offersScalarWhereInput | offersScalarWhereInput[]
  }

  export type storesUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<storesCreateWithoutCompaniesInput, storesUncheckedCreateWithoutCompaniesInput> | storesCreateWithoutCompaniesInput[] | storesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: storesCreateOrConnectWithoutCompaniesInput | storesCreateOrConnectWithoutCompaniesInput[]
    upsert?: storesUpsertWithWhereUniqueWithoutCompaniesInput | storesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: storesCreateManyCompaniesInputEnvelope
    set?: storesWhereUniqueInput | storesWhereUniqueInput[]
    disconnect?: storesWhereUniqueInput | storesWhereUniqueInput[]
    delete?: storesWhereUniqueInput | storesWhereUniqueInput[]
    connect?: storesWhereUniqueInput | storesWhereUniqueInput[]
    update?: storesUpdateWithWhereUniqueWithoutCompaniesInput | storesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: storesUpdateManyWithWhereWithoutCompaniesInput | storesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: storesScalarWhereInput | storesScalarWhereInput[]
  }

  export type usersUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<usersCreateWithoutCompaniesInput, usersUncheckedCreateWithoutCompaniesInput> | usersCreateWithoutCompaniesInput[] | usersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutCompaniesInput | usersCreateOrConnectWithoutCompaniesInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutCompaniesInput | usersUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: usersCreateManyCompaniesInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutCompaniesInput | usersUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: usersUpdateManyWithWhereWithoutCompaniesInput | usersUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type categoriesUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<categoriesCreateWithoutCompaniesInput, categoriesUncheckedCreateWithoutCompaniesInput> | categoriesCreateWithoutCompaniesInput[] | categoriesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: categoriesCreateOrConnectWithoutCompaniesInput | categoriesCreateOrConnectWithoutCompaniesInput[]
    upsert?: categoriesUpsertWithWhereUniqueWithoutCompaniesInput | categoriesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: categoriesCreateManyCompaniesInputEnvelope
    set?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    disconnect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    delete?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    connect?: categoriesWhereUniqueInput | categoriesWhereUniqueInput[]
    update?: categoriesUpdateWithWhereUniqueWithoutCompaniesInput | categoriesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: categoriesUpdateManyWithWhereWithoutCompaniesInput | categoriesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
  }

  export type company_frontend_settingsUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<company_frontend_settingsCreateWithoutCompaniesInput, company_frontend_settingsUncheckedCreateWithoutCompaniesInput> | company_frontend_settingsCreateWithoutCompaniesInput[] | company_frontend_settingsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_frontend_settingsCreateOrConnectWithoutCompaniesInput | company_frontend_settingsCreateOrConnectWithoutCompaniesInput[]
    upsert?: company_frontend_settingsUpsertWithWhereUniqueWithoutCompaniesInput | company_frontend_settingsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: company_frontend_settingsCreateManyCompaniesInputEnvelope
    set?: company_frontend_settingsWhereUniqueInput | company_frontend_settingsWhereUniqueInput[]
    disconnect?: company_frontend_settingsWhereUniqueInput | company_frontend_settingsWhereUniqueInput[]
    delete?: company_frontend_settingsWhereUniqueInput | company_frontend_settingsWhereUniqueInput[]
    connect?: company_frontend_settingsWhereUniqueInput | company_frontend_settingsWhereUniqueInput[]
    update?: company_frontend_settingsUpdateWithWhereUniqueWithoutCompaniesInput | company_frontend_settingsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: company_frontend_settingsUpdateManyWithWhereWithoutCompaniesInput | company_frontend_settingsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: company_frontend_settingsScalarWhereInput | company_frontend_settingsScalarWhereInput[]
  }

  export type company_integrationsUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<company_integrationsCreateWithoutCompaniesInput, company_integrationsUncheckedCreateWithoutCompaniesInput> | company_integrationsCreateWithoutCompaniesInput[] | company_integrationsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_integrationsCreateOrConnectWithoutCompaniesInput | company_integrationsCreateOrConnectWithoutCompaniesInput[]
    upsert?: company_integrationsUpsertWithWhereUniqueWithoutCompaniesInput | company_integrationsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: company_integrationsCreateManyCompaniesInputEnvelope
    set?: company_integrationsWhereUniqueInput | company_integrationsWhereUniqueInput[]
    disconnect?: company_integrationsWhereUniqueInput | company_integrationsWhereUniqueInput[]
    delete?: company_integrationsWhereUniqueInput | company_integrationsWhereUniqueInput[]
    connect?: company_integrationsWhereUniqueInput | company_integrationsWhereUniqueInput[]
    update?: company_integrationsUpdateWithWhereUniqueWithoutCompaniesInput | company_integrationsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: company_integrationsUpdateManyWithWhereWithoutCompaniesInput | company_integrationsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: company_integrationsScalarWhereInput | company_integrationsScalarWhereInput[]
  }

  export type company_profilesUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<company_profilesCreateWithoutCompaniesInput, company_profilesUncheckedCreateWithoutCompaniesInput> | company_profilesCreateWithoutCompaniesInput[] | company_profilesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_profilesCreateOrConnectWithoutCompaniesInput | company_profilesCreateOrConnectWithoutCompaniesInput[]
    upsert?: company_profilesUpsertWithWhereUniqueWithoutCompaniesInput | company_profilesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: company_profilesCreateManyCompaniesInputEnvelope
    set?: company_profilesWhereUniqueInput | company_profilesWhereUniqueInput[]
    disconnect?: company_profilesWhereUniqueInput | company_profilesWhereUniqueInput[]
    delete?: company_profilesWhereUniqueInput | company_profilesWhereUniqueInput[]
    connect?: company_profilesWhereUniqueInput | company_profilesWhereUniqueInput[]
    update?: company_profilesUpdateWithWhereUniqueWithoutCompaniesInput | company_profilesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: company_profilesUpdateManyWithWhereWithoutCompaniesInput | company_profilesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: company_profilesScalarWhereInput | company_profilesScalarWhereInput[]
  }

  export type company_subscriptionsUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<company_subscriptionsCreateWithoutCompaniesInput, company_subscriptionsUncheckedCreateWithoutCompaniesInput> | company_subscriptionsCreateWithoutCompaniesInput[] | company_subscriptionsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: company_subscriptionsCreateOrConnectWithoutCompaniesInput | company_subscriptionsCreateOrConnectWithoutCompaniesInput[]
    upsert?: company_subscriptionsUpsertWithWhereUniqueWithoutCompaniesInput | company_subscriptionsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: company_subscriptionsCreateManyCompaniesInputEnvelope
    set?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
    disconnect?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
    delete?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
    connect?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
    update?: company_subscriptionsUpdateWithWhereUniqueWithoutCompaniesInput | company_subscriptionsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: company_subscriptionsUpdateManyWithWhereWithoutCompaniesInput | company_subscriptionsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: company_subscriptionsScalarWhereInput | company_subscriptionsScalarWhereInput[]
  }

  export type integration_category_mappingsUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<integration_category_mappingsCreateWithoutCompaniesInput, integration_category_mappingsUncheckedCreateWithoutCompaniesInput> | integration_category_mappingsCreateWithoutCompaniesInput[] | integration_category_mappingsUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: integration_category_mappingsCreateOrConnectWithoutCompaniesInput | integration_category_mappingsCreateOrConnectWithoutCompaniesInput[]
    upsert?: integration_category_mappingsUpsertWithWhereUniqueWithoutCompaniesInput | integration_category_mappingsUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: integration_category_mappingsCreateManyCompaniesInputEnvelope
    set?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
    disconnect?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
    delete?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
    connect?: integration_category_mappingsWhereUniqueInput | integration_category_mappingsWhereUniqueInput[]
    update?: integration_category_mappingsUpdateWithWhereUniqueWithoutCompaniesInput | integration_category_mappingsUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: integration_category_mappingsUpdateManyWithWhereWithoutCompaniesInput | integration_category_mappingsUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: integration_category_mappingsScalarWhereInput | integration_category_mappingsScalarWhereInput[]
  }

  export type offersUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<offersCreateWithoutCompaniesInput, offersUncheckedCreateWithoutCompaniesInput> | offersCreateWithoutCompaniesInput[] | offersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: offersCreateOrConnectWithoutCompaniesInput | offersCreateOrConnectWithoutCompaniesInput[]
    upsert?: offersUpsertWithWhereUniqueWithoutCompaniesInput | offersUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: offersCreateManyCompaniesInputEnvelope
    set?: offersWhereUniqueInput | offersWhereUniqueInput[]
    disconnect?: offersWhereUniqueInput | offersWhereUniqueInput[]
    delete?: offersWhereUniqueInput | offersWhereUniqueInput[]
    connect?: offersWhereUniqueInput | offersWhereUniqueInput[]
    update?: offersUpdateWithWhereUniqueWithoutCompaniesInput | offersUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: offersUpdateManyWithWhereWithoutCompaniesInput | offersUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: offersScalarWhereInput | offersScalarWhereInput[]
  }

  export type storesUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<storesCreateWithoutCompaniesInput, storesUncheckedCreateWithoutCompaniesInput> | storesCreateWithoutCompaniesInput[] | storesUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: storesCreateOrConnectWithoutCompaniesInput | storesCreateOrConnectWithoutCompaniesInput[]
    upsert?: storesUpsertWithWhereUniqueWithoutCompaniesInput | storesUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: storesCreateManyCompaniesInputEnvelope
    set?: storesWhereUniqueInput | storesWhereUniqueInput[]
    disconnect?: storesWhereUniqueInput | storesWhereUniqueInput[]
    delete?: storesWhereUniqueInput | storesWhereUniqueInput[]
    connect?: storesWhereUniqueInput | storesWhereUniqueInput[]
    update?: storesUpdateWithWhereUniqueWithoutCompaniesInput | storesUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: storesUpdateManyWithWhereWithoutCompaniesInput | storesUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: storesScalarWhereInput | storesScalarWhereInput[]
  }

  export type usersUncheckedUpdateManyWithoutCompaniesNestedInput = {
    create?: XOR<usersCreateWithoutCompaniesInput, usersUncheckedCreateWithoutCompaniesInput> | usersCreateWithoutCompaniesInput[] | usersUncheckedCreateWithoutCompaniesInput[]
    connectOrCreate?: usersCreateOrConnectWithoutCompaniesInput | usersCreateOrConnectWithoutCompaniesInput[]
    upsert?: usersUpsertWithWhereUniqueWithoutCompaniesInput | usersUpsertWithWhereUniqueWithoutCompaniesInput[]
    createMany?: usersCreateManyCompaniesInputEnvelope
    set?: usersWhereUniqueInput | usersWhereUniqueInput[]
    disconnect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    delete?: usersWhereUniqueInput | usersWhereUniqueInput[]
    connect?: usersWhereUniqueInput | usersWhereUniqueInput[]
    update?: usersUpdateWithWhereUniqueWithoutCompaniesInput | usersUpdateWithWhereUniqueWithoutCompaniesInput[]
    updateMany?: usersUpdateManyWithWhereWithoutCompaniesInput | usersUpdateManyWithWhereWithoutCompaniesInput[]
    deleteMany?: usersScalarWhereInput | usersScalarWhereInput[]
  }

  export type companiesCreateNestedOneWithoutCompany_frontend_settingsInput = {
    create?: XOR<companiesCreateWithoutCompany_frontend_settingsInput, companiesUncheckedCreateWithoutCompany_frontend_settingsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompany_frontend_settingsInput
    connect?: companiesWhereUniqueInput
  }

  export type companiesUpdateOneRequiredWithoutCompany_frontend_settingsNestedInput = {
    create?: XOR<companiesCreateWithoutCompany_frontend_settingsInput, companiesUncheckedCreateWithoutCompany_frontend_settingsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompany_frontend_settingsInput
    upsert?: companiesUpsertWithoutCompany_frontend_settingsInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutCompany_frontend_settingsInput, companiesUpdateWithoutCompany_frontend_settingsInput>, companiesUncheckedUpdateWithoutCompany_frontend_settingsInput>
  }

  export type companiesCreateNestedOneWithoutCompany_integrationsInput = {
    create?: XOR<companiesCreateWithoutCompany_integrationsInput, companiesUncheckedCreateWithoutCompany_integrationsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompany_integrationsInput
    connect?: companiesWhereUniqueInput
  }

  export type companiesUpdateOneRequiredWithoutCompany_integrationsNestedInput = {
    create?: XOR<companiesCreateWithoutCompany_integrationsInput, companiesUncheckedCreateWithoutCompany_integrationsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompany_integrationsInput
    upsert?: companiesUpsertWithoutCompany_integrationsInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutCompany_integrationsInput, companiesUpdateWithoutCompany_integrationsInput>, companiesUncheckedUpdateWithoutCompany_integrationsInput>
  }

  export type companiesCreateNestedOneWithoutCompany_profilesInput = {
    create?: XOR<companiesCreateWithoutCompany_profilesInput, companiesUncheckedCreateWithoutCompany_profilesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompany_profilesInput
    connect?: companiesWhereUniqueInput
  }

  export type companiesUpdateOneRequiredWithoutCompany_profilesNestedInput = {
    create?: XOR<companiesCreateWithoutCompany_profilesInput, companiesUncheckedCreateWithoutCompany_profilesInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompany_profilesInput
    upsert?: companiesUpsertWithoutCompany_profilesInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutCompany_profilesInput, companiesUpdateWithoutCompany_profilesInput>, companiesUncheckedUpdateWithoutCompany_profilesInput>
  }

  export type companiesCreateNestedOneWithoutCompany_subscriptionsInput = {
    create?: XOR<companiesCreateWithoutCompany_subscriptionsInput, companiesUncheckedCreateWithoutCompany_subscriptionsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompany_subscriptionsInput
    connect?: companiesWhereUniqueInput
  }

  export type subscriptionsCreateNestedOneWithoutCompany_subscriptionsInput = {
    create?: XOR<subscriptionsCreateWithoutCompany_subscriptionsInput, subscriptionsUncheckedCreateWithoutCompany_subscriptionsInput>
    connectOrCreate?: subscriptionsCreateOrConnectWithoutCompany_subscriptionsInput
    connect?: subscriptionsWhereUniqueInput
  }

  export type paymentsCreateNestedManyWithoutCompany_subscriptionsInput = {
    create?: XOR<paymentsCreateWithoutCompany_subscriptionsInput, paymentsUncheckedCreateWithoutCompany_subscriptionsInput> | paymentsCreateWithoutCompany_subscriptionsInput[] | paymentsUncheckedCreateWithoutCompany_subscriptionsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutCompany_subscriptionsInput | paymentsCreateOrConnectWithoutCompany_subscriptionsInput[]
    createMany?: paymentsCreateManyCompany_subscriptionsInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type paymentsUncheckedCreateNestedManyWithoutCompany_subscriptionsInput = {
    create?: XOR<paymentsCreateWithoutCompany_subscriptionsInput, paymentsUncheckedCreateWithoutCompany_subscriptionsInput> | paymentsCreateWithoutCompany_subscriptionsInput[] | paymentsUncheckedCreateWithoutCompany_subscriptionsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutCompany_subscriptionsInput | paymentsCreateOrConnectWithoutCompany_subscriptionsInput[]
    createMany?: paymentsCreateManyCompany_subscriptionsInputEnvelope
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
  }

  export type companiesUpdateOneRequiredWithoutCompany_subscriptionsNestedInput = {
    create?: XOR<companiesCreateWithoutCompany_subscriptionsInput, companiesUncheckedCreateWithoutCompany_subscriptionsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutCompany_subscriptionsInput
    upsert?: companiesUpsertWithoutCompany_subscriptionsInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutCompany_subscriptionsInput, companiesUpdateWithoutCompany_subscriptionsInput>, companiesUncheckedUpdateWithoutCompany_subscriptionsInput>
  }

  export type subscriptionsUpdateOneRequiredWithoutCompany_subscriptionsNestedInput = {
    create?: XOR<subscriptionsCreateWithoutCompany_subscriptionsInput, subscriptionsUncheckedCreateWithoutCompany_subscriptionsInput>
    connectOrCreate?: subscriptionsCreateOrConnectWithoutCompany_subscriptionsInput
    upsert?: subscriptionsUpsertWithoutCompany_subscriptionsInput
    connect?: subscriptionsWhereUniqueInput
    update?: XOR<XOR<subscriptionsUpdateToOneWithWhereWithoutCompany_subscriptionsInput, subscriptionsUpdateWithoutCompany_subscriptionsInput>, subscriptionsUncheckedUpdateWithoutCompany_subscriptionsInput>
  }

  export type paymentsUpdateManyWithoutCompany_subscriptionsNestedInput = {
    create?: XOR<paymentsCreateWithoutCompany_subscriptionsInput, paymentsUncheckedCreateWithoutCompany_subscriptionsInput> | paymentsCreateWithoutCompany_subscriptionsInput[] | paymentsUncheckedCreateWithoutCompany_subscriptionsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutCompany_subscriptionsInput | paymentsCreateOrConnectWithoutCompany_subscriptionsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutCompany_subscriptionsInput | paymentsUpsertWithWhereUniqueWithoutCompany_subscriptionsInput[]
    createMany?: paymentsCreateManyCompany_subscriptionsInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutCompany_subscriptionsInput | paymentsUpdateWithWhereUniqueWithoutCompany_subscriptionsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutCompany_subscriptionsInput | paymentsUpdateManyWithWhereWithoutCompany_subscriptionsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type paymentsUncheckedUpdateManyWithoutCompany_subscriptionsNestedInput = {
    create?: XOR<paymentsCreateWithoutCompany_subscriptionsInput, paymentsUncheckedCreateWithoutCompany_subscriptionsInput> | paymentsCreateWithoutCompany_subscriptionsInput[] | paymentsUncheckedCreateWithoutCompany_subscriptionsInput[]
    connectOrCreate?: paymentsCreateOrConnectWithoutCompany_subscriptionsInput | paymentsCreateOrConnectWithoutCompany_subscriptionsInput[]
    upsert?: paymentsUpsertWithWhereUniqueWithoutCompany_subscriptionsInput | paymentsUpsertWithWhereUniqueWithoutCompany_subscriptionsInput[]
    createMany?: paymentsCreateManyCompany_subscriptionsInputEnvelope
    set?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    disconnect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    delete?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    connect?: paymentsWhereUniqueInput | paymentsWhereUniqueInput[]
    update?: paymentsUpdateWithWhereUniqueWithoutCompany_subscriptionsInput | paymentsUpdateWithWhereUniqueWithoutCompany_subscriptionsInput[]
    updateMany?: paymentsUpdateManyWithWhereWithoutCompany_subscriptionsInput | paymentsUpdateManyWithWhereWithoutCompany_subscriptionsInput[]
    deleteMany?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
  }

  export type categoriesCreateNestedOneWithoutIntegration_category_mappingsInput = {
    create?: XOR<categoriesCreateWithoutIntegration_category_mappingsInput, categoriesUncheckedCreateWithoutIntegration_category_mappingsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutIntegration_category_mappingsInput
    connect?: categoriesWhereUniqueInput
  }

  export type companiesCreateNestedOneWithoutIntegration_category_mappingsInput = {
    create?: XOR<companiesCreateWithoutIntegration_category_mappingsInput, companiesUncheckedCreateWithoutIntegration_category_mappingsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutIntegration_category_mappingsInput
    connect?: companiesWhereUniqueInput
  }

  export type categoriesUpdateOneWithoutIntegration_category_mappingsNestedInput = {
    create?: XOR<categoriesCreateWithoutIntegration_category_mappingsInput, categoriesUncheckedCreateWithoutIntegration_category_mappingsInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutIntegration_category_mappingsInput
    upsert?: categoriesUpsertWithoutIntegration_category_mappingsInput
    disconnect?: categoriesWhereInput | boolean
    delete?: categoriesWhereInput | boolean
    connect?: categoriesWhereUniqueInput
    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutIntegration_category_mappingsInput, categoriesUpdateWithoutIntegration_category_mappingsInput>, categoriesUncheckedUpdateWithoutIntegration_category_mappingsInput>
  }

  export type companiesUpdateOneWithoutIntegration_category_mappingsNestedInput = {
    create?: XOR<companiesCreateWithoutIntegration_category_mappingsInput, companiesUncheckedCreateWithoutIntegration_category_mappingsInput>
    connectOrCreate?: companiesCreateOrConnectWithoutIntegration_category_mappingsInput
    upsert?: companiesUpsertWithoutIntegration_category_mappingsInput
    disconnect?: companiesWhereInput | boolean
    delete?: companiesWhereInput | boolean
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutIntegration_category_mappingsInput, companiesUpdateWithoutIntegration_category_mappingsInput>, companiesUncheckedUpdateWithoutIntegration_category_mappingsInput>
  }

  export type menusCreateNestedOneWithoutOther_menusInput = {
    create?: XOR<menusCreateWithoutOther_menusInput, menusUncheckedCreateWithoutOther_menusInput>
    connectOrCreate?: menusCreateOrConnectWithoutOther_menusInput
    connect?: menusWhereUniqueInput
  }

  export type menusCreateNestedManyWithoutMenusInput = {
    create?: XOR<menusCreateWithoutMenusInput, menusUncheckedCreateWithoutMenusInput> | menusCreateWithoutMenusInput[] | menusUncheckedCreateWithoutMenusInput[]
    connectOrCreate?: menusCreateOrConnectWithoutMenusInput | menusCreateOrConnectWithoutMenusInput[]
    createMany?: menusCreateManyMenusInputEnvelope
    connect?: menusWhereUniqueInput | menusWhereUniqueInput[]
  }

  export type menusUncheckedCreateNestedManyWithoutMenusInput = {
    create?: XOR<menusCreateWithoutMenusInput, menusUncheckedCreateWithoutMenusInput> | menusCreateWithoutMenusInput[] | menusUncheckedCreateWithoutMenusInput[]
    connectOrCreate?: menusCreateOrConnectWithoutMenusInput | menusCreateOrConnectWithoutMenusInput[]
    createMany?: menusCreateManyMenusInputEnvelope
    connect?: menusWhereUniqueInput | menusWhereUniqueInput[]
  }

  export type menusUpdateOneWithoutOther_menusNestedInput = {
    create?: XOR<menusCreateWithoutOther_menusInput, menusUncheckedCreateWithoutOther_menusInput>
    connectOrCreate?: menusCreateOrConnectWithoutOther_menusInput
    upsert?: menusUpsertWithoutOther_menusInput
    disconnect?: menusWhereInput | boolean
    delete?: menusWhereInput | boolean
    connect?: menusWhereUniqueInput
    update?: XOR<XOR<menusUpdateToOneWithWhereWithoutOther_menusInput, menusUpdateWithoutOther_menusInput>, menusUncheckedUpdateWithoutOther_menusInput>
  }

  export type menusUpdateManyWithoutMenusNestedInput = {
    create?: XOR<menusCreateWithoutMenusInput, menusUncheckedCreateWithoutMenusInput> | menusCreateWithoutMenusInput[] | menusUncheckedCreateWithoutMenusInput[]
    connectOrCreate?: menusCreateOrConnectWithoutMenusInput | menusCreateOrConnectWithoutMenusInput[]
    upsert?: menusUpsertWithWhereUniqueWithoutMenusInput | menusUpsertWithWhereUniqueWithoutMenusInput[]
    createMany?: menusCreateManyMenusInputEnvelope
    set?: menusWhereUniqueInput | menusWhereUniqueInput[]
    disconnect?: menusWhereUniqueInput | menusWhereUniqueInput[]
    delete?: menusWhereUniqueInput | menusWhereUniqueInput[]
    connect?: menusWhereUniqueInput | menusWhereUniqueInput[]
    update?: menusUpdateWithWhereUniqueWithoutMenusInput | menusUpdateWithWhereUniqueWithoutMenusInput[]
    updateMany?: menusUpdateManyWithWhereWithoutMenusInput | menusUpdateManyWithWhereWithoutMenusInput[]
    deleteMany?: menusScalarWhereInput | menusScalarWhereInput[]
  }

  export type menusUncheckedUpdateManyWithoutMenusNestedInput = {
    create?: XOR<menusCreateWithoutMenusInput, menusUncheckedCreateWithoutMenusInput> | menusCreateWithoutMenusInput[] | menusUncheckedCreateWithoutMenusInput[]
    connectOrCreate?: menusCreateOrConnectWithoutMenusInput | menusCreateOrConnectWithoutMenusInput[]
    upsert?: menusUpsertWithWhereUniqueWithoutMenusInput | menusUpsertWithWhereUniqueWithoutMenusInput[]
    createMany?: menusCreateManyMenusInputEnvelope
    set?: menusWhereUniqueInput | menusWhereUniqueInput[]
    disconnect?: menusWhereUniqueInput | menusWhereUniqueInput[]
    delete?: menusWhereUniqueInput | menusWhereUniqueInput[]
    connect?: menusWhereUniqueInput | menusWhereUniqueInput[]
    update?: menusUpdateWithWhereUniqueWithoutMenusInput | menusUpdateWithWhereUniqueWithoutMenusInput[]
    updateMany?: menusUpdateManyWithWhereWithoutMenusInput | menusUpdateManyWithWhereWithoutMenusInput[]
    deleteMany?: menusScalarWhereInput | menusScalarWhereInput[]
  }

  export type categoriesCreateNestedOneWithoutOffer_categoryInput = {
    create?: XOR<categoriesCreateWithoutOffer_categoryInput, categoriesUncheckedCreateWithoutOffer_categoryInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutOffer_categoryInput
    connect?: categoriesWhereUniqueInput
  }

  export type offersCreateNestedOneWithoutOffer_categoryInput = {
    create?: XOR<offersCreateWithoutOffer_categoryInput, offersUncheckedCreateWithoutOffer_categoryInput>
    connectOrCreate?: offersCreateOrConnectWithoutOffer_categoryInput
    connect?: offersWhereUniqueInput
  }

  export type categoriesUpdateOneRequiredWithoutOffer_categoryNestedInput = {
    create?: XOR<categoriesCreateWithoutOffer_categoryInput, categoriesUncheckedCreateWithoutOffer_categoryInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutOffer_categoryInput
    upsert?: categoriesUpsertWithoutOffer_categoryInput
    connect?: categoriesWhereUniqueInput
    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutOffer_categoryInput, categoriesUpdateWithoutOffer_categoryInput>, categoriesUncheckedUpdateWithoutOffer_categoryInput>
  }

  export type offersUpdateOneRequiredWithoutOffer_categoryNestedInput = {
    create?: XOR<offersCreateWithoutOffer_categoryInput, offersUncheckedCreateWithoutOffer_categoryInput>
    connectOrCreate?: offersCreateOrConnectWithoutOffer_categoryInput
    upsert?: offersUpsertWithoutOffer_categoryInput
    connect?: offersWhereUniqueInput
    update?: XOR<XOR<offersUpdateToOneWithWhereWithoutOffer_categoryInput, offersUpdateWithoutOffer_categoryInput>, offersUncheckedUpdateWithoutOffer_categoryInput>
  }

  export type offer_categoryCreateNestedManyWithoutOffersInput = {
    create?: XOR<offer_categoryCreateWithoutOffersInput, offer_categoryUncheckedCreateWithoutOffersInput> | offer_categoryCreateWithoutOffersInput[] | offer_categoryUncheckedCreateWithoutOffersInput[]
    connectOrCreate?: offer_categoryCreateOrConnectWithoutOffersInput | offer_categoryCreateOrConnectWithoutOffersInput[]
    createMany?: offer_categoryCreateManyOffersInputEnvelope
    connect?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
  }

  export type categoriesCreateNestedOneWithoutOffersInput = {
    create?: XOR<categoriesCreateWithoutOffersInput, categoriesUncheckedCreateWithoutOffersInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutOffersInput
    connect?: categoriesWhereUniqueInput
  }

  export type companiesCreateNestedOneWithoutOffersInput = {
    create?: XOR<companiesCreateWithoutOffersInput, companiesUncheckedCreateWithoutOffersInput>
    connectOrCreate?: companiesCreateOrConnectWithoutOffersInput
    connect?: companiesWhereUniqueInput
  }

  export type storesCreateNestedOneWithoutOffersInput = {
    create?: XOR<storesCreateWithoutOffersInput, storesUncheckedCreateWithoutOffersInput>
    connectOrCreate?: storesCreateOrConnectWithoutOffersInput
    connect?: storesWhereUniqueInput
  }

  export type offer_categoryUncheckedCreateNestedManyWithoutOffersInput = {
    create?: XOR<offer_categoryCreateWithoutOffersInput, offer_categoryUncheckedCreateWithoutOffersInput> | offer_categoryCreateWithoutOffersInput[] | offer_categoryUncheckedCreateWithoutOffersInput[]
    connectOrCreate?: offer_categoryCreateOrConnectWithoutOffersInput | offer_categoryCreateOrConnectWithoutOffersInput[]
    createMany?: offer_categoryCreateManyOffersInputEnvelope
    connect?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type Enumoffers_typeFieldUpdateOperationsInput = {
    set?: $Enums.offers_type
  }

  export type offer_categoryUpdateManyWithoutOffersNestedInput = {
    create?: XOR<offer_categoryCreateWithoutOffersInput, offer_categoryUncheckedCreateWithoutOffersInput> | offer_categoryCreateWithoutOffersInput[] | offer_categoryUncheckedCreateWithoutOffersInput[]
    connectOrCreate?: offer_categoryCreateOrConnectWithoutOffersInput | offer_categoryCreateOrConnectWithoutOffersInput[]
    upsert?: offer_categoryUpsertWithWhereUniqueWithoutOffersInput | offer_categoryUpsertWithWhereUniqueWithoutOffersInput[]
    createMany?: offer_categoryCreateManyOffersInputEnvelope
    set?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
    disconnect?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
    delete?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
    connect?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
    update?: offer_categoryUpdateWithWhereUniqueWithoutOffersInput | offer_categoryUpdateWithWhereUniqueWithoutOffersInput[]
    updateMany?: offer_categoryUpdateManyWithWhereWithoutOffersInput | offer_categoryUpdateManyWithWhereWithoutOffersInput[]
    deleteMany?: offer_categoryScalarWhereInput | offer_categoryScalarWhereInput[]
  }

  export type categoriesUpdateOneWithoutOffersNestedInput = {
    create?: XOR<categoriesCreateWithoutOffersInput, categoriesUncheckedCreateWithoutOffersInput>
    connectOrCreate?: categoriesCreateOrConnectWithoutOffersInput
    upsert?: categoriesUpsertWithoutOffersInput
    disconnect?: categoriesWhereInput | boolean
    delete?: categoriesWhereInput | boolean
    connect?: categoriesWhereUniqueInput
    update?: XOR<XOR<categoriesUpdateToOneWithWhereWithoutOffersInput, categoriesUpdateWithoutOffersInput>, categoriesUncheckedUpdateWithoutOffersInput>
  }

  export type companiesUpdateOneRequiredWithoutOffersNestedInput = {
    create?: XOR<companiesCreateWithoutOffersInput, companiesUncheckedCreateWithoutOffersInput>
    connectOrCreate?: companiesCreateOrConnectWithoutOffersInput
    upsert?: companiesUpsertWithoutOffersInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutOffersInput, companiesUpdateWithoutOffersInput>, companiesUncheckedUpdateWithoutOffersInput>
  }

  export type storesUpdateOneRequiredWithoutOffersNestedInput = {
    create?: XOR<storesCreateWithoutOffersInput, storesUncheckedCreateWithoutOffersInput>
    connectOrCreate?: storesCreateOrConnectWithoutOffersInput
    upsert?: storesUpsertWithoutOffersInput
    connect?: storesWhereUniqueInput
    update?: XOR<XOR<storesUpdateToOneWithWhereWithoutOffersInput, storesUpdateWithoutOffersInput>, storesUncheckedUpdateWithoutOffersInput>
  }

  export type offer_categoryUncheckedUpdateManyWithoutOffersNestedInput = {
    create?: XOR<offer_categoryCreateWithoutOffersInput, offer_categoryUncheckedCreateWithoutOffersInput> | offer_categoryCreateWithoutOffersInput[] | offer_categoryUncheckedCreateWithoutOffersInput[]
    connectOrCreate?: offer_categoryCreateOrConnectWithoutOffersInput | offer_categoryCreateOrConnectWithoutOffersInput[]
    upsert?: offer_categoryUpsertWithWhereUniqueWithoutOffersInput | offer_categoryUpsertWithWhereUniqueWithoutOffersInput[]
    createMany?: offer_categoryCreateManyOffersInputEnvelope
    set?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
    disconnect?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
    delete?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
    connect?: offer_categoryWhereUniqueInput | offer_categoryWhereUniqueInput[]
    update?: offer_categoryUpdateWithWhereUniqueWithoutOffersInput | offer_categoryUpdateWithWhereUniqueWithoutOffersInput[]
    updateMany?: offer_categoryUpdateManyWithWhereWithoutOffersInput | offer_categoryUpdateManyWithWhereWithoutOffersInput[]
    deleteMany?: offer_categoryScalarWhereInput | offer_categoryScalarWhereInput[]
  }

  export type company_subscriptionsCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<company_subscriptionsCreateWithoutPaymentsInput, company_subscriptionsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: company_subscriptionsCreateOrConnectWithoutPaymentsInput
    connect?: company_subscriptionsWhereUniqueInput
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type company_subscriptionsUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<company_subscriptionsCreateWithoutPaymentsInput, company_subscriptionsUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: company_subscriptionsCreateOrConnectWithoutPaymentsInput
    upsert?: company_subscriptionsUpsertWithoutPaymentsInput
    connect?: company_subscriptionsWhereUniqueInput
    update?: XOR<XOR<company_subscriptionsUpdateToOneWithWhereWithoutPaymentsInput, company_subscriptionsUpdateWithoutPaymentsInput>, company_subscriptionsUncheckedUpdateWithoutPaymentsInput>
  }

  export type offersCreateNestedManyWithoutStoresInput = {
    create?: XOR<offersCreateWithoutStoresInput, offersUncheckedCreateWithoutStoresInput> | offersCreateWithoutStoresInput[] | offersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: offersCreateOrConnectWithoutStoresInput | offersCreateOrConnectWithoutStoresInput[]
    createMany?: offersCreateManyStoresInputEnvelope
    connect?: offersWhereUniqueInput | offersWhereUniqueInput[]
  }

  export type companiesCreateNestedOneWithoutStoresInput = {
    create?: XOR<companiesCreateWithoutStoresInput, companiesUncheckedCreateWithoutStoresInput>
    connectOrCreate?: companiesCreateOrConnectWithoutStoresInput
    connect?: companiesWhereUniqueInput
  }

  export type offersUncheckedCreateNestedManyWithoutStoresInput = {
    create?: XOR<offersCreateWithoutStoresInput, offersUncheckedCreateWithoutStoresInput> | offersCreateWithoutStoresInput[] | offersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: offersCreateOrConnectWithoutStoresInput | offersCreateOrConnectWithoutStoresInput[]
    createMany?: offersCreateManyStoresInputEnvelope
    connect?: offersWhereUniqueInput | offersWhereUniqueInput[]
  }

  export type offersUpdateManyWithoutStoresNestedInput = {
    create?: XOR<offersCreateWithoutStoresInput, offersUncheckedCreateWithoutStoresInput> | offersCreateWithoutStoresInput[] | offersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: offersCreateOrConnectWithoutStoresInput | offersCreateOrConnectWithoutStoresInput[]
    upsert?: offersUpsertWithWhereUniqueWithoutStoresInput | offersUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: offersCreateManyStoresInputEnvelope
    set?: offersWhereUniqueInput | offersWhereUniqueInput[]
    disconnect?: offersWhereUniqueInput | offersWhereUniqueInput[]
    delete?: offersWhereUniqueInput | offersWhereUniqueInput[]
    connect?: offersWhereUniqueInput | offersWhereUniqueInput[]
    update?: offersUpdateWithWhereUniqueWithoutStoresInput | offersUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: offersUpdateManyWithWhereWithoutStoresInput | offersUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: offersScalarWhereInput | offersScalarWhereInput[]
  }

  export type companiesUpdateOneRequiredWithoutStoresNestedInput = {
    create?: XOR<companiesCreateWithoutStoresInput, companiesUncheckedCreateWithoutStoresInput>
    connectOrCreate?: companiesCreateOrConnectWithoutStoresInput
    upsert?: companiesUpsertWithoutStoresInput
    connect?: companiesWhereUniqueInput
    update?: XOR<XOR<companiesUpdateToOneWithWhereWithoutStoresInput, companiesUpdateWithoutStoresInput>, companiesUncheckedUpdateWithoutStoresInput>
  }

  export type offersUncheckedUpdateManyWithoutStoresNestedInput = {
    create?: XOR<offersCreateWithoutStoresInput, offersUncheckedCreateWithoutStoresInput> | offersCreateWithoutStoresInput[] | offersUncheckedCreateWithoutStoresInput[]
    connectOrCreate?: offersCreateOrConnectWithoutStoresInput | offersCreateOrConnectWithoutStoresInput[]
    upsert?: offersUpsertWithWhereUniqueWithoutStoresInput | offersUpsertWithWhereUniqueWithoutStoresInput[]
    createMany?: offersCreateManyStoresInputEnvelope
    set?: offersWhereUniqueInput | offersWhereUniqueInput[]
    disconnect?: offersWhereUniqueInput | offersWhereUniqueInput[]
    delete?: offersWhereUniqueInput | offersWhereUniqueInput[]
    connect?: offersWhereUniqueInput | offersWhereUniqueInput[]
    update?: offersUpdateWithWhereUniqueWithoutStoresInput | offersUpdateWithWhereUniqueWithoutStoresInput[]
    updateMany?: offersUpdateManyWithWhereWithoutStoresInput | offersUpdateManyWithWhereWithoutStoresInput[]
    deleteMany?: offersScalarWhereInput | offersScalarWhereInput[]
  }

  export type company_subscriptionsCreateNestedManyWithoutSubscriptionsInput = {
    create?: XOR<company_subscriptionsCreateWithoutSubscriptionsInput, company_subscriptionsUncheckedCreateWithoutSubscriptionsInput> | company_subscriptionsCreateWithoutSubscriptionsInput[] | company_subscriptionsUncheckedCreateWithoutSubscriptionsInput[]
    connectOrCreate?: company_subscriptionsCreateOrConnectWithoutSubscriptionsInput | company_subscriptionsCreateOrConnectWithoutSubscriptionsInput[]
    createMany?: company_subscriptionsCreateManySubscriptionsInputEnvelope
    connect?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
  }

  export type company_subscriptionsUncheckedCreateNestedManyWithoutSubscriptionsInput = {
    create?: XOR<company_subscriptionsCreateWithoutSubscriptionsInput, company_subscriptionsUncheckedCreateWithoutSubscriptionsInput> | company_subscriptionsCreateWithoutSubscriptionsInput[] | company_subscriptionsUncheckedCreateWithoutSubscriptionsInput[]
    connectOrCreate?: company_subscriptionsCreateOrConnectWithoutSubscriptionsInput | company_subscriptionsCreateOrConnectWithoutSubscriptionsInput[]
    createMany?: company_subscriptionsCreateManySubscriptionsInputEnvelope
    connect?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
  }

  export type company_subscriptionsUpdateManyWithoutSubscriptionsNestedInput = {
    create?: XOR<company_subscriptionsCreateWithoutSubscriptionsInput, company_subscriptionsUncheckedCreateWithoutSubscriptionsInput> | company_subscriptionsCreateWithoutSubscriptionsInput[] | company_subscriptionsUncheckedCreateWithoutSubscriptionsInput[]
    connectOrCreate?: company_subscriptionsCreateOrConnectWithoutSubscriptionsInput | company_subscriptionsCreateOrConnectWithoutSubscriptionsInput[]
    upsert?: company_subscriptionsUpsertWithWhereUniqueWithoutSubscriptionsInput | company_subscriptionsUpsertWithWhereUniqueWithoutSubscriptionsInput[]
    createMany?: company_subscriptionsCreateManySubscriptionsInputEnvelope
    set?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
    disconnect?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
    delete?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
    connect?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
    update?: company_subscriptionsUpdateWithWhereUniqueWithoutSubscriptionsInput | company_subscriptionsUpdateWithWhereUniqueWithoutSubscriptionsInput[]
    updateMany?: company_subscriptionsUpdateManyWithWhereWithoutSubscriptionsInput | company_subscriptionsUpdateManyWithWhereWithoutSubscriptionsInput[]
    deleteMany?: company_subscriptionsScalarWhereInput | company_subscriptionsScalarWhereInput[]
  }

  export type company_subscriptionsUncheckedUpdateManyWithoutSubscriptionsNestedInput = {
    create?: XOR<company_subscriptionsCreateWithoutSubscriptionsInput, company_subscriptionsUncheckedCreateWithoutSubscriptionsInput> | company_subscriptionsCreateWithoutSubscriptionsInput[] | company_subscriptionsUncheckedCreateWithoutSubscriptionsInput[]
    connectOrCreate?: company_subscriptionsCreateOrConnectWithoutSubscriptionsInput | company_subscriptionsCreateOrConnectWithoutSubscriptionsInput[]
    upsert?: company_subscriptionsUpsertWithWhereUniqueWithoutSubscriptionsInput | company_subscriptionsUpsertWithWhereUniqueWithoutSubscriptionsInput[]
    createMany?: company_subscriptionsCreateManySubscriptionsInputEnvelope
    set?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
    disconnect?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
    delete?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
    connect?: company_subscriptionsWhereUniqueInput | company_subscriptionsWhereUniqueInput[]
    update?: company_subscriptionsUpdateWithWhereUniqueWithoutSubscriptionsInput | company_subscriptionsUpdateWithWhereUniqueWithoutSubscriptionsInput[]
    updateMany?: company_subscriptionsUpdateManyWithWhereWithoutSubscriptionsInput | company_subscriptionsUpdateManyWithWhereWithoutSubscriptionsInput[]
    deleteMany?: company_subscriptionsScalarWhereInput | company_subscriptionsScalarWhereInput[]
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[]
    notIn?: bigint[] | number[]
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | null
    notIn?: bigint[] | number[] | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    search?: string
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumoffers_typeFilter<$PrismaModel = never> = {
    equals?: $Enums.offers_type | Enumoffers_typeFieldRefInput<$PrismaModel>
    in?: $Enums.offers_type[]
    notIn?: $Enums.offers_type[]
    not?: NestedEnumoffers_typeFilter<$PrismaModel> | $Enums.offers_type
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumoffers_typeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.offers_type | Enumoffers_typeFieldRefInput<$PrismaModel>
    in?: $Enums.offers_type[]
    notIn?: $Enums.offers_type[]
    not?: NestedEnumoffers_typeWithAggregatesFilter<$PrismaModel> | $Enums.offers_type
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumoffers_typeFilter<$PrismaModel>
    _max?: NestedEnumoffers_typeFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type permissionsCreateWithoutModel_has_permissionsInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    role_has_permissions?: role_has_permissionsCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsUncheckedCreateWithoutModel_has_permissionsInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    role_has_permissions?: role_has_permissionsUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsCreateOrConnectWithoutModel_has_permissionsInput = {
    where: permissionsWhereUniqueInput
    create: XOR<permissionsCreateWithoutModel_has_permissionsInput, permissionsUncheckedCreateWithoutModel_has_permissionsInput>
  }

  export type permissionsUpsertWithoutModel_has_permissionsInput = {
    update: XOR<permissionsUpdateWithoutModel_has_permissionsInput, permissionsUncheckedUpdateWithoutModel_has_permissionsInput>
    create: XOR<permissionsCreateWithoutModel_has_permissionsInput, permissionsUncheckedCreateWithoutModel_has_permissionsInput>
    where?: permissionsWhereInput
  }

  export type permissionsUpdateToOneWithWhereWithoutModel_has_permissionsInput = {
    where?: permissionsWhereInput
    data: XOR<permissionsUpdateWithoutModel_has_permissionsInput, permissionsUncheckedUpdateWithoutModel_has_permissionsInput>
  }

  export type permissionsUpdateWithoutModel_has_permissionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_has_permissions?: role_has_permissionsUpdateManyWithoutPermissionsNestedInput
  }

  export type permissionsUncheckedUpdateWithoutModel_has_permissionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_has_permissions?: role_has_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type rolesCreateWithoutModel_has_rolesInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    role_has_permissions?: role_has_permissionsCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateWithoutModel_has_rolesInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    role_has_permissions?: role_has_permissionsUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesCreateOrConnectWithoutModel_has_rolesInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutModel_has_rolesInput, rolesUncheckedCreateWithoutModel_has_rolesInput>
  }

  export type rolesUpsertWithoutModel_has_rolesInput = {
    update: XOR<rolesUpdateWithoutModel_has_rolesInput, rolesUncheckedUpdateWithoutModel_has_rolesInput>
    create: XOR<rolesCreateWithoutModel_has_rolesInput, rolesUncheckedCreateWithoutModel_has_rolesInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutModel_has_rolesInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutModel_has_rolesInput, rolesUncheckedUpdateWithoutModel_has_rolesInput>
  }

  export type rolesUpdateWithoutModel_has_rolesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_has_permissions?: role_has_permissionsUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateWithoutModel_has_rolesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role_has_permissions?: role_has_permissionsUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type model_has_permissionsCreateWithoutPermissionsInput = {
    model_type: string
    model_id: bigint | number
  }

  export type model_has_permissionsUncheckedCreateWithoutPermissionsInput = {
    model_type: string
    model_id: bigint | number
  }

  export type model_has_permissionsCreateOrConnectWithoutPermissionsInput = {
    where: model_has_permissionsWhereUniqueInput
    create: XOR<model_has_permissionsCreateWithoutPermissionsInput, model_has_permissionsUncheckedCreateWithoutPermissionsInput>
  }

  export type model_has_permissionsCreateManyPermissionsInputEnvelope = {
    data: model_has_permissionsCreateManyPermissionsInput | model_has_permissionsCreateManyPermissionsInput[]
    skipDuplicates?: boolean
  }

  export type role_has_permissionsCreateWithoutPermissionsInput = {
    roles: rolesCreateNestedOneWithoutRole_has_permissionsInput
  }

  export type role_has_permissionsUncheckedCreateWithoutPermissionsInput = {
    role_id: bigint | number
  }

  export type role_has_permissionsCreateOrConnectWithoutPermissionsInput = {
    where: role_has_permissionsWhereUniqueInput
    create: XOR<role_has_permissionsCreateWithoutPermissionsInput, role_has_permissionsUncheckedCreateWithoutPermissionsInput>
  }

  export type role_has_permissionsCreateManyPermissionsInputEnvelope = {
    data: role_has_permissionsCreateManyPermissionsInput | role_has_permissionsCreateManyPermissionsInput[]
    skipDuplicates?: boolean
  }

  export type model_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput = {
    where: model_has_permissionsWhereUniqueInput
    update: XOR<model_has_permissionsUpdateWithoutPermissionsInput, model_has_permissionsUncheckedUpdateWithoutPermissionsInput>
    create: XOR<model_has_permissionsCreateWithoutPermissionsInput, model_has_permissionsUncheckedCreateWithoutPermissionsInput>
  }

  export type model_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput = {
    where: model_has_permissionsWhereUniqueInput
    data: XOR<model_has_permissionsUpdateWithoutPermissionsInput, model_has_permissionsUncheckedUpdateWithoutPermissionsInput>
  }

  export type model_has_permissionsUpdateManyWithWhereWithoutPermissionsInput = {
    where: model_has_permissionsScalarWhereInput
    data: XOR<model_has_permissionsUpdateManyMutationInput, model_has_permissionsUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type model_has_permissionsScalarWhereInput = {
    AND?: model_has_permissionsScalarWhereInput | model_has_permissionsScalarWhereInput[]
    OR?: model_has_permissionsScalarWhereInput[]
    NOT?: model_has_permissionsScalarWhereInput | model_has_permissionsScalarWhereInput[]
    permission_id?: BigIntFilter<"model_has_permissions"> | bigint | number
    model_type?: StringFilter<"model_has_permissions"> | string
    model_id?: BigIntFilter<"model_has_permissions"> | bigint | number
  }

  export type role_has_permissionsUpsertWithWhereUniqueWithoutPermissionsInput = {
    where: role_has_permissionsWhereUniqueInput
    update: XOR<role_has_permissionsUpdateWithoutPermissionsInput, role_has_permissionsUncheckedUpdateWithoutPermissionsInput>
    create: XOR<role_has_permissionsCreateWithoutPermissionsInput, role_has_permissionsUncheckedCreateWithoutPermissionsInput>
  }

  export type role_has_permissionsUpdateWithWhereUniqueWithoutPermissionsInput = {
    where: role_has_permissionsWhereUniqueInput
    data: XOR<role_has_permissionsUpdateWithoutPermissionsInput, role_has_permissionsUncheckedUpdateWithoutPermissionsInput>
  }

  export type role_has_permissionsUpdateManyWithWhereWithoutPermissionsInput = {
    where: role_has_permissionsScalarWhereInput
    data: XOR<role_has_permissionsUpdateManyMutationInput, role_has_permissionsUncheckedUpdateManyWithoutPermissionsInput>
  }

  export type role_has_permissionsScalarWhereInput = {
    AND?: role_has_permissionsScalarWhereInput | role_has_permissionsScalarWhereInput[]
    OR?: role_has_permissionsScalarWhereInput[]
    NOT?: role_has_permissionsScalarWhereInput | role_has_permissionsScalarWhereInput[]
    permission_id?: BigIntFilter<"role_has_permissions"> | bigint | number
    role_id?: BigIntFilter<"role_has_permissions"> | bigint | number
  }

  export type permissionsCreateWithoutRole_has_permissionsInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    model_has_permissions?: model_has_permissionsCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsUncheckedCreateWithoutRole_has_permissionsInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    model_has_permissions?: model_has_permissionsUncheckedCreateNestedManyWithoutPermissionsInput
  }

  export type permissionsCreateOrConnectWithoutRole_has_permissionsInput = {
    where: permissionsWhereUniqueInput
    create: XOR<permissionsCreateWithoutRole_has_permissionsInput, permissionsUncheckedCreateWithoutRole_has_permissionsInput>
  }

  export type rolesCreateWithoutRole_has_permissionsInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    model_has_roles?: model_has_rolesCreateNestedManyWithoutRolesInput
  }

  export type rolesUncheckedCreateWithoutRole_has_permissionsInput = {
    id?: bigint | number
    name: string
    guard_name: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    model_has_roles?: model_has_rolesUncheckedCreateNestedManyWithoutRolesInput
  }

  export type rolesCreateOrConnectWithoutRole_has_permissionsInput = {
    where: rolesWhereUniqueInput
    create: XOR<rolesCreateWithoutRole_has_permissionsInput, rolesUncheckedCreateWithoutRole_has_permissionsInput>
  }

  export type permissionsUpsertWithoutRole_has_permissionsInput = {
    update: XOR<permissionsUpdateWithoutRole_has_permissionsInput, permissionsUncheckedUpdateWithoutRole_has_permissionsInput>
    create: XOR<permissionsCreateWithoutRole_has_permissionsInput, permissionsUncheckedCreateWithoutRole_has_permissionsInput>
    where?: permissionsWhereInput
  }

  export type permissionsUpdateToOneWithWhereWithoutRole_has_permissionsInput = {
    where?: permissionsWhereInput
    data: XOR<permissionsUpdateWithoutRole_has_permissionsInput, permissionsUncheckedUpdateWithoutRole_has_permissionsInput>
  }

  export type permissionsUpdateWithoutRole_has_permissionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_has_permissions?: model_has_permissionsUpdateManyWithoutPermissionsNestedInput
  }

  export type permissionsUncheckedUpdateWithoutRole_has_permissionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_has_permissions?: model_has_permissionsUncheckedUpdateManyWithoutPermissionsNestedInput
  }

  export type rolesUpsertWithoutRole_has_permissionsInput = {
    update: XOR<rolesUpdateWithoutRole_has_permissionsInput, rolesUncheckedUpdateWithoutRole_has_permissionsInput>
    create: XOR<rolesCreateWithoutRole_has_permissionsInput, rolesUncheckedCreateWithoutRole_has_permissionsInput>
    where?: rolesWhereInput
  }

  export type rolesUpdateToOneWithWhereWithoutRole_has_permissionsInput = {
    where?: rolesWhereInput
    data: XOR<rolesUpdateWithoutRole_has_permissionsInput, rolesUncheckedUpdateWithoutRole_has_permissionsInput>
  }

  export type rolesUpdateWithoutRole_has_permissionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_has_roles?: model_has_rolesUpdateManyWithoutRolesNestedInput
  }

  export type rolesUncheckedUpdateWithoutRole_has_permissionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    guard_name?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    model_has_roles?: model_has_rolesUncheckedUpdateManyWithoutRolesNestedInput
  }

  export type model_has_rolesCreateWithoutRolesInput = {
    model_type: string
    model_id: bigint | number
  }

  export type model_has_rolesUncheckedCreateWithoutRolesInput = {
    model_type: string
    model_id: bigint | number
  }

  export type model_has_rolesCreateOrConnectWithoutRolesInput = {
    where: model_has_rolesWhereUniqueInput
    create: XOR<model_has_rolesCreateWithoutRolesInput, model_has_rolesUncheckedCreateWithoutRolesInput>
  }

  export type model_has_rolesCreateManyRolesInputEnvelope = {
    data: model_has_rolesCreateManyRolesInput | model_has_rolesCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type role_has_permissionsCreateWithoutRolesInput = {
    permissions: permissionsCreateNestedOneWithoutRole_has_permissionsInput
  }

  export type role_has_permissionsUncheckedCreateWithoutRolesInput = {
    permission_id: bigint | number
  }

  export type role_has_permissionsCreateOrConnectWithoutRolesInput = {
    where: role_has_permissionsWhereUniqueInput
    create: XOR<role_has_permissionsCreateWithoutRolesInput, role_has_permissionsUncheckedCreateWithoutRolesInput>
  }

  export type role_has_permissionsCreateManyRolesInputEnvelope = {
    data: role_has_permissionsCreateManyRolesInput | role_has_permissionsCreateManyRolesInput[]
    skipDuplicates?: boolean
  }

  export type model_has_rolesUpsertWithWhereUniqueWithoutRolesInput = {
    where: model_has_rolesWhereUniqueInput
    update: XOR<model_has_rolesUpdateWithoutRolesInput, model_has_rolesUncheckedUpdateWithoutRolesInput>
    create: XOR<model_has_rolesCreateWithoutRolesInput, model_has_rolesUncheckedCreateWithoutRolesInput>
  }

  export type model_has_rolesUpdateWithWhereUniqueWithoutRolesInput = {
    where: model_has_rolesWhereUniqueInput
    data: XOR<model_has_rolesUpdateWithoutRolesInput, model_has_rolesUncheckedUpdateWithoutRolesInput>
  }

  export type model_has_rolesUpdateManyWithWhereWithoutRolesInput = {
    where: model_has_rolesScalarWhereInput
    data: XOR<model_has_rolesUpdateManyMutationInput, model_has_rolesUncheckedUpdateManyWithoutRolesInput>
  }

  export type model_has_rolesScalarWhereInput = {
    AND?: model_has_rolesScalarWhereInput | model_has_rolesScalarWhereInput[]
    OR?: model_has_rolesScalarWhereInput[]
    NOT?: model_has_rolesScalarWhereInput | model_has_rolesScalarWhereInput[]
    role_id?: BigIntFilter<"model_has_roles"> | bigint | number
    model_type?: StringFilter<"model_has_roles"> | string
    model_id?: BigIntFilter<"model_has_roles"> | bigint | number
  }

  export type role_has_permissionsUpsertWithWhereUniqueWithoutRolesInput = {
    where: role_has_permissionsWhereUniqueInput
    update: XOR<role_has_permissionsUpdateWithoutRolesInput, role_has_permissionsUncheckedUpdateWithoutRolesInput>
    create: XOR<role_has_permissionsCreateWithoutRolesInput, role_has_permissionsUncheckedCreateWithoutRolesInput>
  }

  export type role_has_permissionsUpdateWithWhereUniqueWithoutRolesInput = {
    where: role_has_permissionsWhereUniqueInput
    data: XOR<role_has_permissionsUpdateWithoutRolesInput, role_has_permissionsUncheckedUpdateWithoutRolesInput>
  }

  export type role_has_permissionsUpdateManyWithWhereWithoutRolesInput = {
    where: role_has_permissionsScalarWhereInput
    data: XOR<role_has_permissionsUpdateManyMutationInput, role_has_permissionsUncheckedUpdateManyWithoutRolesInput>
  }

  export type companiesCreateWithoutUsersInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutCompaniesInput
    company_frontend_settings?: company_frontend_settingsCreateNestedManyWithoutCompaniesInput
    company_integrations?: company_integrationsCreateNestedManyWithoutCompaniesInput
    company_profiles?: company_profilesCreateNestedManyWithoutCompaniesInput
    company_subscriptions?: company_subscriptionsCreateNestedManyWithoutCompaniesInput
    integration_category_mappings?: integration_category_mappingsCreateNestedManyWithoutCompaniesInput
    offers?: offersCreateNestedManyWithoutCompaniesInput
    stores?: storesCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutUsersInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutCompaniesInput
    company_frontend_settings?: company_frontend_settingsUncheckedCreateNestedManyWithoutCompaniesInput
    company_integrations?: company_integrationsUncheckedCreateNestedManyWithoutCompaniesInput
    company_profiles?: company_profilesUncheckedCreateNestedManyWithoutCompaniesInput
    company_subscriptions?: company_subscriptionsUncheckedCreateNestedManyWithoutCompaniesInput
    integration_category_mappings?: integration_category_mappingsUncheckedCreateNestedManyWithoutCompaniesInput
    offers?: offersUncheckedCreateNestedManyWithoutCompaniesInput
    stores?: storesUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutUsersInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutUsersInput, companiesUncheckedCreateWithoutUsersInput>
  }

  export type companiesUpsertWithoutUsersInput = {
    update: XOR<companiesUpdateWithoutUsersInput, companiesUncheckedUpdateWithoutUsersInput>
    create: XOR<companiesCreateWithoutUsersInput, companiesUncheckedCreateWithoutUsersInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutUsersInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutUsersInput, companiesUncheckedUpdateWithoutUsersInput>
  }

  export type companiesUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutCompaniesNestedInput
    company_frontend_settings?: company_frontend_settingsUpdateManyWithoutCompaniesNestedInput
    company_integrations?: company_integrationsUpdateManyWithoutCompaniesNestedInput
    company_profiles?: company_profilesUpdateManyWithoutCompaniesNestedInput
    company_subscriptions?: company_subscriptionsUpdateManyWithoutCompaniesNestedInput
    integration_category_mappings?: integration_category_mappingsUpdateManyWithoutCompaniesNestedInput
    offers?: offersUpdateManyWithoutCompaniesNestedInput
    stores?: storesUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutUsersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutCompaniesNestedInput
    company_frontend_settings?: company_frontend_settingsUncheckedUpdateManyWithoutCompaniesNestedInput
    company_integrations?: company_integrationsUncheckedUpdateManyWithoutCompaniesNestedInput
    company_profiles?: company_profilesUncheckedUpdateManyWithoutCompaniesNestedInput
    company_subscriptions?: company_subscriptionsUncheckedUpdateManyWithoutCompaniesNestedInput
    integration_category_mappings?: integration_category_mappingsUncheckedUpdateManyWithoutCompaniesNestedInput
    offers?: offersUncheckedUpdateManyWithoutCompaniesNestedInput
    stores?: storesUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesCreateWithoutCategoriesInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    company_frontend_settings?: company_frontend_settingsCreateNestedManyWithoutCompaniesInput
    company_integrations?: company_integrationsCreateNestedManyWithoutCompaniesInput
    company_profiles?: company_profilesCreateNestedManyWithoutCompaniesInput
    company_subscriptions?: company_subscriptionsCreateNestedManyWithoutCompaniesInput
    integration_category_mappings?: integration_category_mappingsCreateNestedManyWithoutCompaniesInput
    offers?: offersCreateNestedManyWithoutCompaniesInput
    stores?: storesCreateNestedManyWithoutCompaniesInput
    users?: usersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutCategoriesInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    company_frontend_settings?: company_frontend_settingsUncheckedCreateNestedManyWithoutCompaniesInput
    company_integrations?: company_integrationsUncheckedCreateNestedManyWithoutCompaniesInput
    company_profiles?: company_profilesUncheckedCreateNestedManyWithoutCompaniesInput
    company_subscriptions?: company_subscriptionsUncheckedCreateNestedManyWithoutCompaniesInput
    integration_category_mappings?: integration_category_mappingsUncheckedCreateNestedManyWithoutCompaniesInput
    offers?: offersUncheckedCreateNestedManyWithoutCompaniesInput
    stores?: storesUncheckedCreateNestedManyWithoutCompaniesInput
    users?: usersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutCategoriesInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutCategoriesInput, companiesUncheckedCreateWithoutCategoriesInput>
  }

  export type categoriesCreateWithoutOther_categoriesInput = {
    id?: bigint | number
    name: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    companies: companiesCreateNestedOneWithoutCategoriesInput
    categories?: categoriesCreateNestedOneWithoutOther_categoriesInput
    integration_category_mappings?: integration_category_mappingsCreateNestedManyWithoutCategoriesInput
    offer_category?: offer_categoryCreateNestedManyWithoutCategoriesInput
    offers?: offersCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutOther_categoriesInput = {
    id?: bigint | number
    name: string
    parent_id?: bigint | number | null
    company_id: bigint | number
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    integration_category_mappings?: integration_category_mappingsUncheckedCreateNestedManyWithoutCategoriesInput
    offer_category?: offer_categoryUncheckedCreateNestedManyWithoutCategoriesInput
    offers?: offersUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutOther_categoriesInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutOther_categoriesInput, categoriesUncheckedCreateWithoutOther_categoriesInput>
  }

  export type categoriesCreateWithoutCategoriesInput = {
    id?: bigint | number
    name: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    companies: companiesCreateNestedOneWithoutCategoriesInput
    other_categories?: categoriesCreateNestedManyWithoutCategoriesInput
    integration_category_mappings?: integration_category_mappingsCreateNestedManyWithoutCategoriesInput
    offer_category?: offer_categoryCreateNestedManyWithoutCategoriesInput
    offers?: offersCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutCategoriesInput = {
    id?: bigint | number
    name: string
    company_id: bigint | number
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    other_categories?: categoriesUncheckedCreateNestedManyWithoutCategoriesInput
    integration_category_mappings?: integration_category_mappingsUncheckedCreateNestedManyWithoutCategoriesInput
    offer_category?: offer_categoryUncheckedCreateNestedManyWithoutCategoriesInput
    offers?: offersUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutCategoriesInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutCategoriesInput, categoriesUncheckedCreateWithoutCategoriesInput>
  }

  export type categoriesCreateManyCategoriesInputEnvelope = {
    data: categoriesCreateManyCategoriesInput | categoriesCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type integration_category_mappingsCreateWithoutCategoriesInput = {
    id?: bigint | number
    provider: string
    external_category: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    companies?: companiesCreateNestedOneWithoutIntegration_category_mappingsInput
  }

  export type integration_category_mappingsUncheckedCreateWithoutCategoriesInput = {
    id?: bigint | number
    company_id?: bigint | number | null
    provider: string
    external_category: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type integration_category_mappingsCreateOrConnectWithoutCategoriesInput = {
    where: integration_category_mappingsWhereUniqueInput
    create: XOR<integration_category_mappingsCreateWithoutCategoriesInput, integration_category_mappingsUncheckedCreateWithoutCategoriesInput>
  }

  export type integration_category_mappingsCreateManyCategoriesInputEnvelope = {
    data: integration_category_mappingsCreateManyCategoriesInput | integration_category_mappingsCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type offer_categoryCreateWithoutCategoriesInput = {
    id?: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    offers: offersCreateNestedOneWithoutOffer_categoryInput
  }

  export type offer_categoryUncheckedCreateWithoutCategoriesInput = {
    id?: bigint | number
    offer_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type offer_categoryCreateOrConnectWithoutCategoriesInput = {
    where: offer_categoryWhereUniqueInput
    create: XOR<offer_categoryCreateWithoutCategoriesInput, offer_categoryUncheckedCreateWithoutCategoriesInput>
  }

  export type offer_categoryCreateManyCategoriesInputEnvelope = {
    data: offer_categoryCreateManyCategoriesInput | offer_categoryCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type offersCreateWithoutCategoriesInput = {
    id?: bigint | number
    title: string
    description?: string | null
    product_url?: string | null
    image_url?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    code?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    link?: string | null
    is_featured?: boolean
    is_exclusive?: boolean
    is_deal?: boolean
    path?: string | null
    thumbnail?: string | null
    sku?: string | null
    product_name?: string | null
    product_price?: Decimal | DecimalJsLike | number | string | null
    old_price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    type?: $Enums.offers_type
    external_id?: string | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    offer_category?: offer_categoryCreateNestedManyWithoutOffersInput
    companies: companiesCreateNestedOneWithoutOffersInput
    stores: storesCreateNestedOneWithoutOffersInput
  }

  export type offersUncheckedCreateWithoutCategoriesInput = {
    id?: bigint | number
    company_id: bigint | number
    store_id: bigint | number
    title: string
    description?: string | null
    product_url?: string | null
    image_url?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    code?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    link?: string | null
    is_featured?: boolean
    is_exclusive?: boolean
    is_deal?: boolean
    path?: string | null
    thumbnail?: string | null
    sku?: string | null
    product_name?: string | null
    product_price?: Decimal | DecimalJsLike | number | string | null
    old_price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    type?: $Enums.offers_type
    external_id?: string | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    offer_category?: offer_categoryUncheckedCreateNestedManyWithoutOffersInput
  }

  export type offersCreateOrConnectWithoutCategoriesInput = {
    where: offersWhereUniqueInput
    create: XOR<offersCreateWithoutCategoriesInput, offersUncheckedCreateWithoutCategoriesInput>
  }

  export type offersCreateManyCategoriesInputEnvelope = {
    data: offersCreateManyCategoriesInput | offersCreateManyCategoriesInput[]
    skipDuplicates?: boolean
  }

  export type companiesUpsertWithoutCategoriesInput = {
    update: XOR<companiesUpdateWithoutCategoriesInput, companiesUncheckedUpdateWithoutCategoriesInput>
    create: XOR<companiesCreateWithoutCategoriesInput, companiesUncheckedCreateWithoutCategoriesInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutCategoriesInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutCategoriesInput, companiesUncheckedUpdateWithoutCategoriesInput>
  }

  export type companiesUpdateWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_frontend_settings?: company_frontend_settingsUpdateManyWithoutCompaniesNestedInput
    company_integrations?: company_integrationsUpdateManyWithoutCompaniesNestedInput
    company_profiles?: company_profilesUpdateManyWithoutCompaniesNestedInput
    company_subscriptions?: company_subscriptionsUpdateManyWithoutCompaniesNestedInput
    integration_category_mappings?: integration_category_mappingsUpdateManyWithoutCompaniesNestedInput
    offers?: offersUpdateManyWithoutCompaniesNestedInput
    stores?: storesUpdateManyWithoutCompaniesNestedInput
    users?: usersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    company_frontend_settings?: company_frontend_settingsUncheckedUpdateManyWithoutCompaniesNestedInput
    company_integrations?: company_integrationsUncheckedUpdateManyWithoutCompaniesNestedInput
    company_profiles?: company_profilesUncheckedUpdateManyWithoutCompaniesNestedInput
    company_subscriptions?: company_subscriptionsUncheckedUpdateManyWithoutCompaniesNestedInput
    integration_category_mappings?: integration_category_mappingsUncheckedUpdateManyWithoutCompaniesNestedInput
    offers?: offersUncheckedUpdateManyWithoutCompaniesNestedInput
    stores?: storesUncheckedUpdateManyWithoutCompaniesNestedInput
    users?: usersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type categoriesUpsertWithoutOther_categoriesInput = {
    update: XOR<categoriesUpdateWithoutOther_categoriesInput, categoriesUncheckedUpdateWithoutOther_categoriesInput>
    create: XOR<categoriesCreateWithoutOther_categoriesInput, categoriesUncheckedCreateWithoutOther_categoriesInput>
    where?: categoriesWhereInput
  }

  export type categoriesUpdateToOneWithWhereWithoutOther_categoriesInput = {
    where?: categoriesWhereInput
    data: XOR<categoriesUpdateWithoutOther_categoriesInput, categoriesUncheckedUpdateWithoutOther_categoriesInput>
  }

  export type categoriesUpdateWithoutOther_categoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutCategoriesNestedInput
    categories?: categoriesUpdateOneWithoutOther_categoriesNestedInput
    integration_category_mappings?: integration_category_mappingsUpdateManyWithoutCategoriesNestedInput
    offer_category?: offer_categoryUpdateManyWithoutCategoriesNestedInput
    offers?: offersUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutOther_categoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    integration_category_mappings?: integration_category_mappingsUncheckedUpdateManyWithoutCategoriesNestedInput
    offer_category?: offer_categoryUncheckedUpdateManyWithoutCategoriesNestedInput
    offers?: offersUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: categoriesWhereUniqueInput
    update: XOR<categoriesUpdateWithoutCategoriesInput, categoriesUncheckedUpdateWithoutCategoriesInput>
    create: XOR<categoriesCreateWithoutCategoriesInput, categoriesUncheckedCreateWithoutCategoriesInput>
  }

  export type categoriesUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: categoriesWhereUniqueInput
    data: XOR<categoriesUpdateWithoutCategoriesInput, categoriesUncheckedUpdateWithoutCategoriesInput>
  }

  export type categoriesUpdateManyWithWhereWithoutCategoriesInput = {
    where: categoriesScalarWhereInput
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type categoriesScalarWhereInput = {
    AND?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
    OR?: categoriesScalarWhereInput[]
    NOT?: categoriesScalarWhereInput | categoriesScalarWhereInput[]
    id?: BigIntFilter<"categories"> | bigint | number
    name?: StringFilter<"categories"> | string
    parent_id?: BigIntNullableFilter<"categories"> | bigint | number | null
    company_id?: BigIntFilter<"categories"> | bigint | number
    status?: BoolFilter<"categories"> | boolean
    created_at?: DateTimeNullableFilter<"categories"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"categories"> | Date | string | null
  }

  export type integration_category_mappingsUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: integration_category_mappingsWhereUniqueInput
    update: XOR<integration_category_mappingsUpdateWithoutCategoriesInput, integration_category_mappingsUncheckedUpdateWithoutCategoriesInput>
    create: XOR<integration_category_mappingsCreateWithoutCategoriesInput, integration_category_mappingsUncheckedCreateWithoutCategoriesInput>
  }

  export type integration_category_mappingsUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: integration_category_mappingsWhereUniqueInput
    data: XOR<integration_category_mappingsUpdateWithoutCategoriesInput, integration_category_mappingsUncheckedUpdateWithoutCategoriesInput>
  }

  export type integration_category_mappingsUpdateManyWithWhereWithoutCategoriesInput = {
    where: integration_category_mappingsScalarWhereInput
    data: XOR<integration_category_mappingsUpdateManyMutationInput, integration_category_mappingsUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type integration_category_mappingsScalarWhereInput = {
    AND?: integration_category_mappingsScalarWhereInput | integration_category_mappingsScalarWhereInput[]
    OR?: integration_category_mappingsScalarWhereInput[]
    NOT?: integration_category_mappingsScalarWhereInput | integration_category_mappingsScalarWhereInput[]
    id?: BigIntFilter<"integration_category_mappings"> | bigint | number
    company_id?: BigIntNullableFilter<"integration_category_mappings"> | bigint | number | null
    provider?: StringFilter<"integration_category_mappings"> | string
    external_category?: StringFilter<"integration_category_mappings"> | string
    category_id?: BigIntNullableFilter<"integration_category_mappings"> | bigint | number | null
    created_at?: DateTimeNullableFilter<"integration_category_mappings"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"integration_category_mappings"> | Date | string | null
  }

  export type offer_categoryUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: offer_categoryWhereUniqueInput
    update: XOR<offer_categoryUpdateWithoutCategoriesInput, offer_categoryUncheckedUpdateWithoutCategoriesInput>
    create: XOR<offer_categoryCreateWithoutCategoriesInput, offer_categoryUncheckedCreateWithoutCategoriesInput>
  }

  export type offer_categoryUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: offer_categoryWhereUniqueInput
    data: XOR<offer_categoryUpdateWithoutCategoriesInput, offer_categoryUncheckedUpdateWithoutCategoriesInput>
  }

  export type offer_categoryUpdateManyWithWhereWithoutCategoriesInput = {
    where: offer_categoryScalarWhereInput
    data: XOR<offer_categoryUpdateManyMutationInput, offer_categoryUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type offer_categoryScalarWhereInput = {
    AND?: offer_categoryScalarWhereInput | offer_categoryScalarWhereInput[]
    OR?: offer_categoryScalarWhereInput[]
    NOT?: offer_categoryScalarWhereInput | offer_categoryScalarWhereInput[]
    id?: BigIntFilter<"offer_category"> | bigint | number
    offer_id?: BigIntFilter<"offer_category"> | bigint | number
    category_id?: BigIntFilter<"offer_category"> | bigint | number
    created_at?: DateTimeNullableFilter<"offer_category"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"offer_category"> | Date | string | null
  }

  export type offersUpsertWithWhereUniqueWithoutCategoriesInput = {
    where: offersWhereUniqueInput
    update: XOR<offersUpdateWithoutCategoriesInput, offersUncheckedUpdateWithoutCategoriesInput>
    create: XOR<offersCreateWithoutCategoriesInput, offersUncheckedCreateWithoutCategoriesInput>
  }

  export type offersUpdateWithWhereUniqueWithoutCategoriesInput = {
    where: offersWhereUniqueInput
    data: XOR<offersUpdateWithoutCategoriesInput, offersUncheckedUpdateWithoutCategoriesInput>
  }

  export type offersUpdateManyWithWhereWithoutCategoriesInput = {
    where: offersScalarWhereInput
    data: XOR<offersUpdateManyMutationInput, offersUncheckedUpdateManyWithoutCategoriesInput>
  }

  export type offersScalarWhereInput = {
    AND?: offersScalarWhereInput | offersScalarWhereInput[]
    OR?: offersScalarWhereInput[]
    NOT?: offersScalarWhereInput | offersScalarWhereInput[]
    id?: BigIntFilter<"offers"> | bigint | number
    company_id?: BigIntFilter<"offers"> | bigint | number
    store_id?: BigIntFilter<"offers"> | bigint | number
    category_id?: BigIntNullableFilter<"offers"> | bigint | number | null
    title?: StringFilter<"offers"> | string
    description?: StringNullableFilter<"offers"> | string | null
    product_url?: StringNullableFilter<"offers"> | string | null
    image_url?: StringNullableFilter<"offers"> | string | null
    price?: DecimalNullableFilter<"offers"> | Decimal | DecimalJsLike | number | string | null
    code?: StringNullableFilter<"offers"> | string | null
    start_date?: DateTimeNullableFilter<"offers"> | Date | string | null
    end_date?: DateTimeNullableFilter<"offers"> | Date | string | null
    link?: StringNullableFilter<"offers"> | string | null
    is_featured?: BoolFilter<"offers"> | boolean
    is_exclusive?: BoolFilter<"offers"> | boolean
    is_deal?: BoolFilter<"offers"> | boolean
    path?: StringNullableFilter<"offers"> | string | null
    thumbnail?: StringNullableFilter<"offers"> | string | null
    sku?: StringNullableFilter<"offers"> | string | null
    product_name?: StringNullableFilter<"offers"> | string | null
    product_price?: DecimalNullableFilter<"offers"> | Decimal | DecimalJsLike | number | string | null
    old_price?: DecimalNullableFilter<"offers"> | Decimal | DecimalJsLike | number | string | null
    source?: StringNullableFilter<"offers"> | string | null
    type?: Enumoffers_typeFilter<"offers"> | $Enums.offers_type
    external_id?: StringNullableFilter<"offers"> | string | null
    status?: BoolFilter<"offers"> | boolean
    created_at?: DateTimeNullableFilter<"offers"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"offers"> | Date | string | null
  }

  export type categoriesCreateWithoutCompaniesInput = {
    id?: bigint | number
    name: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesCreateNestedOneWithoutOther_categoriesInput
    other_categories?: categoriesCreateNestedManyWithoutCategoriesInput
    integration_category_mappings?: integration_category_mappingsCreateNestedManyWithoutCategoriesInput
    offer_category?: offer_categoryCreateNestedManyWithoutCategoriesInput
    offers?: offersCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutCompaniesInput = {
    id?: bigint | number
    name: string
    parent_id?: bigint | number | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    other_categories?: categoriesUncheckedCreateNestedManyWithoutCategoriesInput
    integration_category_mappings?: integration_category_mappingsUncheckedCreateNestedManyWithoutCategoriesInput
    offer_category?: offer_categoryUncheckedCreateNestedManyWithoutCategoriesInput
    offers?: offersUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutCompaniesInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutCompaniesInput, categoriesUncheckedCreateWithoutCompaniesInput>
  }

  export type categoriesCreateManyCompaniesInputEnvelope = {
    data: categoriesCreateManyCompaniesInput | categoriesCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type company_frontend_settingsCreateWithoutCompaniesInput = {
    id?: bigint | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_frontend_settingsUncheckedCreateWithoutCompaniesInput = {
    id?: bigint | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_frontend_settingsCreateOrConnectWithoutCompaniesInput = {
    where: company_frontend_settingsWhereUniqueInput
    create: XOR<company_frontend_settingsCreateWithoutCompaniesInput, company_frontend_settingsUncheckedCreateWithoutCompaniesInput>
  }

  export type company_frontend_settingsCreateManyCompaniesInputEnvelope = {
    data: company_frontend_settingsCreateManyCompaniesInput | company_frontend_settingsCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type company_integrationsCreateWithoutCompaniesInput = {
    id?: bigint | number
    provider: string
    credentials: JsonNullValueInput | InputJsonValue
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_integrationsUncheckedCreateWithoutCompaniesInput = {
    id?: bigint | number
    provider: string
    credentials: JsonNullValueInput | InputJsonValue
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_integrationsCreateOrConnectWithoutCompaniesInput = {
    where: company_integrationsWhereUniqueInput
    create: XOR<company_integrationsCreateWithoutCompaniesInput, company_integrationsUncheckedCreateWithoutCompaniesInput>
  }

  export type company_integrationsCreateManyCompaniesInputEnvelope = {
    data: company_integrationsCreateManyCompaniesInput | company_integrationsCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type company_profilesCreateWithoutCompaniesInput = {
    id?: bigint | number
    phone?: string | null
    address?: string | null
    country?: string | null
    zipcode?: string | null
    city?: string | null
    state?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_profilesUncheckedCreateWithoutCompaniesInput = {
    id?: bigint | number
    phone?: string | null
    address?: string | null
    country?: string | null
    zipcode?: string | null
    city?: string | null
    state?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_profilesCreateOrConnectWithoutCompaniesInput = {
    where: company_profilesWhereUniqueInput
    create: XOR<company_profilesCreateWithoutCompaniesInput, company_profilesUncheckedCreateWithoutCompaniesInput>
  }

  export type company_profilesCreateManyCompaniesInputEnvelope = {
    data: company_profilesCreateManyCompaniesInput | company_profilesCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type company_subscriptionsCreateWithoutCompaniesInput = {
    id?: bigint | number
    start_date: Date | string
    end_date: Date | string
    status: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    subscriptions: subscriptionsCreateNestedOneWithoutCompany_subscriptionsInput
    payments?: paymentsCreateNestedManyWithoutCompany_subscriptionsInput
  }

  export type company_subscriptionsUncheckedCreateWithoutCompaniesInput = {
    id?: bigint | number
    subscription_id: bigint | number
    start_date: Date | string
    end_date: Date | string
    status: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    payments?: paymentsUncheckedCreateNestedManyWithoutCompany_subscriptionsInput
  }

  export type company_subscriptionsCreateOrConnectWithoutCompaniesInput = {
    where: company_subscriptionsWhereUniqueInput
    create: XOR<company_subscriptionsCreateWithoutCompaniesInput, company_subscriptionsUncheckedCreateWithoutCompaniesInput>
  }

  export type company_subscriptionsCreateManyCompaniesInputEnvelope = {
    data: company_subscriptionsCreateManyCompaniesInput | company_subscriptionsCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type integration_category_mappingsCreateWithoutCompaniesInput = {
    id?: bigint | number
    provider: string
    external_category: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesCreateNestedOneWithoutIntegration_category_mappingsInput
  }

  export type integration_category_mappingsUncheckedCreateWithoutCompaniesInput = {
    id?: bigint | number
    provider: string
    external_category: string
    category_id?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type integration_category_mappingsCreateOrConnectWithoutCompaniesInput = {
    where: integration_category_mappingsWhereUniqueInput
    create: XOR<integration_category_mappingsCreateWithoutCompaniesInput, integration_category_mappingsUncheckedCreateWithoutCompaniesInput>
  }

  export type integration_category_mappingsCreateManyCompaniesInputEnvelope = {
    data: integration_category_mappingsCreateManyCompaniesInput | integration_category_mappingsCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type offersCreateWithoutCompaniesInput = {
    id?: bigint | number
    title: string
    description?: string | null
    product_url?: string | null
    image_url?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    code?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    link?: string | null
    is_featured?: boolean
    is_exclusive?: boolean
    is_deal?: boolean
    path?: string | null
    thumbnail?: string | null
    sku?: string | null
    product_name?: string | null
    product_price?: Decimal | DecimalJsLike | number | string | null
    old_price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    type?: $Enums.offers_type
    external_id?: string | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    offer_category?: offer_categoryCreateNestedManyWithoutOffersInput
    categories?: categoriesCreateNestedOneWithoutOffersInput
    stores: storesCreateNestedOneWithoutOffersInput
  }

  export type offersUncheckedCreateWithoutCompaniesInput = {
    id?: bigint | number
    store_id: bigint | number
    category_id?: bigint | number | null
    title: string
    description?: string | null
    product_url?: string | null
    image_url?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    code?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    link?: string | null
    is_featured?: boolean
    is_exclusive?: boolean
    is_deal?: boolean
    path?: string | null
    thumbnail?: string | null
    sku?: string | null
    product_name?: string | null
    product_price?: Decimal | DecimalJsLike | number | string | null
    old_price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    type?: $Enums.offers_type
    external_id?: string | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    offer_category?: offer_categoryUncheckedCreateNestedManyWithoutOffersInput
  }

  export type offersCreateOrConnectWithoutCompaniesInput = {
    where: offersWhereUniqueInput
    create: XOR<offersCreateWithoutCompaniesInput, offersUncheckedCreateWithoutCompaniesInput>
  }

  export type offersCreateManyCompaniesInputEnvelope = {
    data: offersCreateManyCompaniesInput | offersCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type storesCreateWithoutCompaniesInput = {
    id?: bigint | number
    name: string
    image?: string | null
    description?: string | null
    status?: number
    channelId?: bigint | number | null
    channelName?: string | null
    programId?: bigint | number | null
    categoryName?: string | null
    categoryId?: bigint | number | null
    productFeedId?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    offers?: offersCreateNestedManyWithoutStoresInput
  }

  export type storesUncheckedCreateWithoutCompaniesInput = {
    id?: bigint | number
    name: string
    image?: string | null
    description?: string | null
    status?: number
    channelId?: bigint | number | null
    channelName?: string | null
    programId?: bigint | number | null
    categoryName?: string | null
    categoryId?: bigint | number | null
    productFeedId?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    offers?: offersUncheckedCreateNestedManyWithoutStoresInput
  }

  export type storesCreateOrConnectWithoutCompaniesInput = {
    where: storesWhereUniqueInput
    create: XOR<storesCreateWithoutCompaniesInput, storesUncheckedCreateWithoutCompaniesInput>
  }

  export type storesCreateManyCompaniesInputEnvelope = {
    data: storesCreateManyCompaniesInput | storesCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type usersCreateWithoutCompaniesInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersUncheckedCreateWithoutCompaniesInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersCreateOrConnectWithoutCompaniesInput = {
    where: usersWhereUniqueInput
    create: XOR<usersCreateWithoutCompaniesInput, usersUncheckedCreateWithoutCompaniesInput>
  }

  export type usersCreateManyCompaniesInputEnvelope = {
    data: usersCreateManyCompaniesInput | usersCreateManyCompaniesInput[]
    skipDuplicates?: boolean
  }

  export type categoriesUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: categoriesWhereUniqueInput
    update: XOR<categoriesUpdateWithoutCompaniesInput, categoriesUncheckedUpdateWithoutCompaniesInput>
    create: XOR<categoriesCreateWithoutCompaniesInput, categoriesUncheckedCreateWithoutCompaniesInput>
  }

  export type categoriesUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: categoriesWhereUniqueInput
    data: XOR<categoriesUpdateWithoutCompaniesInput, categoriesUncheckedUpdateWithoutCompaniesInput>
  }

  export type categoriesUpdateManyWithWhereWithoutCompaniesInput = {
    where: categoriesScalarWhereInput
    data: XOR<categoriesUpdateManyMutationInput, categoriesUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type company_frontend_settingsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: company_frontend_settingsWhereUniqueInput
    update: XOR<company_frontend_settingsUpdateWithoutCompaniesInput, company_frontend_settingsUncheckedUpdateWithoutCompaniesInput>
    create: XOR<company_frontend_settingsCreateWithoutCompaniesInput, company_frontend_settingsUncheckedCreateWithoutCompaniesInput>
  }

  export type company_frontend_settingsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: company_frontend_settingsWhereUniqueInput
    data: XOR<company_frontend_settingsUpdateWithoutCompaniesInput, company_frontend_settingsUncheckedUpdateWithoutCompaniesInput>
  }

  export type company_frontend_settingsUpdateManyWithWhereWithoutCompaniesInput = {
    where: company_frontend_settingsScalarWhereInput
    data: XOR<company_frontend_settingsUpdateManyMutationInput, company_frontend_settingsUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type company_frontend_settingsScalarWhereInput = {
    AND?: company_frontend_settingsScalarWhereInput | company_frontend_settingsScalarWhereInput[]
    OR?: company_frontend_settingsScalarWhereInput[]
    NOT?: company_frontend_settingsScalarWhereInput | company_frontend_settingsScalarWhereInput[]
    id?: BigIntFilter<"company_frontend_settings"> | bigint | number
    company_id?: BigIntFilter<"company_frontend_settings"> | bigint | number
    settings?: JsonNullableFilter<"company_frontend_settings">
    created_at?: DateTimeNullableFilter<"company_frontend_settings"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"company_frontend_settings"> | Date | string | null
  }

  export type company_integrationsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: company_integrationsWhereUniqueInput
    update: XOR<company_integrationsUpdateWithoutCompaniesInput, company_integrationsUncheckedUpdateWithoutCompaniesInput>
    create: XOR<company_integrationsCreateWithoutCompaniesInput, company_integrationsUncheckedCreateWithoutCompaniesInput>
  }

  export type company_integrationsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: company_integrationsWhereUniqueInput
    data: XOR<company_integrationsUpdateWithoutCompaniesInput, company_integrationsUncheckedUpdateWithoutCompaniesInput>
  }

  export type company_integrationsUpdateManyWithWhereWithoutCompaniesInput = {
    where: company_integrationsScalarWhereInput
    data: XOR<company_integrationsUpdateManyMutationInput, company_integrationsUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type company_integrationsScalarWhereInput = {
    AND?: company_integrationsScalarWhereInput | company_integrationsScalarWhereInput[]
    OR?: company_integrationsScalarWhereInput[]
    NOT?: company_integrationsScalarWhereInput | company_integrationsScalarWhereInput[]
    id?: BigIntFilter<"company_integrations"> | bigint | number
    company_id?: BigIntFilter<"company_integrations"> | bigint | number
    provider?: StringFilter<"company_integrations"> | string
    credentials?: JsonFilter<"company_integrations">
    status?: BoolFilter<"company_integrations"> | boolean
    created_at?: DateTimeNullableFilter<"company_integrations"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"company_integrations"> | Date | string | null
  }

  export type company_profilesUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: company_profilesWhereUniqueInput
    update: XOR<company_profilesUpdateWithoutCompaniesInput, company_profilesUncheckedUpdateWithoutCompaniesInput>
    create: XOR<company_profilesCreateWithoutCompaniesInput, company_profilesUncheckedCreateWithoutCompaniesInput>
  }

  export type company_profilesUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: company_profilesWhereUniqueInput
    data: XOR<company_profilesUpdateWithoutCompaniesInput, company_profilesUncheckedUpdateWithoutCompaniesInput>
  }

  export type company_profilesUpdateManyWithWhereWithoutCompaniesInput = {
    where: company_profilesScalarWhereInput
    data: XOR<company_profilesUpdateManyMutationInput, company_profilesUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type company_profilesScalarWhereInput = {
    AND?: company_profilesScalarWhereInput | company_profilesScalarWhereInput[]
    OR?: company_profilesScalarWhereInput[]
    NOT?: company_profilesScalarWhereInput | company_profilesScalarWhereInput[]
    id?: BigIntFilter<"company_profiles"> | bigint | number
    company_id?: BigIntFilter<"company_profiles"> | bigint | number
    phone?: StringNullableFilter<"company_profiles"> | string | null
    address?: StringNullableFilter<"company_profiles"> | string | null
    country?: StringNullableFilter<"company_profiles"> | string | null
    zipcode?: StringNullableFilter<"company_profiles"> | string | null
    city?: StringNullableFilter<"company_profiles"> | string | null
    state?: StringNullableFilter<"company_profiles"> | string | null
    created_at?: DateTimeNullableFilter<"company_profiles"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"company_profiles"> | Date | string | null
  }

  export type company_subscriptionsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: company_subscriptionsWhereUniqueInput
    update: XOR<company_subscriptionsUpdateWithoutCompaniesInput, company_subscriptionsUncheckedUpdateWithoutCompaniesInput>
    create: XOR<company_subscriptionsCreateWithoutCompaniesInput, company_subscriptionsUncheckedCreateWithoutCompaniesInput>
  }

  export type company_subscriptionsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: company_subscriptionsWhereUniqueInput
    data: XOR<company_subscriptionsUpdateWithoutCompaniesInput, company_subscriptionsUncheckedUpdateWithoutCompaniesInput>
  }

  export type company_subscriptionsUpdateManyWithWhereWithoutCompaniesInput = {
    where: company_subscriptionsScalarWhereInput
    data: XOR<company_subscriptionsUpdateManyMutationInput, company_subscriptionsUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type company_subscriptionsScalarWhereInput = {
    AND?: company_subscriptionsScalarWhereInput | company_subscriptionsScalarWhereInput[]
    OR?: company_subscriptionsScalarWhereInput[]
    NOT?: company_subscriptionsScalarWhereInput | company_subscriptionsScalarWhereInput[]
    id?: BigIntFilter<"company_subscriptions"> | bigint | number
    company_id?: BigIntFilter<"company_subscriptions"> | bigint | number
    subscription_id?: BigIntFilter<"company_subscriptions"> | bigint | number
    start_date?: DateTimeFilter<"company_subscriptions"> | Date | string
    end_date?: DateTimeFilter<"company_subscriptions"> | Date | string
    status?: StringFilter<"company_subscriptions"> | string
    created_at?: DateTimeNullableFilter<"company_subscriptions"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"company_subscriptions"> | Date | string | null
  }

  export type integration_category_mappingsUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: integration_category_mappingsWhereUniqueInput
    update: XOR<integration_category_mappingsUpdateWithoutCompaniesInput, integration_category_mappingsUncheckedUpdateWithoutCompaniesInput>
    create: XOR<integration_category_mappingsCreateWithoutCompaniesInput, integration_category_mappingsUncheckedCreateWithoutCompaniesInput>
  }

  export type integration_category_mappingsUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: integration_category_mappingsWhereUniqueInput
    data: XOR<integration_category_mappingsUpdateWithoutCompaniesInput, integration_category_mappingsUncheckedUpdateWithoutCompaniesInput>
  }

  export type integration_category_mappingsUpdateManyWithWhereWithoutCompaniesInput = {
    where: integration_category_mappingsScalarWhereInput
    data: XOR<integration_category_mappingsUpdateManyMutationInput, integration_category_mappingsUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type offersUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: offersWhereUniqueInput
    update: XOR<offersUpdateWithoutCompaniesInput, offersUncheckedUpdateWithoutCompaniesInput>
    create: XOR<offersCreateWithoutCompaniesInput, offersUncheckedCreateWithoutCompaniesInput>
  }

  export type offersUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: offersWhereUniqueInput
    data: XOR<offersUpdateWithoutCompaniesInput, offersUncheckedUpdateWithoutCompaniesInput>
  }

  export type offersUpdateManyWithWhereWithoutCompaniesInput = {
    where: offersScalarWhereInput
    data: XOR<offersUpdateManyMutationInput, offersUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type storesUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: storesWhereUniqueInput
    update: XOR<storesUpdateWithoutCompaniesInput, storesUncheckedUpdateWithoutCompaniesInput>
    create: XOR<storesCreateWithoutCompaniesInput, storesUncheckedCreateWithoutCompaniesInput>
  }

  export type storesUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: storesWhereUniqueInput
    data: XOR<storesUpdateWithoutCompaniesInput, storesUncheckedUpdateWithoutCompaniesInput>
  }

  export type storesUpdateManyWithWhereWithoutCompaniesInput = {
    where: storesScalarWhereInput
    data: XOR<storesUpdateManyMutationInput, storesUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type storesScalarWhereInput = {
    AND?: storesScalarWhereInput | storesScalarWhereInput[]
    OR?: storesScalarWhereInput[]
    NOT?: storesScalarWhereInput | storesScalarWhereInput[]
    id?: BigIntFilter<"stores"> | bigint | number
    company_id?: BigIntFilter<"stores"> | bigint | number
    name?: StringFilter<"stores"> | string
    image?: StringNullableFilter<"stores"> | string | null
    description?: StringNullableFilter<"stores"> | string | null
    status?: IntFilter<"stores"> | number
    channelId?: BigIntNullableFilter<"stores"> | bigint | number | null
    channelName?: StringNullableFilter<"stores"> | string | null
    programId?: BigIntNullableFilter<"stores"> | bigint | number | null
    categoryName?: StringNullableFilter<"stores"> | string | null
    categoryId?: BigIntNullableFilter<"stores"> | bigint | number | null
    productFeedId?: BigIntNullableFilter<"stores"> | bigint | number | null
    created_at?: DateTimeNullableFilter<"stores"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"stores"> | Date | string | null
  }

  export type usersUpsertWithWhereUniqueWithoutCompaniesInput = {
    where: usersWhereUniqueInput
    update: XOR<usersUpdateWithoutCompaniesInput, usersUncheckedUpdateWithoutCompaniesInput>
    create: XOR<usersCreateWithoutCompaniesInput, usersUncheckedCreateWithoutCompaniesInput>
  }

  export type usersUpdateWithWhereUniqueWithoutCompaniesInput = {
    where: usersWhereUniqueInput
    data: XOR<usersUpdateWithoutCompaniesInput, usersUncheckedUpdateWithoutCompaniesInput>
  }

  export type usersUpdateManyWithWhereWithoutCompaniesInput = {
    where: usersScalarWhereInput
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyWithoutCompaniesInput>
  }

  export type usersScalarWhereInput = {
    AND?: usersScalarWhereInput | usersScalarWhereInput[]
    OR?: usersScalarWhereInput[]
    NOT?: usersScalarWhereInput | usersScalarWhereInput[]
    id?: BigIntFilter<"users"> | bigint | number
    name?: StringFilter<"users"> | string
    email?: StringFilter<"users"> | string
    email_verified_at?: DateTimeNullableFilter<"users"> | Date | string | null
    password?: StringFilter<"users"> | string
    company_id?: BigIntNullableFilter<"users"> | bigint | number | null
    remember_token?: StringNullableFilter<"users"> | string | null
    created_at?: DateTimeNullableFilter<"users"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"users"> | Date | string | null
  }

  export type companiesCreateWithoutCompany_frontend_settingsInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutCompaniesInput
    company_integrations?: company_integrationsCreateNestedManyWithoutCompaniesInput
    company_profiles?: company_profilesCreateNestedManyWithoutCompaniesInput
    company_subscriptions?: company_subscriptionsCreateNestedManyWithoutCompaniesInput
    integration_category_mappings?: integration_category_mappingsCreateNestedManyWithoutCompaniesInput
    offers?: offersCreateNestedManyWithoutCompaniesInput
    stores?: storesCreateNestedManyWithoutCompaniesInput
    users?: usersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutCompany_frontend_settingsInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutCompaniesInput
    company_integrations?: company_integrationsUncheckedCreateNestedManyWithoutCompaniesInput
    company_profiles?: company_profilesUncheckedCreateNestedManyWithoutCompaniesInput
    company_subscriptions?: company_subscriptionsUncheckedCreateNestedManyWithoutCompaniesInput
    integration_category_mappings?: integration_category_mappingsUncheckedCreateNestedManyWithoutCompaniesInput
    offers?: offersUncheckedCreateNestedManyWithoutCompaniesInput
    stores?: storesUncheckedCreateNestedManyWithoutCompaniesInput
    users?: usersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutCompany_frontend_settingsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutCompany_frontend_settingsInput, companiesUncheckedCreateWithoutCompany_frontend_settingsInput>
  }

  export type companiesUpsertWithoutCompany_frontend_settingsInput = {
    update: XOR<companiesUpdateWithoutCompany_frontend_settingsInput, companiesUncheckedUpdateWithoutCompany_frontend_settingsInput>
    create: XOR<companiesCreateWithoutCompany_frontend_settingsInput, companiesUncheckedCreateWithoutCompany_frontend_settingsInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutCompany_frontend_settingsInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutCompany_frontend_settingsInput, companiesUncheckedUpdateWithoutCompany_frontend_settingsInput>
  }

  export type companiesUpdateWithoutCompany_frontend_settingsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutCompaniesNestedInput
    company_integrations?: company_integrationsUpdateManyWithoutCompaniesNestedInput
    company_profiles?: company_profilesUpdateManyWithoutCompaniesNestedInput
    company_subscriptions?: company_subscriptionsUpdateManyWithoutCompaniesNestedInput
    integration_category_mappings?: integration_category_mappingsUpdateManyWithoutCompaniesNestedInput
    offers?: offersUpdateManyWithoutCompaniesNestedInput
    stores?: storesUpdateManyWithoutCompaniesNestedInput
    users?: usersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutCompany_frontend_settingsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutCompaniesNestedInput
    company_integrations?: company_integrationsUncheckedUpdateManyWithoutCompaniesNestedInput
    company_profiles?: company_profilesUncheckedUpdateManyWithoutCompaniesNestedInput
    company_subscriptions?: company_subscriptionsUncheckedUpdateManyWithoutCompaniesNestedInput
    integration_category_mappings?: integration_category_mappingsUncheckedUpdateManyWithoutCompaniesNestedInput
    offers?: offersUncheckedUpdateManyWithoutCompaniesNestedInput
    stores?: storesUncheckedUpdateManyWithoutCompaniesNestedInput
    users?: usersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesCreateWithoutCompany_integrationsInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutCompaniesInput
    company_frontend_settings?: company_frontend_settingsCreateNestedManyWithoutCompaniesInput
    company_profiles?: company_profilesCreateNestedManyWithoutCompaniesInput
    company_subscriptions?: company_subscriptionsCreateNestedManyWithoutCompaniesInput
    integration_category_mappings?: integration_category_mappingsCreateNestedManyWithoutCompaniesInput
    offers?: offersCreateNestedManyWithoutCompaniesInput
    stores?: storesCreateNestedManyWithoutCompaniesInput
    users?: usersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutCompany_integrationsInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutCompaniesInput
    company_frontend_settings?: company_frontend_settingsUncheckedCreateNestedManyWithoutCompaniesInput
    company_profiles?: company_profilesUncheckedCreateNestedManyWithoutCompaniesInput
    company_subscriptions?: company_subscriptionsUncheckedCreateNestedManyWithoutCompaniesInput
    integration_category_mappings?: integration_category_mappingsUncheckedCreateNestedManyWithoutCompaniesInput
    offers?: offersUncheckedCreateNestedManyWithoutCompaniesInput
    stores?: storesUncheckedCreateNestedManyWithoutCompaniesInput
    users?: usersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutCompany_integrationsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutCompany_integrationsInput, companiesUncheckedCreateWithoutCompany_integrationsInput>
  }

  export type companiesUpsertWithoutCompany_integrationsInput = {
    update: XOR<companiesUpdateWithoutCompany_integrationsInput, companiesUncheckedUpdateWithoutCompany_integrationsInput>
    create: XOR<companiesCreateWithoutCompany_integrationsInput, companiesUncheckedCreateWithoutCompany_integrationsInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutCompany_integrationsInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutCompany_integrationsInput, companiesUncheckedUpdateWithoutCompany_integrationsInput>
  }

  export type companiesUpdateWithoutCompany_integrationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutCompaniesNestedInput
    company_frontend_settings?: company_frontend_settingsUpdateManyWithoutCompaniesNestedInput
    company_profiles?: company_profilesUpdateManyWithoutCompaniesNestedInput
    company_subscriptions?: company_subscriptionsUpdateManyWithoutCompaniesNestedInput
    integration_category_mappings?: integration_category_mappingsUpdateManyWithoutCompaniesNestedInput
    offers?: offersUpdateManyWithoutCompaniesNestedInput
    stores?: storesUpdateManyWithoutCompaniesNestedInput
    users?: usersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutCompany_integrationsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutCompaniesNestedInput
    company_frontend_settings?: company_frontend_settingsUncheckedUpdateManyWithoutCompaniesNestedInput
    company_profiles?: company_profilesUncheckedUpdateManyWithoutCompaniesNestedInput
    company_subscriptions?: company_subscriptionsUncheckedUpdateManyWithoutCompaniesNestedInput
    integration_category_mappings?: integration_category_mappingsUncheckedUpdateManyWithoutCompaniesNestedInput
    offers?: offersUncheckedUpdateManyWithoutCompaniesNestedInput
    stores?: storesUncheckedUpdateManyWithoutCompaniesNestedInput
    users?: usersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesCreateWithoutCompany_profilesInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutCompaniesInput
    company_frontend_settings?: company_frontend_settingsCreateNestedManyWithoutCompaniesInput
    company_integrations?: company_integrationsCreateNestedManyWithoutCompaniesInput
    company_subscriptions?: company_subscriptionsCreateNestedManyWithoutCompaniesInput
    integration_category_mappings?: integration_category_mappingsCreateNestedManyWithoutCompaniesInput
    offers?: offersCreateNestedManyWithoutCompaniesInput
    stores?: storesCreateNestedManyWithoutCompaniesInput
    users?: usersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutCompany_profilesInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutCompaniesInput
    company_frontend_settings?: company_frontend_settingsUncheckedCreateNestedManyWithoutCompaniesInput
    company_integrations?: company_integrationsUncheckedCreateNestedManyWithoutCompaniesInput
    company_subscriptions?: company_subscriptionsUncheckedCreateNestedManyWithoutCompaniesInput
    integration_category_mappings?: integration_category_mappingsUncheckedCreateNestedManyWithoutCompaniesInput
    offers?: offersUncheckedCreateNestedManyWithoutCompaniesInput
    stores?: storesUncheckedCreateNestedManyWithoutCompaniesInput
    users?: usersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutCompany_profilesInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutCompany_profilesInput, companiesUncheckedCreateWithoutCompany_profilesInput>
  }

  export type companiesUpsertWithoutCompany_profilesInput = {
    update: XOR<companiesUpdateWithoutCompany_profilesInput, companiesUncheckedUpdateWithoutCompany_profilesInput>
    create: XOR<companiesCreateWithoutCompany_profilesInput, companiesUncheckedCreateWithoutCompany_profilesInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutCompany_profilesInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutCompany_profilesInput, companiesUncheckedUpdateWithoutCompany_profilesInput>
  }

  export type companiesUpdateWithoutCompany_profilesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutCompaniesNestedInput
    company_frontend_settings?: company_frontend_settingsUpdateManyWithoutCompaniesNestedInput
    company_integrations?: company_integrationsUpdateManyWithoutCompaniesNestedInput
    company_subscriptions?: company_subscriptionsUpdateManyWithoutCompaniesNestedInput
    integration_category_mappings?: integration_category_mappingsUpdateManyWithoutCompaniesNestedInput
    offers?: offersUpdateManyWithoutCompaniesNestedInput
    stores?: storesUpdateManyWithoutCompaniesNestedInput
    users?: usersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutCompany_profilesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutCompaniesNestedInput
    company_frontend_settings?: company_frontend_settingsUncheckedUpdateManyWithoutCompaniesNestedInput
    company_integrations?: company_integrationsUncheckedUpdateManyWithoutCompaniesNestedInput
    company_subscriptions?: company_subscriptionsUncheckedUpdateManyWithoutCompaniesNestedInput
    integration_category_mappings?: integration_category_mappingsUncheckedUpdateManyWithoutCompaniesNestedInput
    offers?: offersUncheckedUpdateManyWithoutCompaniesNestedInput
    stores?: storesUncheckedUpdateManyWithoutCompaniesNestedInput
    users?: usersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesCreateWithoutCompany_subscriptionsInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutCompaniesInput
    company_frontend_settings?: company_frontend_settingsCreateNestedManyWithoutCompaniesInput
    company_integrations?: company_integrationsCreateNestedManyWithoutCompaniesInput
    company_profiles?: company_profilesCreateNestedManyWithoutCompaniesInput
    integration_category_mappings?: integration_category_mappingsCreateNestedManyWithoutCompaniesInput
    offers?: offersCreateNestedManyWithoutCompaniesInput
    stores?: storesCreateNestedManyWithoutCompaniesInput
    users?: usersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutCompany_subscriptionsInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutCompaniesInput
    company_frontend_settings?: company_frontend_settingsUncheckedCreateNestedManyWithoutCompaniesInput
    company_integrations?: company_integrationsUncheckedCreateNestedManyWithoutCompaniesInput
    company_profiles?: company_profilesUncheckedCreateNestedManyWithoutCompaniesInput
    integration_category_mappings?: integration_category_mappingsUncheckedCreateNestedManyWithoutCompaniesInput
    offers?: offersUncheckedCreateNestedManyWithoutCompaniesInput
    stores?: storesUncheckedCreateNestedManyWithoutCompaniesInput
    users?: usersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutCompany_subscriptionsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutCompany_subscriptionsInput, companiesUncheckedCreateWithoutCompany_subscriptionsInput>
  }

  export type subscriptionsCreateWithoutCompany_subscriptionsInput = {
    id?: bigint | number
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration: number
    features?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type subscriptionsUncheckedCreateWithoutCompany_subscriptionsInput = {
    id?: bigint | number
    name: string
    price: Decimal | DecimalJsLike | number | string
    duration: number
    features?: NullableJsonNullValueInput | InputJsonValue
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type subscriptionsCreateOrConnectWithoutCompany_subscriptionsInput = {
    where: subscriptionsWhereUniqueInput
    create: XOR<subscriptionsCreateWithoutCompany_subscriptionsInput, subscriptionsUncheckedCreateWithoutCompany_subscriptionsInput>
  }

  export type paymentsCreateWithoutCompany_subscriptionsInput = {
    id?: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    payment_status: string
    transaction_id?: string | null
    paid_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type paymentsUncheckedCreateWithoutCompany_subscriptionsInput = {
    id?: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    payment_status: string
    transaction_id?: string | null
    paid_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type paymentsCreateOrConnectWithoutCompany_subscriptionsInput = {
    where: paymentsWhereUniqueInput
    create: XOR<paymentsCreateWithoutCompany_subscriptionsInput, paymentsUncheckedCreateWithoutCompany_subscriptionsInput>
  }

  export type paymentsCreateManyCompany_subscriptionsInputEnvelope = {
    data: paymentsCreateManyCompany_subscriptionsInput | paymentsCreateManyCompany_subscriptionsInput[]
    skipDuplicates?: boolean
  }

  export type companiesUpsertWithoutCompany_subscriptionsInput = {
    update: XOR<companiesUpdateWithoutCompany_subscriptionsInput, companiesUncheckedUpdateWithoutCompany_subscriptionsInput>
    create: XOR<companiesCreateWithoutCompany_subscriptionsInput, companiesUncheckedCreateWithoutCompany_subscriptionsInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutCompany_subscriptionsInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutCompany_subscriptionsInput, companiesUncheckedUpdateWithoutCompany_subscriptionsInput>
  }

  export type companiesUpdateWithoutCompany_subscriptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutCompaniesNestedInput
    company_frontend_settings?: company_frontend_settingsUpdateManyWithoutCompaniesNestedInput
    company_integrations?: company_integrationsUpdateManyWithoutCompaniesNestedInput
    company_profiles?: company_profilesUpdateManyWithoutCompaniesNestedInput
    integration_category_mappings?: integration_category_mappingsUpdateManyWithoutCompaniesNestedInput
    offers?: offersUpdateManyWithoutCompaniesNestedInput
    stores?: storesUpdateManyWithoutCompaniesNestedInput
    users?: usersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutCompany_subscriptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutCompaniesNestedInput
    company_frontend_settings?: company_frontend_settingsUncheckedUpdateManyWithoutCompaniesNestedInput
    company_integrations?: company_integrationsUncheckedUpdateManyWithoutCompaniesNestedInput
    company_profiles?: company_profilesUncheckedUpdateManyWithoutCompaniesNestedInput
    integration_category_mappings?: integration_category_mappingsUncheckedUpdateManyWithoutCompaniesNestedInput
    offers?: offersUncheckedUpdateManyWithoutCompaniesNestedInput
    stores?: storesUncheckedUpdateManyWithoutCompaniesNestedInput
    users?: usersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type subscriptionsUpsertWithoutCompany_subscriptionsInput = {
    update: XOR<subscriptionsUpdateWithoutCompany_subscriptionsInput, subscriptionsUncheckedUpdateWithoutCompany_subscriptionsInput>
    create: XOR<subscriptionsCreateWithoutCompany_subscriptionsInput, subscriptionsUncheckedCreateWithoutCompany_subscriptionsInput>
    where?: subscriptionsWhereInput
  }

  export type subscriptionsUpdateToOneWithWhereWithoutCompany_subscriptionsInput = {
    where?: subscriptionsWhereInput
    data: XOR<subscriptionsUpdateWithoutCompany_subscriptionsInput, subscriptionsUncheckedUpdateWithoutCompany_subscriptionsInput>
  }

  export type subscriptionsUpdateWithoutCompany_subscriptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type subscriptionsUncheckedUpdateWithoutCompany_subscriptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    duration?: IntFieldUpdateOperationsInput | number
    features?: NullableJsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsUpsertWithWhereUniqueWithoutCompany_subscriptionsInput = {
    where: paymentsWhereUniqueInput
    update: XOR<paymentsUpdateWithoutCompany_subscriptionsInput, paymentsUncheckedUpdateWithoutCompany_subscriptionsInput>
    create: XOR<paymentsCreateWithoutCompany_subscriptionsInput, paymentsUncheckedCreateWithoutCompany_subscriptionsInput>
  }

  export type paymentsUpdateWithWhereUniqueWithoutCompany_subscriptionsInput = {
    where: paymentsWhereUniqueInput
    data: XOR<paymentsUpdateWithoutCompany_subscriptionsInput, paymentsUncheckedUpdateWithoutCompany_subscriptionsInput>
  }

  export type paymentsUpdateManyWithWhereWithoutCompany_subscriptionsInput = {
    where: paymentsScalarWhereInput
    data: XOR<paymentsUpdateManyMutationInput, paymentsUncheckedUpdateManyWithoutCompany_subscriptionsInput>
  }

  export type paymentsScalarWhereInput = {
    AND?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    OR?: paymentsScalarWhereInput[]
    NOT?: paymentsScalarWhereInput | paymentsScalarWhereInput[]
    id?: BigIntFilter<"payments"> | bigint | number
    company_subscription_id?: BigIntFilter<"payments"> | bigint | number
    amount?: DecimalFilter<"payments"> | Decimal | DecimalJsLike | number | string
    payment_method?: StringFilter<"payments"> | string
    payment_status?: StringFilter<"payments"> | string
    transaction_id?: StringNullableFilter<"payments"> | string | null
    paid_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    created_at?: DateTimeNullableFilter<"payments"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"payments"> | Date | string | null
  }

  export type categoriesCreateWithoutIntegration_category_mappingsInput = {
    id?: bigint | number
    name: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    companies: companiesCreateNestedOneWithoutCategoriesInput
    categories?: categoriesCreateNestedOneWithoutOther_categoriesInput
    other_categories?: categoriesCreateNestedManyWithoutCategoriesInput
    offer_category?: offer_categoryCreateNestedManyWithoutCategoriesInput
    offers?: offersCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutIntegration_category_mappingsInput = {
    id?: bigint | number
    name: string
    parent_id?: bigint | number | null
    company_id: bigint | number
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    other_categories?: categoriesUncheckedCreateNestedManyWithoutCategoriesInput
    offer_category?: offer_categoryUncheckedCreateNestedManyWithoutCategoriesInput
    offers?: offersUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutIntegration_category_mappingsInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutIntegration_category_mappingsInput, categoriesUncheckedCreateWithoutIntegration_category_mappingsInput>
  }

  export type companiesCreateWithoutIntegration_category_mappingsInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutCompaniesInput
    company_frontend_settings?: company_frontend_settingsCreateNestedManyWithoutCompaniesInput
    company_integrations?: company_integrationsCreateNestedManyWithoutCompaniesInput
    company_profiles?: company_profilesCreateNestedManyWithoutCompaniesInput
    company_subscriptions?: company_subscriptionsCreateNestedManyWithoutCompaniesInput
    offers?: offersCreateNestedManyWithoutCompaniesInput
    stores?: storesCreateNestedManyWithoutCompaniesInput
    users?: usersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutIntegration_category_mappingsInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutCompaniesInput
    company_frontend_settings?: company_frontend_settingsUncheckedCreateNestedManyWithoutCompaniesInput
    company_integrations?: company_integrationsUncheckedCreateNestedManyWithoutCompaniesInput
    company_profiles?: company_profilesUncheckedCreateNestedManyWithoutCompaniesInput
    company_subscriptions?: company_subscriptionsUncheckedCreateNestedManyWithoutCompaniesInput
    offers?: offersUncheckedCreateNestedManyWithoutCompaniesInput
    stores?: storesUncheckedCreateNestedManyWithoutCompaniesInput
    users?: usersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutIntegration_category_mappingsInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutIntegration_category_mappingsInput, companiesUncheckedCreateWithoutIntegration_category_mappingsInput>
  }

  export type categoriesUpsertWithoutIntegration_category_mappingsInput = {
    update: XOR<categoriesUpdateWithoutIntegration_category_mappingsInput, categoriesUncheckedUpdateWithoutIntegration_category_mappingsInput>
    create: XOR<categoriesCreateWithoutIntegration_category_mappingsInput, categoriesUncheckedCreateWithoutIntegration_category_mappingsInput>
    where?: categoriesWhereInput
  }

  export type categoriesUpdateToOneWithWhereWithoutIntegration_category_mappingsInput = {
    where?: categoriesWhereInput
    data: XOR<categoriesUpdateWithoutIntegration_category_mappingsInput, categoriesUncheckedUpdateWithoutIntegration_category_mappingsInput>
  }

  export type categoriesUpdateWithoutIntegration_category_mappingsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutCategoriesNestedInput
    categories?: categoriesUpdateOneWithoutOther_categoriesNestedInput
    other_categories?: categoriesUpdateManyWithoutCategoriesNestedInput
    offer_category?: offer_categoryUpdateManyWithoutCategoriesNestedInput
    offers?: offersUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutIntegration_category_mappingsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_categories?: categoriesUncheckedUpdateManyWithoutCategoriesNestedInput
    offer_category?: offer_categoryUncheckedUpdateManyWithoutCategoriesNestedInput
    offers?: offersUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type companiesUpsertWithoutIntegration_category_mappingsInput = {
    update: XOR<companiesUpdateWithoutIntegration_category_mappingsInput, companiesUncheckedUpdateWithoutIntegration_category_mappingsInput>
    create: XOR<companiesCreateWithoutIntegration_category_mappingsInput, companiesUncheckedCreateWithoutIntegration_category_mappingsInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutIntegration_category_mappingsInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutIntegration_category_mappingsInput, companiesUncheckedUpdateWithoutIntegration_category_mappingsInput>
  }

  export type companiesUpdateWithoutIntegration_category_mappingsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutCompaniesNestedInput
    company_frontend_settings?: company_frontend_settingsUpdateManyWithoutCompaniesNestedInput
    company_integrations?: company_integrationsUpdateManyWithoutCompaniesNestedInput
    company_profiles?: company_profilesUpdateManyWithoutCompaniesNestedInput
    company_subscriptions?: company_subscriptionsUpdateManyWithoutCompaniesNestedInput
    offers?: offersUpdateManyWithoutCompaniesNestedInput
    stores?: storesUpdateManyWithoutCompaniesNestedInput
    users?: usersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutIntegration_category_mappingsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutCompaniesNestedInput
    company_frontend_settings?: company_frontend_settingsUncheckedUpdateManyWithoutCompaniesNestedInput
    company_integrations?: company_integrationsUncheckedUpdateManyWithoutCompaniesNestedInput
    company_profiles?: company_profilesUncheckedUpdateManyWithoutCompaniesNestedInput
    company_subscriptions?: company_subscriptionsUncheckedUpdateManyWithoutCompaniesNestedInput
    offers?: offersUncheckedUpdateManyWithoutCompaniesNestedInput
    stores?: storesUncheckedUpdateManyWithoutCompaniesNestedInput
    users?: usersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type menusCreateWithoutOther_menusInput = {
    id?: bigint | number
    title: string
    href?: string | null
    icon?: string | null
    role?: string | null
    permission?: string | null
    order?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    menus?: menusCreateNestedOneWithoutOther_menusInput
  }

  export type menusUncheckedCreateWithoutOther_menusInput = {
    id?: bigint | number
    title: string
    href?: string | null
    icon?: string | null
    role?: string | null
    permission?: string | null
    parent_id?: bigint | number | null
    order?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type menusCreateOrConnectWithoutOther_menusInput = {
    where: menusWhereUniqueInput
    create: XOR<menusCreateWithoutOther_menusInput, menusUncheckedCreateWithoutOther_menusInput>
  }

  export type menusCreateWithoutMenusInput = {
    id?: bigint | number
    title: string
    href?: string | null
    icon?: string | null
    role?: string | null
    permission?: string | null
    order?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    other_menus?: menusCreateNestedManyWithoutMenusInput
  }

  export type menusUncheckedCreateWithoutMenusInput = {
    id?: bigint | number
    title: string
    href?: string | null
    icon?: string | null
    role?: string | null
    permission?: string | null
    order?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    other_menus?: menusUncheckedCreateNestedManyWithoutMenusInput
  }

  export type menusCreateOrConnectWithoutMenusInput = {
    where: menusWhereUniqueInput
    create: XOR<menusCreateWithoutMenusInput, menusUncheckedCreateWithoutMenusInput>
  }

  export type menusCreateManyMenusInputEnvelope = {
    data: menusCreateManyMenusInput | menusCreateManyMenusInput[]
    skipDuplicates?: boolean
  }

  export type menusUpsertWithoutOther_menusInput = {
    update: XOR<menusUpdateWithoutOther_menusInput, menusUncheckedUpdateWithoutOther_menusInput>
    create: XOR<menusCreateWithoutOther_menusInput, menusUncheckedCreateWithoutOther_menusInput>
    where?: menusWhereInput
  }

  export type menusUpdateToOneWithWhereWithoutOther_menusInput = {
    where?: menusWhereInput
    data: XOR<menusUpdateWithoutOther_menusInput, menusUncheckedUpdateWithoutOther_menusInput>
  }

  export type menusUpdateWithoutOther_menusInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    href?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    menus?: menusUpdateOneWithoutOther_menusNestedInput
  }

  export type menusUncheckedUpdateWithoutOther_menusInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    href?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    parent_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    order?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type menusUpsertWithWhereUniqueWithoutMenusInput = {
    where: menusWhereUniqueInput
    update: XOR<menusUpdateWithoutMenusInput, menusUncheckedUpdateWithoutMenusInput>
    create: XOR<menusCreateWithoutMenusInput, menusUncheckedCreateWithoutMenusInput>
  }

  export type menusUpdateWithWhereUniqueWithoutMenusInput = {
    where: menusWhereUniqueInput
    data: XOR<menusUpdateWithoutMenusInput, menusUncheckedUpdateWithoutMenusInput>
  }

  export type menusUpdateManyWithWhereWithoutMenusInput = {
    where: menusScalarWhereInput
    data: XOR<menusUpdateManyMutationInput, menusUncheckedUpdateManyWithoutMenusInput>
  }

  export type menusScalarWhereInput = {
    AND?: menusScalarWhereInput | menusScalarWhereInput[]
    OR?: menusScalarWhereInput[]
    NOT?: menusScalarWhereInput | menusScalarWhereInput[]
    id?: BigIntFilter<"menus"> | bigint | number
    title?: StringFilter<"menus"> | string
    href?: StringNullableFilter<"menus"> | string | null
    icon?: StringNullableFilter<"menus"> | string | null
    role?: StringNullableFilter<"menus"> | string | null
    permission?: StringNullableFilter<"menus"> | string | null
    parent_id?: BigIntNullableFilter<"menus"> | bigint | number | null
    order?: IntFilter<"menus"> | number
    created_at?: DateTimeNullableFilter<"menus"> | Date | string | null
    updated_at?: DateTimeNullableFilter<"menus"> | Date | string | null
  }

  export type categoriesCreateWithoutOffer_categoryInput = {
    id?: bigint | number
    name: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    companies: companiesCreateNestedOneWithoutCategoriesInput
    categories?: categoriesCreateNestedOneWithoutOther_categoriesInput
    other_categories?: categoriesCreateNestedManyWithoutCategoriesInput
    integration_category_mappings?: integration_category_mappingsCreateNestedManyWithoutCategoriesInput
    offers?: offersCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutOffer_categoryInput = {
    id?: bigint | number
    name: string
    parent_id?: bigint | number | null
    company_id: bigint | number
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    other_categories?: categoriesUncheckedCreateNestedManyWithoutCategoriesInput
    integration_category_mappings?: integration_category_mappingsUncheckedCreateNestedManyWithoutCategoriesInput
    offers?: offersUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutOffer_categoryInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutOffer_categoryInput, categoriesUncheckedCreateWithoutOffer_categoryInput>
  }

  export type offersCreateWithoutOffer_categoryInput = {
    id?: bigint | number
    title: string
    description?: string | null
    product_url?: string | null
    image_url?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    code?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    link?: string | null
    is_featured?: boolean
    is_exclusive?: boolean
    is_deal?: boolean
    path?: string | null
    thumbnail?: string | null
    sku?: string | null
    product_name?: string | null
    product_price?: Decimal | DecimalJsLike | number | string | null
    old_price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    type?: $Enums.offers_type
    external_id?: string | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesCreateNestedOneWithoutOffersInput
    companies: companiesCreateNestedOneWithoutOffersInput
    stores: storesCreateNestedOneWithoutOffersInput
  }

  export type offersUncheckedCreateWithoutOffer_categoryInput = {
    id?: bigint | number
    company_id: bigint | number
    store_id: bigint | number
    category_id?: bigint | number | null
    title: string
    description?: string | null
    product_url?: string | null
    image_url?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    code?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    link?: string | null
    is_featured?: boolean
    is_exclusive?: boolean
    is_deal?: boolean
    path?: string | null
    thumbnail?: string | null
    sku?: string | null
    product_name?: string | null
    product_price?: Decimal | DecimalJsLike | number | string | null
    old_price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    type?: $Enums.offers_type
    external_id?: string | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type offersCreateOrConnectWithoutOffer_categoryInput = {
    where: offersWhereUniqueInput
    create: XOR<offersCreateWithoutOffer_categoryInput, offersUncheckedCreateWithoutOffer_categoryInput>
  }

  export type categoriesUpsertWithoutOffer_categoryInput = {
    update: XOR<categoriesUpdateWithoutOffer_categoryInput, categoriesUncheckedUpdateWithoutOffer_categoryInput>
    create: XOR<categoriesCreateWithoutOffer_categoryInput, categoriesUncheckedCreateWithoutOffer_categoryInput>
    where?: categoriesWhereInput
  }

  export type categoriesUpdateToOneWithWhereWithoutOffer_categoryInput = {
    where?: categoriesWhereInput
    data: XOR<categoriesUpdateWithoutOffer_categoryInput, categoriesUncheckedUpdateWithoutOffer_categoryInput>
  }

  export type categoriesUpdateWithoutOffer_categoryInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutCategoriesNestedInput
    categories?: categoriesUpdateOneWithoutOther_categoriesNestedInput
    other_categories?: categoriesUpdateManyWithoutCategoriesNestedInput
    integration_category_mappings?: integration_category_mappingsUpdateManyWithoutCategoriesNestedInput
    offers?: offersUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutOffer_categoryInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_categories?: categoriesUncheckedUpdateManyWithoutCategoriesNestedInput
    integration_category_mappings?: integration_category_mappingsUncheckedUpdateManyWithoutCategoriesNestedInput
    offers?: offersUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type offersUpsertWithoutOffer_categoryInput = {
    update: XOR<offersUpdateWithoutOffer_categoryInput, offersUncheckedUpdateWithoutOffer_categoryInput>
    create: XOR<offersCreateWithoutOffer_categoryInput, offersUncheckedCreateWithoutOffer_categoryInput>
    where?: offersWhereInput
  }

  export type offersUpdateToOneWithWhereWithoutOffer_categoryInput = {
    where?: offersWhereInput
    data: XOR<offersUpdateWithoutOffer_categoryInput, offersUncheckedUpdateWithoutOffer_categoryInput>
  }

  export type offersUpdateWithoutOffer_categoryInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    product_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_exclusive?: BoolFieldUpdateOperationsInput | boolean
    is_deal?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    product_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    old_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: Enumoffers_typeFieldUpdateOperationsInput | $Enums.offers_type
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateOneWithoutOffersNestedInput
    companies?: companiesUpdateOneRequiredWithoutOffersNestedInput
    stores?: storesUpdateOneRequiredWithoutOffersNestedInput
  }

  export type offersUncheckedUpdateWithoutOffer_categoryInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    store_id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    product_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_exclusive?: BoolFieldUpdateOperationsInput | boolean
    is_deal?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    product_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    old_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: Enumoffers_typeFieldUpdateOperationsInput | $Enums.offers_type
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type offer_categoryCreateWithoutOffersInput = {
    id?: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories: categoriesCreateNestedOneWithoutOffer_categoryInput
  }

  export type offer_categoryUncheckedCreateWithoutOffersInput = {
    id?: bigint | number
    category_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type offer_categoryCreateOrConnectWithoutOffersInput = {
    where: offer_categoryWhereUniqueInput
    create: XOR<offer_categoryCreateWithoutOffersInput, offer_categoryUncheckedCreateWithoutOffersInput>
  }

  export type offer_categoryCreateManyOffersInputEnvelope = {
    data: offer_categoryCreateManyOffersInput | offer_categoryCreateManyOffersInput[]
    skipDuplicates?: boolean
  }

  export type categoriesCreateWithoutOffersInput = {
    id?: bigint | number
    name: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    companies: companiesCreateNestedOneWithoutCategoriesInput
    categories?: categoriesCreateNestedOneWithoutOther_categoriesInput
    other_categories?: categoriesCreateNestedManyWithoutCategoriesInput
    integration_category_mappings?: integration_category_mappingsCreateNestedManyWithoutCategoriesInput
    offer_category?: offer_categoryCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesUncheckedCreateWithoutOffersInput = {
    id?: bigint | number
    name: string
    parent_id?: bigint | number | null
    company_id: bigint | number
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    other_categories?: categoriesUncheckedCreateNestedManyWithoutCategoriesInput
    integration_category_mappings?: integration_category_mappingsUncheckedCreateNestedManyWithoutCategoriesInput
    offer_category?: offer_categoryUncheckedCreateNestedManyWithoutCategoriesInput
  }

  export type categoriesCreateOrConnectWithoutOffersInput = {
    where: categoriesWhereUniqueInput
    create: XOR<categoriesCreateWithoutOffersInput, categoriesUncheckedCreateWithoutOffersInput>
  }

  export type companiesCreateWithoutOffersInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutCompaniesInput
    company_frontend_settings?: company_frontend_settingsCreateNestedManyWithoutCompaniesInput
    company_integrations?: company_integrationsCreateNestedManyWithoutCompaniesInput
    company_profiles?: company_profilesCreateNestedManyWithoutCompaniesInput
    company_subscriptions?: company_subscriptionsCreateNestedManyWithoutCompaniesInput
    integration_category_mappings?: integration_category_mappingsCreateNestedManyWithoutCompaniesInput
    stores?: storesCreateNestedManyWithoutCompaniesInput
    users?: usersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutOffersInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutCompaniesInput
    company_frontend_settings?: company_frontend_settingsUncheckedCreateNestedManyWithoutCompaniesInput
    company_integrations?: company_integrationsUncheckedCreateNestedManyWithoutCompaniesInput
    company_profiles?: company_profilesUncheckedCreateNestedManyWithoutCompaniesInput
    company_subscriptions?: company_subscriptionsUncheckedCreateNestedManyWithoutCompaniesInput
    integration_category_mappings?: integration_category_mappingsUncheckedCreateNestedManyWithoutCompaniesInput
    stores?: storesUncheckedCreateNestedManyWithoutCompaniesInput
    users?: usersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutOffersInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutOffersInput, companiesUncheckedCreateWithoutOffersInput>
  }

  export type storesCreateWithoutOffersInput = {
    id?: bigint | number
    name: string
    image?: string | null
    description?: string | null
    status?: number
    channelId?: bigint | number | null
    channelName?: string | null
    programId?: bigint | number | null
    categoryName?: string | null
    categoryId?: bigint | number | null
    productFeedId?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
    companies: companiesCreateNestedOneWithoutStoresInput
  }

  export type storesUncheckedCreateWithoutOffersInput = {
    id?: bigint | number
    company_id: bigint | number
    name: string
    image?: string | null
    description?: string | null
    status?: number
    channelId?: bigint | number | null
    channelName?: string | null
    programId?: bigint | number | null
    categoryName?: string | null
    categoryId?: bigint | number | null
    productFeedId?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type storesCreateOrConnectWithoutOffersInput = {
    where: storesWhereUniqueInput
    create: XOR<storesCreateWithoutOffersInput, storesUncheckedCreateWithoutOffersInput>
  }

  export type offer_categoryUpsertWithWhereUniqueWithoutOffersInput = {
    where: offer_categoryWhereUniqueInput
    update: XOR<offer_categoryUpdateWithoutOffersInput, offer_categoryUncheckedUpdateWithoutOffersInput>
    create: XOR<offer_categoryCreateWithoutOffersInput, offer_categoryUncheckedCreateWithoutOffersInput>
  }

  export type offer_categoryUpdateWithWhereUniqueWithoutOffersInput = {
    where: offer_categoryWhereUniqueInput
    data: XOR<offer_categoryUpdateWithoutOffersInput, offer_categoryUncheckedUpdateWithoutOffersInput>
  }

  export type offer_categoryUpdateManyWithWhereWithoutOffersInput = {
    where: offer_categoryScalarWhereInput
    data: XOR<offer_categoryUpdateManyMutationInput, offer_categoryUncheckedUpdateManyWithoutOffersInput>
  }

  export type categoriesUpsertWithoutOffersInput = {
    update: XOR<categoriesUpdateWithoutOffersInput, categoriesUncheckedUpdateWithoutOffersInput>
    create: XOR<categoriesCreateWithoutOffersInput, categoriesUncheckedCreateWithoutOffersInput>
    where?: categoriesWhereInput
  }

  export type categoriesUpdateToOneWithWhereWithoutOffersInput = {
    where?: categoriesWhereInput
    data: XOR<categoriesUpdateWithoutOffersInput, categoriesUncheckedUpdateWithoutOffersInput>
  }

  export type categoriesUpdateWithoutOffersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutCategoriesNestedInput
    categories?: categoriesUpdateOneWithoutOther_categoriesNestedInput
    other_categories?: categoriesUpdateManyWithoutCategoriesNestedInput
    integration_category_mappings?: integration_category_mappingsUpdateManyWithoutCategoriesNestedInput
    offer_category?: offer_categoryUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutOffersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_categories?: categoriesUncheckedUpdateManyWithoutCategoriesNestedInput
    integration_category_mappings?: integration_category_mappingsUncheckedUpdateManyWithoutCategoriesNestedInput
    offer_category?: offer_categoryUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type companiesUpsertWithoutOffersInput = {
    update: XOR<companiesUpdateWithoutOffersInput, companiesUncheckedUpdateWithoutOffersInput>
    create: XOR<companiesCreateWithoutOffersInput, companiesUncheckedCreateWithoutOffersInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutOffersInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutOffersInput, companiesUncheckedUpdateWithoutOffersInput>
  }

  export type companiesUpdateWithoutOffersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutCompaniesNestedInput
    company_frontend_settings?: company_frontend_settingsUpdateManyWithoutCompaniesNestedInput
    company_integrations?: company_integrationsUpdateManyWithoutCompaniesNestedInput
    company_profiles?: company_profilesUpdateManyWithoutCompaniesNestedInput
    company_subscriptions?: company_subscriptionsUpdateManyWithoutCompaniesNestedInput
    integration_category_mappings?: integration_category_mappingsUpdateManyWithoutCompaniesNestedInput
    stores?: storesUpdateManyWithoutCompaniesNestedInput
    users?: usersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutOffersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutCompaniesNestedInput
    company_frontend_settings?: company_frontend_settingsUncheckedUpdateManyWithoutCompaniesNestedInput
    company_integrations?: company_integrationsUncheckedUpdateManyWithoutCompaniesNestedInput
    company_profiles?: company_profilesUncheckedUpdateManyWithoutCompaniesNestedInput
    company_subscriptions?: company_subscriptionsUncheckedUpdateManyWithoutCompaniesNestedInput
    integration_category_mappings?: integration_category_mappingsUncheckedUpdateManyWithoutCompaniesNestedInput
    stores?: storesUncheckedUpdateManyWithoutCompaniesNestedInput
    users?: usersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type storesUpsertWithoutOffersInput = {
    update: XOR<storesUpdateWithoutOffersInput, storesUncheckedUpdateWithoutOffersInput>
    create: XOR<storesCreateWithoutOffersInput, storesUncheckedCreateWithoutOffersInput>
    where?: storesWhereInput
  }

  export type storesUpdateToOneWithWhereWithoutOffersInput = {
    where?: storesWhereInput
    data: XOR<storesUpdateWithoutOffersInput, storesUncheckedUpdateWithoutOffersInput>
  }

  export type storesUpdateWithoutOffersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    channelId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    productFeedId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutStoresNestedInput
  }

  export type storesUncheckedUpdateWithoutOffersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    channelId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    productFeedId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_subscriptionsCreateWithoutPaymentsInput = {
    id?: bigint | number
    start_date: Date | string
    end_date: Date | string
    status: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    companies: companiesCreateNestedOneWithoutCompany_subscriptionsInput
    subscriptions: subscriptionsCreateNestedOneWithoutCompany_subscriptionsInput
  }

  export type company_subscriptionsUncheckedCreateWithoutPaymentsInput = {
    id?: bigint | number
    company_id: bigint | number
    subscription_id: bigint | number
    start_date: Date | string
    end_date: Date | string
    status: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_subscriptionsCreateOrConnectWithoutPaymentsInput = {
    where: company_subscriptionsWhereUniqueInput
    create: XOR<company_subscriptionsCreateWithoutPaymentsInput, company_subscriptionsUncheckedCreateWithoutPaymentsInput>
  }

  export type company_subscriptionsUpsertWithoutPaymentsInput = {
    update: XOR<company_subscriptionsUpdateWithoutPaymentsInput, company_subscriptionsUncheckedUpdateWithoutPaymentsInput>
    create: XOR<company_subscriptionsCreateWithoutPaymentsInput, company_subscriptionsUncheckedCreateWithoutPaymentsInput>
    where?: company_subscriptionsWhereInput
  }

  export type company_subscriptionsUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: company_subscriptionsWhereInput
    data: XOR<company_subscriptionsUpdateWithoutPaymentsInput, company_subscriptionsUncheckedUpdateWithoutPaymentsInput>
  }

  export type company_subscriptionsUpdateWithoutPaymentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutCompany_subscriptionsNestedInput
    subscriptions?: subscriptionsUpdateOneRequiredWithoutCompany_subscriptionsNestedInput
  }

  export type company_subscriptionsUncheckedUpdateWithoutPaymentsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    subscription_id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type offersCreateWithoutStoresInput = {
    id?: bigint | number
    title: string
    description?: string | null
    product_url?: string | null
    image_url?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    code?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    link?: string | null
    is_featured?: boolean
    is_exclusive?: boolean
    is_deal?: boolean
    path?: string | null
    thumbnail?: string | null
    sku?: string | null
    product_name?: string | null
    product_price?: Decimal | DecimalJsLike | number | string | null
    old_price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    type?: $Enums.offers_type
    external_id?: string | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    offer_category?: offer_categoryCreateNestedManyWithoutOffersInput
    categories?: categoriesCreateNestedOneWithoutOffersInput
    companies: companiesCreateNestedOneWithoutOffersInput
  }

  export type offersUncheckedCreateWithoutStoresInput = {
    id?: bigint | number
    company_id: bigint | number
    category_id?: bigint | number | null
    title: string
    description?: string | null
    product_url?: string | null
    image_url?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    code?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    link?: string | null
    is_featured?: boolean
    is_exclusive?: boolean
    is_deal?: boolean
    path?: string | null
    thumbnail?: string | null
    sku?: string | null
    product_name?: string | null
    product_price?: Decimal | DecimalJsLike | number | string | null
    old_price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    type?: $Enums.offers_type
    external_id?: string | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    offer_category?: offer_categoryUncheckedCreateNestedManyWithoutOffersInput
  }

  export type offersCreateOrConnectWithoutStoresInput = {
    where: offersWhereUniqueInput
    create: XOR<offersCreateWithoutStoresInput, offersUncheckedCreateWithoutStoresInput>
  }

  export type offersCreateManyStoresInputEnvelope = {
    data: offersCreateManyStoresInput | offersCreateManyStoresInput[]
    skipDuplicates?: boolean
  }

  export type companiesCreateWithoutStoresInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesCreateNestedManyWithoutCompaniesInput
    company_frontend_settings?: company_frontend_settingsCreateNestedManyWithoutCompaniesInput
    company_integrations?: company_integrationsCreateNestedManyWithoutCompaniesInput
    company_profiles?: company_profilesCreateNestedManyWithoutCompaniesInput
    company_subscriptions?: company_subscriptionsCreateNestedManyWithoutCompaniesInput
    integration_category_mappings?: integration_category_mappingsCreateNestedManyWithoutCompaniesInput
    offers?: offersCreateNestedManyWithoutCompaniesInput
    users?: usersCreateNestedManyWithoutCompaniesInput
  }

  export type companiesUncheckedCreateWithoutStoresInput = {
    id?: bigint | number
    registration_no?: string | null
    vat?: string | null
    name: string
    email: string
    domain: string
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
    categories?: categoriesUncheckedCreateNestedManyWithoutCompaniesInput
    company_frontend_settings?: company_frontend_settingsUncheckedCreateNestedManyWithoutCompaniesInput
    company_integrations?: company_integrationsUncheckedCreateNestedManyWithoutCompaniesInput
    company_profiles?: company_profilesUncheckedCreateNestedManyWithoutCompaniesInput
    company_subscriptions?: company_subscriptionsUncheckedCreateNestedManyWithoutCompaniesInput
    integration_category_mappings?: integration_category_mappingsUncheckedCreateNestedManyWithoutCompaniesInput
    offers?: offersUncheckedCreateNestedManyWithoutCompaniesInput
    users?: usersUncheckedCreateNestedManyWithoutCompaniesInput
  }

  export type companiesCreateOrConnectWithoutStoresInput = {
    where: companiesWhereUniqueInput
    create: XOR<companiesCreateWithoutStoresInput, companiesUncheckedCreateWithoutStoresInput>
  }

  export type offersUpsertWithWhereUniqueWithoutStoresInput = {
    where: offersWhereUniqueInput
    update: XOR<offersUpdateWithoutStoresInput, offersUncheckedUpdateWithoutStoresInput>
    create: XOR<offersCreateWithoutStoresInput, offersUncheckedCreateWithoutStoresInput>
  }

  export type offersUpdateWithWhereUniqueWithoutStoresInput = {
    where: offersWhereUniqueInput
    data: XOR<offersUpdateWithoutStoresInput, offersUncheckedUpdateWithoutStoresInput>
  }

  export type offersUpdateManyWithWhereWithoutStoresInput = {
    where: offersScalarWhereInput
    data: XOR<offersUpdateManyMutationInput, offersUncheckedUpdateManyWithoutStoresInput>
  }

  export type companiesUpsertWithoutStoresInput = {
    update: XOR<companiesUpdateWithoutStoresInput, companiesUncheckedUpdateWithoutStoresInput>
    create: XOR<companiesCreateWithoutStoresInput, companiesUncheckedCreateWithoutStoresInput>
    where?: companiesWhereInput
  }

  export type companiesUpdateToOneWithWhereWithoutStoresInput = {
    where?: companiesWhereInput
    data: XOR<companiesUpdateWithoutStoresInput, companiesUncheckedUpdateWithoutStoresInput>
  }

  export type companiesUpdateWithoutStoresInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateManyWithoutCompaniesNestedInput
    company_frontend_settings?: company_frontend_settingsUpdateManyWithoutCompaniesNestedInput
    company_integrations?: company_integrationsUpdateManyWithoutCompaniesNestedInput
    company_profiles?: company_profilesUpdateManyWithoutCompaniesNestedInput
    company_subscriptions?: company_subscriptionsUpdateManyWithoutCompaniesNestedInput
    integration_category_mappings?: integration_category_mappingsUpdateManyWithoutCompaniesNestedInput
    offers?: offersUpdateManyWithoutCompaniesNestedInput
    users?: usersUpdateManyWithoutCompaniesNestedInput
  }

  export type companiesUncheckedUpdateWithoutStoresInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    registration_no?: NullableStringFieldUpdateOperationsInput | string | null
    vat?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    domain?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUncheckedUpdateManyWithoutCompaniesNestedInput
    company_frontend_settings?: company_frontend_settingsUncheckedUpdateManyWithoutCompaniesNestedInput
    company_integrations?: company_integrationsUncheckedUpdateManyWithoutCompaniesNestedInput
    company_profiles?: company_profilesUncheckedUpdateManyWithoutCompaniesNestedInput
    company_subscriptions?: company_subscriptionsUncheckedUpdateManyWithoutCompaniesNestedInput
    integration_category_mappings?: integration_category_mappingsUncheckedUpdateManyWithoutCompaniesNestedInput
    offers?: offersUncheckedUpdateManyWithoutCompaniesNestedInput
    users?: usersUncheckedUpdateManyWithoutCompaniesNestedInput
  }

  export type company_subscriptionsCreateWithoutSubscriptionsInput = {
    id?: bigint | number
    start_date: Date | string
    end_date: Date | string
    status: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    companies: companiesCreateNestedOneWithoutCompany_subscriptionsInput
    payments?: paymentsCreateNestedManyWithoutCompany_subscriptionsInput
  }

  export type company_subscriptionsUncheckedCreateWithoutSubscriptionsInput = {
    id?: bigint | number
    company_id: bigint | number
    start_date: Date | string
    end_date: Date | string
    status: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
    payments?: paymentsUncheckedCreateNestedManyWithoutCompany_subscriptionsInput
  }

  export type company_subscriptionsCreateOrConnectWithoutSubscriptionsInput = {
    where: company_subscriptionsWhereUniqueInput
    create: XOR<company_subscriptionsCreateWithoutSubscriptionsInput, company_subscriptionsUncheckedCreateWithoutSubscriptionsInput>
  }

  export type company_subscriptionsCreateManySubscriptionsInputEnvelope = {
    data: company_subscriptionsCreateManySubscriptionsInput | company_subscriptionsCreateManySubscriptionsInput[]
    skipDuplicates?: boolean
  }

  export type company_subscriptionsUpsertWithWhereUniqueWithoutSubscriptionsInput = {
    where: company_subscriptionsWhereUniqueInput
    update: XOR<company_subscriptionsUpdateWithoutSubscriptionsInput, company_subscriptionsUncheckedUpdateWithoutSubscriptionsInput>
    create: XOR<company_subscriptionsCreateWithoutSubscriptionsInput, company_subscriptionsUncheckedCreateWithoutSubscriptionsInput>
  }

  export type company_subscriptionsUpdateWithWhereUniqueWithoutSubscriptionsInput = {
    where: company_subscriptionsWhereUniqueInput
    data: XOR<company_subscriptionsUpdateWithoutSubscriptionsInput, company_subscriptionsUncheckedUpdateWithoutSubscriptionsInput>
  }

  export type company_subscriptionsUpdateManyWithWhereWithoutSubscriptionsInput = {
    where: company_subscriptionsScalarWhereInput
    data: XOR<company_subscriptionsUpdateManyMutationInput, company_subscriptionsUncheckedUpdateManyWithoutSubscriptionsInput>
  }

  export type model_has_permissionsCreateManyPermissionsInput = {
    model_type: string
    model_id: bigint | number
  }

  export type role_has_permissionsCreateManyPermissionsInput = {
    role_id: bigint | number
  }

  export type model_has_permissionsUpdateWithoutPermissionsInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_permissionsUncheckedUpdateWithoutPermissionsInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_permissionsUncheckedUpdateManyWithoutPermissionsInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type role_has_permissionsUpdateWithoutPermissionsInput = {
    roles?: rolesUpdateOneRequiredWithoutRole_has_permissionsNestedInput
  }

  export type role_has_permissionsUncheckedUpdateWithoutPermissionsInput = {
    role_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type role_has_permissionsUncheckedUpdateManyWithoutPermissionsInput = {
    role_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_rolesCreateManyRolesInput = {
    model_type: string
    model_id: bigint | number
  }

  export type role_has_permissionsCreateManyRolesInput = {
    permission_id: bigint | number
  }

  export type model_has_rolesUpdateWithoutRolesInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_rolesUncheckedUpdateWithoutRolesInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type model_has_rolesUncheckedUpdateManyWithoutRolesInput = {
    model_type?: StringFieldUpdateOperationsInput | string
    model_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type role_has_permissionsUpdateWithoutRolesInput = {
    permissions?: permissionsUpdateOneRequiredWithoutRole_has_permissionsNestedInput
  }

  export type role_has_permissionsUncheckedUpdateWithoutRolesInput = {
    permission_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type role_has_permissionsUncheckedUpdateManyWithoutRolesInput = {
    permission_id?: BigIntFieldUpdateOperationsInput | bigint | number
  }

  export type categoriesCreateManyCategoriesInput = {
    id?: bigint | number
    name: string
    company_id: bigint | number
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type integration_category_mappingsCreateManyCategoriesInput = {
    id?: bigint | number
    company_id?: bigint | number | null
    provider: string
    external_category: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type offer_categoryCreateManyCategoriesInput = {
    id?: bigint | number
    offer_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type offersCreateManyCategoriesInput = {
    id?: bigint | number
    company_id: bigint | number
    store_id: bigint | number
    title: string
    description?: string | null
    product_url?: string | null
    image_url?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    code?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    link?: string | null
    is_featured?: boolean
    is_exclusive?: boolean
    is_deal?: boolean
    path?: string | null
    thumbnail?: string | null
    sku?: string | null
    product_name?: string | null
    product_price?: Decimal | DecimalJsLike | number | string | null
    old_price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    type?: $Enums.offers_type
    external_id?: string | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type categoriesUpdateWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutCategoriesNestedInput
    other_categories?: categoriesUpdateManyWithoutCategoriesNestedInput
    integration_category_mappings?: integration_category_mappingsUpdateManyWithoutCategoriesNestedInput
    offer_category?: offer_categoryUpdateManyWithoutCategoriesNestedInput
    offers?: offersUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_categories?: categoriesUncheckedUpdateManyWithoutCategoriesNestedInput
    integration_category_mappings?: integration_category_mappingsUncheckedUpdateManyWithoutCategoriesNestedInput
    offer_category?: offer_categoryUncheckedUpdateManyWithoutCategoriesNestedInput
    offers?: offersUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateManyWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type integration_category_mappingsUpdateWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    provider?: StringFieldUpdateOperationsInput | string
    external_category?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneWithoutIntegration_category_mappingsNestedInput
  }

  export type integration_category_mappingsUncheckedUpdateWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    provider?: StringFieldUpdateOperationsInput | string
    external_category?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type integration_category_mappingsUncheckedUpdateManyWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    provider?: StringFieldUpdateOperationsInput | string
    external_category?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type offer_categoryUpdateWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offers?: offersUpdateOneRequiredWithoutOffer_categoryNestedInput
  }

  export type offer_categoryUncheckedUpdateWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    offer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type offer_categoryUncheckedUpdateManyWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    offer_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type offersUpdateWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    product_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_exclusive?: BoolFieldUpdateOperationsInput | boolean
    is_deal?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    product_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    old_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: Enumoffers_typeFieldUpdateOperationsInput | $Enums.offers_type
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offer_category?: offer_categoryUpdateManyWithoutOffersNestedInput
    companies?: companiesUpdateOneRequiredWithoutOffersNestedInput
    stores?: storesUpdateOneRequiredWithoutOffersNestedInput
  }

  export type offersUncheckedUpdateWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    store_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    product_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_exclusive?: BoolFieldUpdateOperationsInput | boolean
    is_deal?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    product_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    old_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: Enumoffers_typeFieldUpdateOperationsInput | $Enums.offers_type
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offer_category?: offer_categoryUncheckedUpdateManyWithoutOffersNestedInput
  }

  export type offersUncheckedUpdateManyWithoutCategoriesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    store_id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    product_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_exclusive?: BoolFieldUpdateOperationsInput | boolean
    is_deal?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    product_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    old_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: Enumoffers_typeFieldUpdateOperationsInput | $Enums.offers_type
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type categoriesCreateManyCompaniesInput = {
    id?: bigint | number
    name: string
    parent_id?: bigint | number | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_frontend_settingsCreateManyCompaniesInput = {
    id?: bigint | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_integrationsCreateManyCompaniesInput = {
    id?: bigint | number
    provider: string
    credentials: JsonNullValueInput | InputJsonValue
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_profilesCreateManyCompaniesInput = {
    id?: bigint | number
    phone?: string | null
    address?: string | null
    country?: string | null
    zipcode?: string | null
    city?: string | null
    state?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_subscriptionsCreateManyCompaniesInput = {
    id?: bigint | number
    subscription_id: bigint | number
    start_date: Date | string
    end_date: Date | string
    status: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type integration_category_mappingsCreateManyCompaniesInput = {
    id?: bigint | number
    provider: string
    external_category: string
    category_id?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type offersCreateManyCompaniesInput = {
    id?: bigint | number
    store_id: bigint | number
    category_id?: bigint | number | null
    title: string
    description?: string | null
    product_url?: string | null
    image_url?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    code?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    link?: string | null
    is_featured?: boolean
    is_exclusive?: boolean
    is_deal?: boolean
    path?: string | null
    thumbnail?: string | null
    sku?: string | null
    product_name?: string | null
    product_price?: Decimal | DecimalJsLike | number | string | null
    old_price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    type?: $Enums.offers_type
    external_id?: string | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type storesCreateManyCompaniesInput = {
    id?: bigint | number
    name: string
    image?: string | null
    description?: string | null
    status?: number
    channelId?: bigint | number | null
    channelName?: string | null
    programId?: bigint | number | null
    categoryName?: string | null
    categoryId?: bigint | number | null
    productFeedId?: bigint | number | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type usersCreateManyCompaniesInput = {
    id?: bigint | number
    name: string
    email: string
    email_verified_at?: Date | string | null
    password: string
    remember_token?: string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type categoriesUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateOneWithoutOther_categoriesNestedInput
    other_categories?: categoriesUpdateManyWithoutCategoriesNestedInput
    integration_category_mappings?: integration_category_mappingsUpdateManyWithoutCategoriesNestedInput
    offer_category?: offer_categoryUpdateManyWithoutCategoriesNestedInput
    offers?: offersUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_categories?: categoriesUncheckedUpdateManyWithoutCategoriesNestedInput
    integration_category_mappings?: integration_category_mappingsUncheckedUpdateManyWithoutCategoriesNestedInput
    offer_category?: offer_categoryUncheckedUpdateManyWithoutCategoriesNestedInput
    offers?: offersUncheckedUpdateManyWithoutCategoriesNestedInput
  }

  export type categoriesUncheckedUpdateManyWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    parent_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_frontend_settingsUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_frontend_settingsUncheckedUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_frontend_settingsUncheckedUpdateManyWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    settings?: NullableJsonNullValueInput | InputJsonValue
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_integrationsUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    provider?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_integrationsUncheckedUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    provider?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_integrationsUncheckedUpdateManyWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    provider?: StringFieldUpdateOperationsInput | string
    credentials?: JsonNullValueInput | InputJsonValue
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_profilesUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_profilesUncheckedUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_profilesUncheckedUpdateManyWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    country?: NullableStringFieldUpdateOperationsInput | string | null
    zipcode?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    state?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_subscriptionsUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    subscriptions?: subscriptionsUpdateOneRequiredWithoutCompany_subscriptionsNestedInput
    payments?: paymentsUpdateManyWithoutCompany_subscriptionsNestedInput
  }

  export type company_subscriptionsUncheckedUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    subscription_id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payments?: paymentsUncheckedUpdateManyWithoutCompany_subscriptionsNestedInput
  }

  export type company_subscriptionsUncheckedUpdateManyWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    subscription_id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type integration_category_mappingsUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    provider?: StringFieldUpdateOperationsInput | string
    external_category?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateOneWithoutIntegration_category_mappingsNestedInput
  }

  export type integration_category_mappingsUncheckedUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    provider?: StringFieldUpdateOperationsInput | string
    external_category?: StringFieldUpdateOperationsInput | string
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type integration_category_mappingsUncheckedUpdateManyWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    provider?: StringFieldUpdateOperationsInput | string
    external_category?: StringFieldUpdateOperationsInput | string
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type offersUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    product_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_exclusive?: BoolFieldUpdateOperationsInput | boolean
    is_deal?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    product_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    old_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: Enumoffers_typeFieldUpdateOperationsInput | $Enums.offers_type
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offer_category?: offer_categoryUpdateManyWithoutOffersNestedInput
    categories?: categoriesUpdateOneWithoutOffersNestedInput
    stores?: storesUpdateOneRequiredWithoutOffersNestedInput
  }

  export type offersUncheckedUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    store_id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    product_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_exclusive?: BoolFieldUpdateOperationsInput | boolean
    is_deal?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    product_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    old_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: Enumoffers_typeFieldUpdateOperationsInput | $Enums.offers_type
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offer_category?: offer_categoryUncheckedUpdateManyWithoutOffersNestedInput
  }

  export type offersUncheckedUpdateManyWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    store_id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    product_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_exclusive?: BoolFieldUpdateOperationsInput | boolean
    is_deal?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    product_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    old_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: Enumoffers_typeFieldUpdateOperationsInput | $Enums.offers_type
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type storesUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    channelId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    productFeedId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offers?: offersUpdateManyWithoutStoresNestedInput
  }

  export type storesUncheckedUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    channelId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    productFeedId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offers?: offersUncheckedUpdateManyWithoutStoresNestedInput
  }

  export type storesUncheckedUpdateManyWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    image?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    channelId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    channelName?: NullableStringFieldUpdateOperationsInput | string | null
    programId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    categoryName?: NullableStringFieldUpdateOperationsInput | string | null
    categoryId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    productFeedId?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type usersUncheckedUpdateManyWithoutCompaniesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    email_verified_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    password?: StringFieldUpdateOperationsInput | string
    remember_token?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsCreateManyCompany_subscriptionsInput = {
    id?: bigint | number
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    payment_status: string
    transaction_id?: string | null
    paid_at?: Date | string | null
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type paymentsUpdateWithoutCompany_subscriptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    payment_status?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsUncheckedUpdateWithoutCompany_subscriptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    payment_status?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type paymentsUncheckedUpdateManyWithoutCompany_subscriptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    payment_status?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type menusCreateManyMenusInput = {
    id?: bigint | number
    title: string
    href?: string | null
    icon?: string | null
    role?: string | null
    permission?: string | null
    order?: number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type menusUpdateWithoutMenusInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    href?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_menus?: menusUpdateManyWithoutMenusNestedInput
  }

  export type menusUncheckedUpdateWithoutMenusInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    href?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    other_menus?: menusUncheckedUpdateManyWithoutMenusNestedInput
  }

  export type menusUncheckedUpdateManyWithoutMenusInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    href?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    role?: NullableStringFieldUpdateOperationsInput | string | null
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type offer_categoryCreateManyOffersInput = {
    id?: bigint | number
    category_id: bigint | number
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type offer_categoryUpdateWithoutOffersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    categories?: categoriesUpdateOneRequiredWithoutOffer_categoryNestedInput
  }

  export type offer_categoryUncheckedUpdateWithoutOffersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type offer_categoryUncheckedUpdateManyWithoutOffersInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type offersCreateManyStoresInput = {
    id?: bigint | number
    company_id: bigint | number
    category_id?: bigint | number | null
    title: string
    description?: string | null
    product_url?: string | null
    image_url?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    code?: string | null
    start_date?: Date | string | null
    end_date?: Date | string | null
    link?: string | null
    is_featured?: boolean
    is_exclusive?: boolean
    is_deal?: boolean
    path?: string | null
    thumbnail?: string | null
    sku?: string | null
    product_name?: string | null
    product_price?: Decimal | DecimalJsLike | number | string | null
    old_price?: Decimal | DecimalJsLike | number | string | null
    source?: string | null
    type?: $Enums.offers_type
    external_id?: string | null
    status?: boolean
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type offersUpdateWithoutStoresInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    product_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_exclusive?: BoolFieldUpdateOperationsInput | boolean
    is_deal?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    product_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    old_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: Enumoffers_typeFieldUpdateOperationsInput | $Enums.offers_type
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offer_category?: offer_categoryUpdateManyWithoutOffersNestedInput
    categories?: categoriesUpdateOneWithoutOffersNestedInput
    companies?: companiesUpdateOneRequiredWithoutOffersNestedInput
  }

  export type offersUncheckedUpdateWithoutStoresInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    product_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_exclusive?: BoolFieldUpdateOperationsInput | boolean
    is_deal?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    product_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    old_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: Enumoffers_typeFieldUpdateOperationsInput | $Enums.offers_type
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    offer_category?: offer_categoryUncheckedUpdateManyWithoutOffersNestedInput
  }

  export type offersUncheckedUpdateManyWithoutStoresInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    category_id?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    product_url?: NullableStringFieldUpdateOperationsInput | string | null
    image_url?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    start_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    link?: NullableStringFieldUpdateOperationsInput | string | null
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    is_exclusive?: BoolFieldUpdateOperationsInput | boolean
    is_deal?: BoolFieldUpdateOperationsInput | boolean
    path?: NullableStringFieldUpdateOperationsInput | string | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    sku?: NullableStringFieldUpdateOperationsInput | string | null
    product_name?: NullableStringFieldUpdateOperationsInput | string | null
    product_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    old_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    type?: Enumoffers_typeFieldUpdateOperationsInput | $Enums.offers_type
    external_id?: NullableStringFieldUpdateOperationsInput | string | null
    status?: BoolFieldUpdateOperationsInput | boolean
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type company_subscriptionsCreateManySubscriptionsInput = {
    id?: bigint | number
    company_id: bigint | number
    start_date: Date | string
    end_date: Date | string
    status: string
    created_at?: Date | string | null
    updated_at?: Date | string | null
  }

  export type company_subscriptionsUpdateWithoutSubscriptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    companies?: companiesUpdateOneRequiredWithoutCompany_subscriptionsNestedInput
    payments?: paymentsUpdateManyWithoutCompany_subscriptionsNestedInput
  }

  export type company_subscriptionsUncheckedUpdateWithoutSubscriptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    payments?: paymentsUncheckedUpdateManyWithoutCompany_subscriptionsNestedInput
  }

  export type company_subscriptionsUncheckedUpdateManyWithoutSubscriptionsInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    company_id?: BigIntFieldUpdateOperationsInput | bigint | number
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    created_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    updated_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}